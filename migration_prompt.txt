\*\*Provided Components (Assume these have been added to the repository):\*\* 1. \*\*\`proto/\`\*\*: Directory with Protobuf definitions (\`task\_control.proto\`, etc.) and build scripts. Ensure protos are compiled. 2. \*\*\`src/services/grpc/server.ts\`\*\*: (Originally \`externalGrpcServer.ts\`) Implements the gRPC server using a callback/notifier pattern (\`GrpcServerCallbacks\`, \`GrpcTaskNotifier\`). 3. \*\*\`src/services/grpc/mapper.ts\`\*\*: (Originally \`grpc-mapper.ts\`) Handles mapping between internal Cline types and Protobuf types. 4. \*\*\`src/services/grpc/utils.ts\`\*\*: (Originally \`proto-mapper.ts\`) Contains utility functions for Protobuf map conversions. 5. \*\*(Optional) \`tools/sandbox-client/\`\*\*: External Go client for testing the gRPC interface. \*\*Integration Strategy (Inspired by \`TestServer.ts\` but for external control):\*\* 1. \*\*Create \`src/services/grpc/GrpcBridge.ts\`:\*\* This new module will be the central integration point. 2. \*\*Initialize in \`src/extension.ts\`:\*\* \* In the \`activate\` function of \`src/extension.ts\`, import and instantiate \`GrpcBridge\`. \* Pass necessary context (like \`vscode.ExtensionContext\`, maybe the \`WebviewProvider\` instance if needed for message interception) to the \`GrpcBridge\` constructor. \* Ensure the \`GrpcBridge\` is properly disposed of in the \`deactivate\` function. 3. \*\*\`GrpcBridge\` Responsibilities:\*\* \* \*\*Start gRPC Server:\*\* Import \`startExternalGrpcServer\` from \`server.ts\`. Implement the \`GrpcServerCallbacks\` interface within \`GrpcBridge\`. Call \`startExternalGrpcServer\`, passing the callback implementations and storing the returned \`GrpcTaskNotifier\`. \* \*\*Implement Callbacks:\*\* \* \`handleGrpcInitTask(clientId, text, images)\`: Should find the main \`Controller\` instance and call a method like \`controller.initTask(text, images, undefined, clientId)\` to start a task associated with the gRPC client. It needs a way to map \`clientId\` to the created \`Task\` instance (perhaps store this mapping within the bridge or controller). \* \`handleAskResponse(clientId, response)\`: Find the \`Task\` associated with \`clientId\`. Simulate a \`WebviewMessage\` or call a method on the \`Task\` (e.g., \`task.handleWebviewAskResponse(...)\`) to inject the response. \* \`handleToolResult(clientId, result)\`: Find the \`Task\` associated with \`clientId\`. Inject the tool result back into the task's execution loop (e.g., by calling a method like \`task.addToolResultFromExternal(result)\` - this method might need to be added cleanly to \`Task\` or its base class if absolutely necessary, or find an alternative injection point). \* \`handleUserInput(clientId, text, images)\`: Find the \`Task\` associated with \`clientId\`. Simulate a user sending input, perhaps via \`controller.handleWebviewMessage({ type: 'invoke', invoke: 'sendMessage', text, images })\`. \* \`handleGenericMessage(clientId, message)\`: Find the \`Controller\` and call \`controller.handleWebviewMessage(message)\`, potentially associating it with the correct task if needed. \* \*\*Intercept Outgoing Messages:\*\* \* Find a \*non-invasive\* way to intercept messages flowing from the \`Controller\` to the \`WebviewProvider\`. This is the most challenging part without modifying core files. Potential approaches: \* \*\*Event Listener:\*\* Check if \`Controller\` or \`WebviewProvider\` emit events that can be listened to. \* \*\*Wrapper/Proxy:\*\* In \`extension.ts\`, instead of passing the direct \`postMessage\` function to the \`Controller\`, pass a wrapped version provided by \`GrpcBridge\`. This wrapper checks if the message is for a gRPC-controlled task (using the \`clientId\`-\`Task\` map) and forwards it via the \`grpcNotifier\` \*instead of\* or \*in addition to\* the webview. \* \*\*Dynamic Patching (Use with caution):\*\* Temporarily replace \`controller.postMessageToWebview\` method at runtime (less desirable due to potential side effects). \* When an outgoing message (\`say\`, \`ask\`, \`tool\_use\`, \`state\`) related to a gRPC task is intercepted, use the stored \`grpcNotifier\` and the appropriate \`clientId\` to send the corresponding Protobuf message (using the \`mapper.ts\` functions). \* \*\*Manage \`clientId\`-\`Task\` Mapping:\*\* Maintain a map (\`Map\<string, Task>\`) to associate active gRPC client IDs with their corresponding \`Task\` instances. This map is populated during \`handleGrpcInitTask\` and cleared when a task ends or the gRPC stream disconnects. \* \*\*Cleanup:\*\* Ensure gRPC server is stopped (\`stopExternalGrpcServer\`) and any listeners/wrappers are removed when the bridge is disposed.
