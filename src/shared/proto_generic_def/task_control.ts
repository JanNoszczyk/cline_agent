// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: task_control.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire"
import { Empty } from "./google/protobuf/empty"
import { Struct, Value } from "./google/protobuf/struct"
import { StringValue } from "./google/protobuf/wrappers"

export const protobufPackage = "cline.task_control"

export enum ApiProvider {
	API_PROVIDER_UNSPECIFIED = 0,
	ANTHROPIC = 1,
	OPENROUTER = 2,
	BEDROCK = 3,
	VERTEX = 4,
	OPENAI = 5,
	OLLAMA = 6,
	LMSTUDIO = 7,
	GEMINI = 8,
	OPENAI_NATIVE = 9,
	REQUESTY = 10,
	TOGETHER = 11,
	DEEPSEEK = 12,
	QWEN = 13,
	DOUBAO = 14,
	MISTRAL = 15,
	VSCODE_LM = 16,
	CLINE = 17,
	LITELLM = 18,
	ASKSAGE = 19,
	XAI = 20,
	SAMBANOVA = 21,
	UNRECOGNIZED = -1,
}

export function apiProviderFromJSON(object: any): ApiProvider {
	switch (object) {
		case 0:
		case "API_PROVIDER_UNSPECIFIED":
			return ApiProvider.API_PROVIDER_UNSPECIFIED
		case 1:
		case "ANTHROPIC":
			return ApiProvider.ANTHROPIC
		case 2:
		case "OPENROUTER":
			return ApiProvider.OPENROUTER
		case 3:
		case "BEDROCK":
			return ApiProvider.BEDROCK
		case 4:
		case "VERTEX":
			return ApiProvider.VERTEX
		case 5:
		case "OPENAI":
			return ApiProvider.OPENAI
		case 6:
		case "OLLAMA":
			return ApiProvider.OLLAMA
		case 7:
		case "LMSTUDIO":
			return ApiProvider.LMSTUDIO
		case 8:
		case "GEMINI":
			return ApiProvider.GEMINI
		case 9:
		case "OPENAI_NATIVE":
			return ApiProvider.OPENAI_NATIVE
		case 10:
		case "REQUESTY":
			return ApiProvider.REQUESTY
		case 11:
		case "TOGETHER":
			return ApiProvider.TOGETHER
		case 12:
		case "DEEPSEEK":
			return ApiProvider.DEEPSEEK
		case 13:
		case "QWEN":
			return ApiProvider.QWEN
		case 14:
		case "DOUBAO":
			return ApiProvider.DOUBAO
		case 15:
		case "MISTRAL":
			return ApiProvider.MISTRAL
		case 16:
		case "VSCODE_LM":
			return ApiProvider.VSCODE_LM
		case 17:
		case "CLINE":
			return ApiProvider.CLINE
		case 18:
		case "LITELLM":
			return ApiProvider.LITELLM
		case 19:
		case "ASKSAGE":
			return ApiProvider.ASKSAGE
		case 20:
		case "XAI":
			return ApiProvider.XAI
		case 21:
		case "SAMBANOVA":
			return ApiProvider.SAMBANOVA
		case -1:
		case "UNRECOGNIZED":
		default:
			return ApiProvider.UNRECOGNIZED
	}
}

export function apiProviderToJSON(object: ApiProvider): string {
	switch (object) {
		case ApiProvider.API_PROVIDER_UNSPECIFIED:
			return "API_PROVIDER_UNSPECIFIED"
		case ApiProvider.ANTHROPIC:
			return "ANTHROPIC"
		case ApiProvider.OPENROUTER:
			return "OPENROUTER"
		case ApiProvider.BEDROCK:
			return "BEDROCK"
		case ApiProvider.VERTEX:
			return "VERTEX"
		case ApiProvider.OPENAI:
			return "OPENAI"
		case ApiProvider.OLLAMA:
			return "OLLAMA"
		case ApiProvider.LMSTUDIO:
			return "LMSTUDIO"
		case ApiProvider.GEMINI:
			return "GEMINI"
		case ApiProvider.OPENAI_NATIVE:
			return "OPENAI_NATIVE"
		case ApiProvider.REQUESTY:
			return "REQUESTY"
		case ApiProvider.TOGETHER:
			return "TOGETHER"
		case ApiProvider.DEEPSEEK:
			return "DEEPSEEK"
		case ApiProvider.QWEN:
			return "QWEN"
		case ApiProvider.DOUBAO:
			return "DOUBAO"
		case ApiProvider.MISTRAL:
			return "MISTRAL"
		case ApiProvider.VSCODE_LM:
			return "VSCODE_LM"
		case ApiProvider.CLINE:
			return "CLINE"
		case ApiProvider.LITELLM:
			return "LITELLM"
		case ApiProvider.ASKSAGE:
			return "ASKSAGE"
		case ApiProvider.XAI:
			return "XAI"
		case ApiProvider.SAMBANOVA:
			return "SAMBANOVA"
		case ApiProvider.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

/**
 * From src/shared/ChatSettings.ts
 * --------------------------------
 */
export enum ChatMode {
	CHAT_MODE_UNSPECIFIED = 0,
	PLAN = 1,
	ACT = 2,
	UNRECOGNIZED = -1,
}

export function chatModeFromJSON(object: any): ChatMode {
	switch (object) {
		case 0:
		case "CHAT_MODE_UNSPECIFIED":
			return ChatMode.CHAT_MODE_UNSPECIFIED
		case 1:
		case "PLAN":
			return ChatMode.PLAN
		case 2:
		case "ACT":
			return ChatMode.ACT
		case -1:
		case "UNRECOGNIZED":
		default:
			return ChatMode.UNRECOGNIZED
	}
}

export function chatModeToJSON(object: ChatMode): string {
	switch (object) {
		case ChatMode.CHAT_MODE_UNSPECIFIED:
			return "CHAT_MODE_UNSPECIFIED"
		case ChatMode.PLAN:
			return "PLAN"
		case ChatMode.ACT:
			return "ACT"
		case ChatMode.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

/**
 * From src/shared/mcp.ts
 * -----------------------
 */
export enum McpServerStatus {
	MCP_SERVER_STATUS_UNSPECIFIED = 0,
	CONNECTED = 1,
	CONNECTING = 2,
	DISCONNECTED = 3,
	UNRECOGNIZED = -1,
}

export function mcpServerStatusFromJSON(object: any): McpServerStatus {
	switch (object) {
		case 0:
		case "MCP_SERVER_STATUS_UNSPECIFIED":
			return McpServerStatus.MCP_SERVER_STATUS_UNSPECIFIED
		case 1:
		case "CONNECTED":
			return McpServerStatus.CONNECTED
		case 2:
		case "CONNECTING":
			return McpServerStatus.CONNECTING
		case 3:
		case "DISCONNECTED":
			return McpServerStatus.DISCONNECTED
		case -1:
		case "UNRECOGNIZED":
		default:
			return McpServerStatus.UNRECOGNIZED
	}
}

export function mcpServerStatusToJSON(object: McpServerStatus): string {
	switch (object) {
		case McpServerStatus.MCP_SERVER_STATUS_UNSPECIFIED:
			return "MCP_SERVER_STATUS_UNSPECIFIED"
		case McpServerStatus.CONNECTED:
			return "CONNECTED"
		case McpServerStatus.CONNECTING:
			return "CONNECTING"
		case McpServerStatus.DISCONNECTED:
			return "DISCONNECTED"
		case McpServerStatus.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum McpViewTab {
	MCP_VIEW_TAB_UNSPECIFIED = 0,
	MARKETPLACE = 1,
	ADD_REMOTE = 2,
	INSTALLED = 3,
	UNRECOGNIZED = -1,
}

export function mcpViewTabFromJSON(object: any): McpViewTab {
	switch (object) {
		case 0:
		case "MCP_VIEW_TAB_UNSPECIFIED":
			return McpViewTab.MCP_VIEW_TAB_UNSPECIFIED
		case 1:
		case "MARKETPLACE":
			return McpViewTab.MARKETPLACE
		case 2:
		case "ADD_REMOTE":
			return McpViewTab.ADD_REMOTE
		case 3:
		case "INSTALLED":
			return McpViewTab.INSTALLED
		case -1:
		case "UNRECOGNIZED":
		default:
			return McpViewTab.UNRECOGNIZED
	}
}

export function mcpViewTabToJSON(object: McpViewTab): string {
	switch (object) {
		case McpViewTab.MCP_VIEW_TAB_UNSPECIFIED:
			return "MCP_VIEW_TAB_UNSPECIFIED"
		case McpViewTab.MARKETPLACE:
			return "MARKETPLACE"
		case McpViewTab.ADD_REMOTE:
			return "ADD_REMOTE"
		case McpViewTab.INSTALLED:
			return "INSTALLED"
		case McpViewTab.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

/**
 * From src/shared/TelemetrySetting.ts
 * -----------------------------------
 */
export enum TelemetrySettingValue {
	TELEMETRY_SETTING_UNSPECIFIED = 0,
	UNSET = 1,
	ENABLED = 2,
	DISABLED = 3,
	UNRECOGNIZED = -1,
}

export function telemetrySettingValueFromJSON(object: any): TelemetrySettingValue {
	switch (object) {
		case 0:
		case "TELEMETRY_SETTING_UNSPECIFIED":
			return TelemetrySettingValue.TELEMETRY_SETTING_UNSPECIFIED
		case 1:
		case "UNSET":
			return TelemetrySettingValue.UNSET
		case 2:
		case "ENABLED":
			return TelemetrySettingValue.ENABLED
		case 3:
		case "DISABLED":
			return TelemetrySettingValue.DISABLED
		case -1:
		case "UNRECOGNIZED":
		default:
			return TelemetrySettingValue.UNRECOGNIZED
	}
}

export function telemetrySettingValueToJSON(object: TelemetrySettingValue): string {
	switch (object) {
		case TelemetrySettingValue.TELEMETRY_SETTING_UNSPECIFIED:
			return "TELEMETRY_SETTING_UNSPECIFIED"
		case TelemetrySettingValue.UNSET:
			return "UNSET"
		case TelemetrySettingValue.ENABLED:
			return "ENABLED"
		case TelemetrySettingValue.DISABLED:
			return "DISABLED"
		case TelemetrySettingValue.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum ClineAskType {
	CLINE_ASK_TYPE_UNSPECIFIED = 0,
	/** FOLLOWUP - Corresponds to ClineAskQuestion payload */
	FOLLOWUP = 1,
	/** PLAN_MODE_RESPOND - Corresponds to ClinePlanModeResponse payload */
	PLAN_MODE_RESPOND = 2,
	/** COMMAND - Payload defined below (AskCommandPayload) */
	COMMAND = 3,
	/** COMMAND_OUTPUT - Payload defined below (AskCommandOutputPayload) */
	COMMAND_OUTPUT = 4,
	/** COMPLETION_RESULT - Payload defined below (AskCompletionResultPayload) */
	COMPLETION_RESULT = 5,
	/** TOOL - Payload defined below (AskToolPayload) */
	TOOL = 6,
	/** API_REQ_FAILED - Payload defined below (AskApiReqFailedPayload) */
	API_REQ_FAILED = 7,
	/** RESUME_TASK - Payload defined below (AskResumeTaskPayload) */
	RESUME_TASK = 8,
	/** RESUME_COMPLETED_TASK - Payload defined below (AskResumeCompletedTaskPayload) */
	RESUME_COMPLETED_TASK = 9,
	/** MISTAKE_LIMIT_REACHED - Payload defined below (AskMistakeLimitReachedPayload) */
	MISTAKE_LIMIT_REACHED = 10,
	/** AUTO_APPROVAL_MAX_REQ_REACHED - Payload defined below (AskAutoApprovalMaxReqReachedPayload) */
	AUTO_APPROVAL_MAX_REQ_REACHED = 11,
	/** BROWSER_ACTION_LAUNCH - Payload defined below (AskBrowserActionLaunchPayload) */
	BROWSER_ACTION_LAUNCH = 12,
	/** USE_MCP_SERVER - Corresponds to ClineAskUseMcpServer payload */
	USE_MCP_SERVER = 13,
	/** ASK_NEW_TASK - Corresponds to ClineAskNewTask payload - PREFIXED */
	ASK_NEW_TASK = 14,
	UNRECOGNIZED = -1,
}

export function clineAskTypeFromJSON(object: any): ClineAskType {
	switch (object) {
		case 0:
		case "CLINE_ASK_TYPE_UNSPECIFIED":
			return ClineAskType.CLINE_ASK_TYPE_UNSPECIFIED
		case 1:
		case "FOLLOWUP":
			return ClineAskType.FOLLOWUP
		case 2:
		case "PLAN_MODE_RESPOND":
			return ClineAskType.PLAN_MODE_RESPOND
		case 3:
		case "COMMAND":
			return ClineAskType.COMMAND
		case 4:
		case "COMMAND_OUTPUT":
			return ClineAskType.COMMAND_OUTPUT
		case 5:
		case "COMPLETION_RESULT":
			return ClineAskType.COMPLETION_RESULT
		case 6:
		case "TOOL":
			return ClineAskType.TOOL
		case 7:
		case "API_REQ_FAILED":
			return ClineAskType.API_REQ_FAILED
		case 8:
		case "RESUME_TASK":
			return ClineAskType.RESUME_TASK
		case 9:
		case "RESUME_COMPLETED_TASK":
			return ClineAskType.RESUME_COMPLETED_TASK
		case 10:
		case "MISTAKE_LIMIT_REACHED":
			return ClineAskType.MISTAKE_LIMIT_REACHED
		case 11:
		case "AUTO_APPROVAL_MAX_REQ_REACHED":
			return ClineAskType.AUTO_APPROVAL_MAX_REQ_REACHED
		case 12:
		case "BROWSER_ACTION_LAUNCH":
			return ClineAskType.BROWSER_ACTION_LAUNCH
		case 13:
		case "USE_MCP_SERVER":
			return ClineAskType.USE_MCP_SERVER
		case 14:
		case "ASK_NEW_TASK":
			return ClineAskType.ASK_NEW_TASK
		case -1:
		case "UNRECOGNIZED":
		default:
			return ClineAskType.UNRECOGNIZED
	}
}

export function clineAskTypeToJSON(object: ClineAskType): string {
	switch (object) {
		case ClineAskType.CLINE_ASK_TYPE_UNSPECIFIED:
			return "CLINE_ASK_TYPE_UNSPECIFIED"
		case ClineAskType.FOLLOWUP:
			return "FOLLOWUP"
		case ClineAskType.PLAN_MODE_RESPOND:
			return "PLAN_MODE_RESPOND"
		case ClineAskType.COMMAND:
			return "COMMAND"
		case ClineAskType.COMMAND_OUTPUT:
			return "COMMAND_OUTPUT"
		case ClineAskType.COMPLETION_RESULT:
			return "COMPLETION_RESULT"
		case ClineAskType.TOOL:
			return "TOOL"
		case ClineAskType.API_REQ_FAILED:
			return "API_REQ_FAILED"
		case ClineAskType.RESUME_TASK:
			return "RESUME_TASK"
		case ClineAskType.RESUME_COMPLETED_TASK:
			return "RESUME_COMPLETED_TASK"
		case ClineAskType.MISTAKE_LIMIT_REACHED:
			return "MISTAKE_LIMIT_REACHED"
		case ClineAskType.AUTO_APPROVAL_MAX_REQ_REACHED:
			return "AUTO_APPROVAL_MAX_REQ_REACHED"
		case ClineAskType.BROWSER_ACTION_LAUNCH:
			return "BROWSER_ACTION_LAUNCH"
		case ClineAskType.USE_MCP_SERVER:
			return "USE_MCP_SERVER"
		case ClineAskType.ASK_NEW_TASK:
			return "ASK_NEW_TASK"
		case ClineAskType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum ClineSayType {
	CLINE_SAY_TYPE_UNSPECIFIED = 0,
	/** SAY_TASK - Payload defined below (SayTaskPayload) - PREFIXED */
	SAY_TASK = 1,
	/** SAY_ERROR - ** CORRECTED *** Payload defined below (SayErrorPayload) */
	SAY_ERROR = 2,
	/** API_REQ_STARTED - Uses SayApiReqInfoPayload */
	API_REQ_STARTED = 3,
	/** API_REQ_FINISHED - Uses SayApiReqInfoPayload */
	API_REQ_FINISHED = 4,
	/** SAY_TEXT - ** CORRECTED *** Payload defined below (SayTextPayload) */
	SAY_TEXT = 5,
	/** REASONING - Payload defined below (SayReasoningPayload) */
	REASONING = 6,
	/** SAY_COMPLETION_RESULT - Payload defined below (SayCompletionResultPayload) - Renamed from COMPLETION_RESULT */
	SAY_COMPLETION_RESULT = 7,
	/** USER_FEEDBACK - Payload defined below (SayUserFeedbackPayload) */
	USER_FEEDBACK = 8,
	/** USER_FEEDBACK_DIFF - Payload defined below (SayUserFeedbackDiffPayload) */
	USER_FEEDBACK_DIFF = 9,
	/** API_REQ_RETRIED - Uses SayApiReqInfoPayload */
	API_REQ_RETRIED = 10,
	/** SAY_COMMAND - Payload defined below (SayCommandPayload) - Renamed from COMMAND */
	SAY_COMMAND = 11,
	/** SAY_COMMAND_OUTPUT - Payload defined below (SayCommandOutputPayload) - Renamed from COMMAND_OUTPUT */
	SAY_COMMAND_OUTPUT = 12,
	/** SAY_TOOL - Corresponds to ClineSayTool payload - Renamed from TOOL */
	SAY_TOOL = 13,
	/** SHELL_INTEGRATION_WARNING - Payload defined below (SayShellIntegrationWarningPayload) */
	SHELL_INTEGRATION_WARNING = 14,
	/** SAY_BROWSER_ACTION_LAUNCH - Payload defined below (SayBrowserActionLaunchPayload) - Renamed from BROWSER_ACTION_LAUNCH */
	SAY_BROWSER_ACTION_LAUNCH = 15,
	/** BROWSER_ACTION - Corresponds to ClineSayBrowserAction payload */
	BROWSER_ACTION = 16,
	/** BROWSER_ACTION_RESULT - Corresponds to BrowserActionResult payload */
	BROWSER_ACTION_RESULT = 17,
	/** MCP_SERVER_REQUEST_STARTED - Payload defined below (SayMcpServerRequestStartedPayload) */
	MCP_SERVER_REQUEST_STARTED = 18,
	/** MCP_SERVER_RESPONSE - Payload defined below (SayMcpServerResponsePayload) */
	MCP_SERVER_RESPONSE = 19,
	/** SAY_USE_MCP_SERVER - Payload defined below (SayUseMcpServerPayload) - Renamed from USE_MCP_SERVER */
	SAY_USE_MCP_SERVER = 20,
	/** DIFF_ERROR - Payload defined below (SayDiffErrorPayload) */
	DIFF_ERROR = 21,
	/** DELETED_API_REQS - Payload defined below (SayDeletedApiReqsPayload) */
	DELETED_API_REQS = 22,
	/** CLINEIGNORE_ERROR - Payload defined below (SayClineignoreErrorPayload) */
	CLINEIGNORE_ERROR = 23,
	/** CHECKPOINT_CREATED - Payload defined below (SayCheckpointCreatedPayload) */
	CHECKPOINT_CREATED = 24,
	/** LOAD_MCP_DOCUMENTATION - Payload defined below (SayLoadMcpDocumentationPayload) */
	LOAD_MCP_DOCUMENTATION = 25,
	UNRECOGNIZED = -1,
}

export function clineSayTypeFromJSON(object: any): ClineSayType {
	switch (object) {
		case 0:
		case "CLINE_SAY_TYPE_UNSPECIFIED":
			return ClineSayType.CLINE_SAY_TYPE_UNSPECIFIED
		case 1:
		case "SAY_TASK":
			return ClineSayType.SAY_TASK
		case 2:
		case "SAY_ERROR":
			return ClineSayType.SAY_ERROR
		case 3:
		case "API_REQ_STARTED":
			return ClineSayType.API_REQ_STARTED
		case 4:
		case "API_REQ_FINISHED":
			return ClineSayType.API_REQ_FINISHED
		case 5:
		case "SAY_TEXT":
			return ClineSayType.SAY_TEXT
		case 6:
		case "REASONING":
			return ClineSayType.REASONING
		case 7:
		case "SAY_COMPLETION_RESULT":
			return ClineSayType.SAY_COMPLETION_RESULT
		case 8:
		case "USER_FEEDBACK":
			return ClineSayType.USER_FEEDBACK
		case 9:
		case "USER_FEEDBACK_DIFF":
			return ClineSayType.USER_FEEDBACK_DIFF
		case 10:
		case "API_REQ_RETRIED":
			return ClineSayType.API_REQ_RETRIED
		case 11:
		case "SAY_COMMAND":
			return ClineSayType.SAY_COMMAND
		case 12:
		case "SAY_COMMAND_OUTPUT":
			return ClineSayType.SAY_COMMAND_OUTPUT
		case 13:
		case "SAY_TOOL":
			return ClineSayType.SAY_TOOL
		case 14:
		case "SHELL_INTEGRATION_WARNING":
			return ClineSayType.SHELL_INTEGRATION_WARNING
		case 15:
		case "SAY_BROWSER_ACTION_LAUNCH":
			return ClineSayType.SAY_BROWSER_ACTION_LAUNCH
		case 16:
		case "BROWSER_ACTION":
			return ClineSayType.BROWSER_ACTION
		case 17:
		case "BROWSER_ACTION_RESULT":
			return ClineSayType.BROWSER_ACTION_RESULT
		case 18:
		case "MCP_SERVER_REQUEST_STARTED":
			return ClineSayType.MCP_SERVER_REQUEST_STARTED
		case 19:
		case "MCP_SERVER_RESPONSE":
			return ClineSayType.MCP_SERVER_RESPONSE
		case 20:
		case "SAY_USE_MCP_SERVER":
			return ClineSayType.SAY_USE_MCP_SERVER
		case 21:
		case "DIFF_ERROR":
			return ClineSayType.DIFF_ERROR
		case 22:
		case "DELETED_API_REQS":
			return ClineSayType.DELETED_API_REQS
		case 23:
		case "CLINEIGNORE_ERROR":
			return ClineSayType.CLINEIGNORE_ERROR
		case 24:
		case "CHECKPOINT_CREATED":
			return ClineSayType.CHECKPOINT_CREATED
		case 25:
		case "LOAD_MCP_DOCUMENTATION":
			return ClineSayType.LOAD_MCP_DOCUMENTATION
		case -1:
		case "UNRECOGNIZED":
		default:
			return ClineSayType.UNRECOGNIZED
	}
}

export function clineSayTypeToJSON(object: ClineSayType): string {
	switch (object) {
		case ClineSayType.CLINE_SAY_TYPE_UNSPECIFIED:
			return "CLINE_SAY_TYPE_UNSPECIFIED"
		case ClineSayType.SAY_TASK:
			return "SAY_TASK"
		case ClineSayType.SAY_ERROR:
			return "SAY_ERROR"
		case ClineSayType.API_REQ_STARTED:
			return "API_REQ_STARTED"
		case ClineSayType.API_REQ_FINISHED:
			return "API_REQ_FINISHED"
		case ClineSayType.SAY_TEXT:
			return "SAY_TEXT"
		case ClineSayType.REASONING:
			return "REASONING"
		case ClineSayType.SAY_COMPLETION_RESULT:
			return "SAY_COMPLETION_RESULT"
		case ClineSayType.USER_FEEDBACK:
			return "USER_FEEDBACK"
		case ClineSayType.USER_FEEDBACK_DIFF:
			return "USER_FEEDBACK_DIFF"
		case ClineSayType.API_REQ_RETRIED:
			return "API_REQ_RETRIED"
		case ClineSayType.SAY_COMMAND:
			return "SAY_COMMAND"
		case ClineSayType.SAY_COMMAND_OUTPUT:
			return "SAY_COMMAND_OUTPUT"
		case ClineSayType.SAY_TOOL:
			return "SAY_TOOL"
		case ClineSayType.SHELL_INTEGRATION_WARNING:
			return "SHELL_INTEGRATION_WARNING"
		case ClineSayType.SAY_BROWSER_ACTION_LAUNCH:
			return "SAY_BROWSER_ACTION_LAUNCH"
		case ClineSayType.BROWSER_ACTION:
			return "BROWSER_ACTION"
		case ClineSayType.BROWSER_ACTION_RESULT:
			return "BROWSER_ACTION_RESULT"
		case ClineSayType.MCP_SERVER_REQUEST_STARTED:
			return "MCP_SERVER_REQUEST_STARTED"
		case ClineSayType.MCP_SERVER_RESPONSE:
			return "MCP_SERVER_RESPONSE"
		case ClineSayType.SAY_USE_MCP_SERVER:
			return "SAY_USE_MCP_SERVER"
		case ClineSayType.DIFF_ERROR:
			return "DIFF_ERROR"
		case ClineSayType.DELETED_API_REQS:
			return "DELETED_API_REQS"
		case ClineSayType.CLINEIGNORE_ERROR:
			return "CLINEIGNORE_ERROR"
		case ClineSayType.CHECKPOINT_CREATED:
			return "CHECKPOINT_CREATED"
		case ClineSayType.LOAD_MCP_DOCUMENTATION:
			return "LOAD_MCP_DOCUMENTATION"
		case ClineSayType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum ClineApiReqCancelReason {
	CLINE_API_REQ_CANCEL_REASON_UNSPECIFIED = 0,
	STREAMING_FAILED = 1,
	USER_CANCELLED = 2,
	UNRECOGNIZED = -1,
}

export function clineApiReqCancelReasonFromJSON(object: any): ClineApiReqCancelReason {
	switch (object) {
		case 0:
		case "CLINE_API_REQ_CANCEL_REASON_UNSPECIFIED":
			return ClineApiReqCancelReason.CLINE_API_REQ_CANCEL_REASON_UNSPECIFIED
		case 1:
		case "STREAMING_FAILED":
			return ClineApiReqCancelReason.STREAMING_FAILED
		case 2:
		case "USER_CANCELLED":
			return ClineApiReqCancelReason.USER_CANCELLED
		case -1:
		case "UNRECOGNIZED":
		default:
			return ClineApiReqCancelReason.UNRECOGNIZED
	}
}

export function clineApiReqCancelReasonToJSON(object: ClineApiReqCancelReason): string {
	switch (object) {
		case ClineApiReqCancelReason.CLINE_API_REQ_CANCEL_REASON_UNSPECIFIED:
			return "CLINE_API_REQ_CANCEL_REASON_UNSPECIFIED"
		case ClineApiReqCancelReason.STREAMING_FAILED:
			return "STREAMING_FAILED"
		case ClineApiReqCancelReason.USER_CANCELLED:
			return "USER_CANCELLED"
		case ClineApiReqCancelReason.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

/** Corresponds to TS ClineSayTool */
export enum SayToolType {
	SAY_TOOL_TYPE_UNSPECIFIED = 0,
	EDITED_EXISTING_FILE = 1,
	NEW_FILE_CREATED = 2,
	READ_FILE = 3,
	LIST_FILES_TOP_LEVEL = 4,
	LIST_FILES_RECURSIVE = 5,
	LIST_CODE_DEFINITION_NAMES = 6,
	/** SAY_SEARCH_FILES - PREFIXED */
	SAY_SEARCH_FILES = 7,
	UNRECOGNIZED = -1,
}

export function sayToolTypeFromJSON(object: any): SayToolType {
	switch (object) {
		case 0:
		case "SAY_TOOL_TYPE_UNSPECIFIED":
			return SayToolType.SAY_TOOL_TYPE_UNSPECIFIED
		case 1:
		case "EDITED_EXISTING_FILE":
			return SayToolType.EDITED_EXISTING_FILE
		case 2:
		case "NEW_FILE_CREATED":
			return SayToolType.NEW_FILE_CREATED
		case 3:
		case "READ_FILE":
			return SayToolType.READ_FILE
		case 4:
		case "LIST_FILES_TOP_LEVEL":
			return SayToolType.LIST_FILES_TOP_LEVEL
		case 5:
		case "LIST_FILES_RECURSIVE":
			return SayToolType.LIST_FILES_RECURSIVE
		case 6:
		case "LIST_CODE_DEFINITION_NAMES":
			return SayToolType.LIST_CODE_DEFINITION_NAMES
		case 7:
		case "SAY_SEARCH_FILES":
			return SayToolType.SAY_SEARCH_FILES
		case -1:
		case "UNRECOGNIZED":
		default:
			return SayToolType.UNRECOGNIZED
	}
}

export function sayToolTypeToJSON(object: SayToolType): string {
	switch (object) {
		case SayToolType.SAY_TOOL_TYPE_UNSPECIFIED:
			return "SAY_TOOL_TYPE_UNSPECIFIED"
		case SayToolType.EDITED_EXISTING_FILE:
			return "EDITED_EXISTING_FILE"
		case SayToolType.NEW_FILE_CREATED:
			return "NEW_FILE_CREATED"
		case SayToolType.READ_FILE:
			return "READ_FILE"
		case SayToolType.LIST_FILES_TOP_LEVEL:
			return "LIST_FILES_TOP_LEVEL"
		case SayToolType.LIST_FILES_RECURSIVE:
			return "LIST_FILES_RECURSIVE"
		case SayToolType.LIST_CODE_DEFINITION_NAMES:
			return "LIST_CODE_DEFINITION_NAMES"
		case SayToolType.SAY_SEARCH_FILES:
			return "SAY_SEARCH_FILES"
		case SayToolType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

/** Corresponds to TS ClineSayBrowserAction */
export enum BrowserActionType {
	BROWSER_ACTION_TYPE_UNSPECIFIED = 0,
	LAUNCH = 1,
	CLICK = 2,
	TYPE = 3,
	SCROLL_DOWN = 4,
	SCROLL_UP = 5,
	CLOSE = 6,
	UNRECOGNIZED = -1,
}

export function browserActionTypeFromJSON(object: any): BrowserActionType {
	switch (object) {
		case 0:
		case "BROWSER_ACTION_TYPE_UNSPECIFIED":
			return BrowserActionType.BROWSER_ACTION_TYPE_UNSPECIFIED
		case 1:
		case "LAUNCH":
			return BrowserActionType.LAUNCH
		case 2:
		case "CLICK":
			return BrowserActionType.CLICK
		case 3:
		case "TYPE":
			return BrowserActionType.TYPE
		case 4:
		case "SCROLL_DOWN":
			return BrowserActionType.SCROLL_DOWN
		case 5:
		case "SCROLL_UP":
			return BrowserActionType.SCROLL_UP
		case 6:
		case "CLOSE":
			return BrowserActionType.CLOSE
		case -1:
		case "UNRECOGNIZED":
		default:
			return BrowserActionType.UNRECOGNIZED
	}
}

export function browserActionTypeToJSON(object: BrowserActionType): string {
	switch (object) {
		case BrowserActionType.BROWSER_ACTION_TYPE_UNSPECIFIED:
			return "BROWSER_ACTION_TYPE_UNSPECIFIED"
		case BrowserActionType.LAUNCH:
			return "LAUNCH"
		case BrowserActionType.CLICK:
			return "CLICK"
		case BrowserActionType.TYPE:
			return "TYPE"
		case BrowserActionType.SCROLL_DOWN:
			return "SCROLL_DOWN"
		case BrowserActionType.SCROLL_UP:
			return "SCROLL_UP"
		case BrowserActionType.CLOSE:
			return "CLOSE"
		case BrowserActionType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum Platform {
	PLATFORM_UNSPECIFIED = 0,
	AIX = 1,
	DARWIN = 2,
	FREEBSD = 3,
	LINUX = 4,
	OPENBSD = 5,
	SUNOS = 6,
	WIN32 = 7,
	UNKNOWN = 8,
	UNRECOGNIZED = -1,
}

export function platformFromJSON(object: any): Platform {
	switch (object) {
		case 0:
		case "PLATFORM_UNSPECIFIED":
			return Platform.PLATFORM_UNSPECIFIED
		case 1:
		case "AIX":
			return Platform.AIX
		case 2:
		case "DARWIN":
			return Platform.DARWIN
		case 3:
		case "FREEBSD":
			return Platform.FREEBSD
		case 4:
		case "LINUX":
			return Platform.LINUX
		case 5:
		case "OPENBSD":
			return Platform.OPENBSD
		case 6:
		case "SUNOS":
			return Platform.SUNOS
		case 7:
		case "WIN32":
			return Platform.WIN32
		case 8:
		case "UNKNOWN":
			return Platform.UNKNOWN
		case -1:
		case "UNRECOGNIZED":
		default:
			return Platform.UNRECOGNIZED
	}
}

export function platformToJSON(object: Platform): string {
	switch (object) {
		case Platform.PLATFORM_UNSPECIFIED:
			return "PLATFORM_UNSPECIFIED"
		case Platform.AIX:
			return "AIX"
		case Platform.DARWIN:
			return "DARWIN"
		case Platform.FREEBSD:
			return "FREEBSD"
		case Platform.LINUX:
			return "LINUX"
		case Platform.OPENBSD:
			return "OPENBSD"
		case Platform.SUNOS:
			return "SUNOS"
		case Platform.WIN32:
			return "WIN32"
		case Platform.UNKNOWN:
			return "UNKNOWN"
		case Platform.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum ExtensionMessageType {
	EXTENSION_MESSAGE_TYPE_UNSPECIFIED = 0,
	/** STATE - Corrected: TS uses 1 for STATE */
	STATE = 1,
	/** PARTIAL_MESSAGE - Corrected: TS uses 2 for PARTIAL_MESSAGE (e.g., for text streaming) */
	PARTIAL_MESSAGE = 2,
	/** TEXT - Added: For complete text messages */
	TEXT = 3,
	/** TOOL_USE - Added: For sending tool use requests */
	TOOL_USE = 4,
	/** TOOL_RESULT - Added: For sending tool results back to model */
	TOOL_RESULT = 5,
	/** SELECTED_IMAGES - Renumbered */
	SELECTED_IMAGES = 6,
	/** OLLAMA_MODELS - Renumbered */
	OLLAMA_MODELS = 7,
	/** LM_STUDIO_MODELS - Renumbered */
	LM_STUDIO_MODELS = 8,
	/** THEME - Renumbered */
	THEME = 9,
	/** WORKSPACE_UPDATED - Renumbered */
	WORKSPACE_UPDATED = 10,
	/** EXTENSION_INVOKE - Renumbered */
	EXTENSION_INVOKE = 11,
	/** OPEN_ROUTER_MODELS - Renumbered */
	OPEN_ROUTER_MODELS = 12,
	/** OPEN_AI_MODELS - Renumbered */
	OPEN_AI_MODELS = 13,
	/** REQUESTY_MODELS - Renumbered */
	REQUESTY_MODELS = 14,
	/** MCP_SERVERS - Renumbered */
	MCP_SERVERS = 15,
	/** RELINQUISH_CONTROL - Renumbered */
	RELINQUISH_CONTROL = 16,
	/** VS_CODE_LM_MODELS - Renumbered */
	VS_CODE_LM_MODELS = 17,
	/** EXTENSION_REQUEST_VS_CODE_LM_MODELS - Renumbered */
	EXTENSION_REQUEST_VS_CODE_LM_MODELS = 18,
	/** EXTENSION_AUTH_CALLBACK - Renumbered */
	EXTENSION_AUTH_CALLBACK = 19,
	/** MCP_MARKETPLACE_CATALOG - Renumbered */
	MCP_MARKETPLACE_CATALOG = 20,
	/** MCP_DOWNLOAD_DETAILS - Renumbered */
	MCP_DOWNLOAD_DETAILS = 21,
	/** COMMIT_SEARCH_RESULTS - Renumbered */
	COMMIT_SEARCH_RESULTS = 22,
	/** OPEN_GRAPH_DATA - Renumbered */
	OPEN_GRAPH_DATA = 23,
	/** IS_IMAGE_URL_RESULT - Renumbered */
	IS_IMAGE_URL_RESULT = 24,
	/** DID_UPDATE_SETTINGS - Renumbered */
	DID_UPDATE_SETTINGS = 25,
	/** ADD_REMOTE_SERVER_RESULT - Renumbered */
	ADD_REMOTE_SERVER_RESULT = 26,
	/** USER_CREDITS_BALANCE - Renumbered */
	USER_CREDITS_BALANCE = 27,
	/** USER_CREDITS_USAGE - Renumbered */
	USER_CREDITS_USAGE = 28,
	/** USER_CREDITS_PAYMENTS - Renumbered */
	USER_CREDITS_PAYMENTS = 29,
	/** TOTAL_TASKS_SIZE - Renumbered */
	TOTAL_TASKS_SIZE = 30,
	/** ADD_TO_INPUT - Renumbered */
	ADD_TO_INPUT = 31,
	/** BROWSER_CONNECTION_RESULT - Renumbered */
	BROWSER_CONNECTION_RESULT = 32,
	/** DETECTED_CHROME_PATH - Renumbered */
	DETECTED_CHROME_PATH = 33,
	/** SCROLL_TO_SETTINGS - Renumbered */
	SCROLL_TO_SETTINGS = 34,
	/** BROWSER_RELAUNCH_RESULT - Renumbered */
	BROWSER_RELAUNCH_RESULT = 35,
	/** RELATIVE_PATHS_RESPONSE - Renumbered */
	RELATIVE_PATHS_RESPONSE = 36,
	/** FILE_SEARCH_RESULTS - Renumbered */
	FILE_SEARCH_RESULTS = 37,
	/** GRPC_RESPONSE - Renumbered */
	GRPC_RESPONSE = 38,
	/** TASK_STARTED - Kept same value */
	TASK_STARTED = 39,
	/** ERROR - ACTION = 40;               // Renumbered ACTION (if needed, TS currently doesn't seem to send it) */
	ERROR = 99,
	UNRECOGNIZED = -1,
}

export function extensionMessageTypeFromJSON(object: any): ExtensionMessageType {
	switch (object) {
		case 0:
		case "EXTENSION_MESSAGE_TYPE_UNSPECIFIED":
			return ExtensionMessageType.EXTENSION_MESSAGE_TYPE_UNSPECIFIED
		case 1:
		case "STATE":
			return ExtensionMessageType.STATE
		case 2:
		case "PARTIAL_MESSAGE":
			return ExtensionMessageType.PARTIAL_MESSAGE
		case 3:
		case "TEXT":
			return ExtensionMessageType.TEXT
		case 4:
		case "TOOL_USE":
			return ExtensionMessageType.TOOL_USE
		case 5:
		case "TOOL_RESULT":
			return ExtensionMessageType.TOOL_RESULT
		case 6:
		case "SELECTED_IMAGES":
			return ExtensionMessageType.SELECTED_IMAGES
		case 7:
		case "OLLAMA_MODELS":
			return ExtensionMessageType.OLLAMA_MODELS
		case 8:
		case "LM_STUDIO_MODELS":
			return ExtensionMessageType.LM_STUDIO_MODELS
		case 9:
		case "THEME":
			return ExtensionMessageType.THEME
		case 10:
		case "WORKSPACE_UPDATED":
			return ExtensionMessageType.WORKSPACE_UPDATED
		case 11:
		case "EXTENSION_INVOKE":
			return ExtensionMessageType.EXTENSION_INVOKE
		case 12:
		case "OPEN_ROUTER_MODELS":
			return ExtensionMessageType.OPEN_ROUTER_MODELS
		case 13:
		case "OPEN_AI_MODELS":
			return ExtensionMessageType.OPEN_AI_MODELS
		case 14:
		case "REQUESTY_MODELS":
			return ExtensionMessageType.REQUESTY_MODELS
		case 15:
		case "MCP_SERVERS":
			return ExtensionMessageType.MCP_SERVERS
		case 16:
		case "RELINQUISH_CONTROL":
			return ExtensionMessageType.RELINQUISH_CONTROL
		case 17:
		case "VS_CODE_LM_MODELS":
			return ExtensionMessageType.VS_CODE_LM_MODELS
		case 18:
		case "EXTENSION_REQUEST_VS_CODE_LM_MODELS":
			return ExtensionMessageType.EXTENSION_REQUEST_VS_CODE_LM_MODELS
		case 19:
		case "EXTENSION_AUTH_CALLBACK":
			return ExtensionMessageType.EXTENSION_AUTH_CALLBACK
		case 20:
		case "MCP_MARKETPLACE_CATALOG":
			return ExtensionMessageType.MCP_MARKETPLACE_CATALOG
		case 21:
		case "MCP_DOWNLOAD_DETAILS":
			return ExtensionMessageType.MCP_DOWNLOAD_DETAILS
		case 22:
		case "COMMIT_SEARCH_RESULTS":
			return ExtensionMessageType.COMMIT_SEARCH_RESULTS
		case 23:
		case "OPEN_GRAPH_DATA":
			return ExtensionMessageType.OPEN_GRAPH_DATA
		case 24:
		case "IS_IMAGE_URL_RESULT":
			return ExtensionMessageType.IS_IMAGE_URL_RESULT
		case 25:
		case "DID_UPDATE_SETTINGS":
			return ExtensionMessageType.DID_UPDATE_SETTINGS
		case 26:
		case "ADD_REMOTE_SERVER_RESULT":
			return ExtensionMessageType.ADD_REMOTE_SERVER_RESULT
		case 27:
		case "USER_CREDITS_BALANCE":
			return ExtensionMessageType.USER_CREDITS_BALANCE
		case 28:
		case "USER_CREDITS_USAGE":
			return ExtensionMessageType.USER_CREDITS_USAGE
		case 29:
		case "USER_CREDITS_PAYMENTS":
			return ExtensionMessageType.USER_CREDITS_PAYMENTS
		case 30:
		case "TOTAL_TASKS_SIZE":
			return ExtensionMessageType.TOTAL_TASKS_SIZE
		case 31:
		case "ADD_TO_INPUT":
			return ExtensionMessageType.ADD_TO_INPUT
		case 32:
		case "BROWSER_CONNECTION_RESULT":
			return ExtensionMessageType.BROWSER_CONNECTION_RESULT
		case 33:
		case "DETECTED_CHROME_PATH":
			return ExtensionMessageType.DETECTED_CHROME_PATH
		case 34:
		case "SCROLL_TO_SETTINGS":
			return ExtensionMessageType.SCROLL_TO_SETTINGS
		case 35:
		case "BROWSER_RELAUNCH_RESULT":
			return ExtensionMessageType.BROWSER_RELAUNCH_RESULT
		case 36:
		case "RELATIVE_PATHS_RESPONSE":
			return ExtensionMessageType.RELATIVE_PATHS_RESPONSE
		case 37:
		case "FILE_SEARCH_RESULTS":
			return ExtensionMessageType.FILE_SEARCH_RESULTS
		case 38:
		case "GRPC_RESPONSE":
			return ExtensionMessageType.GRPC_RESPONSE
		case 39:
		case "TASK_STARTED":
			return ExtensionMessageType.TASK_STARTED
		case 99:
		case "ERROR":
			return ExtensionMessageType.ERROR
		case -1:
		case "UNRECOGNIZED":
		default:
			return ExtensionMessageType.UNRECOGNIZED
	}
}

export function extensionMessageTypeToJSON(object: ExtensionMessageType): string {
	switch (object) {
		case ExtensionMessageType.EXTENSION_MESSAGE_TYPE_UNSPECIFIED:
			return "EXTENSION_MESSAGE_TYPE_UNSPECIFIED"
		case ExtensionMessageType.STATE:
			return "STATE"
		case ExtensionMessageType.PARTIAL_MESSAGE:
			return "PARTIAL_MESSAGE"
		case ExtensionMessageType.TEXT:
			return "TEXT"
		case ExtensionMessageType.TOOL_USE:
			return "TOOL_USE"
		case ExtensionMessageType.TOOL_RESULT:
			return "TOOL_RESULT"
		case ExtensionMessageType.SELECTED_IMAGES:
			return "SELECTED_IMAGES"
		case ExtensionMessageType.OLLAMA_MODELS:
			return "OLLAMA_MODELS"
		case ExtensionMessageType.LM_STUDIO_MODELS:
			return "LM_STUDIO_MODELS"
		case ExtensionMessageType.THEME:
			return "THEME"
		case ExtensionMessageType.WORKSPACE_UPDATED:
			return "WORKSPACE_UPDATED"
		case ExtensionMessageType.EXTENSION_INVOKE:
			return "EXTENSION_INVOKE"
		case ExtensionMessageType.OPEN_ROUTER_MODELS:
			return "OPEN_ROUTER_MODELS"
		case ExtensionMessageType.OPEN_AI_MODELS:
			return "OPEN_AI_MODELS"
		case ExtensionMessageType.REQUESTY_MODELS:
			return "REQUESTY_MODELS"
		case ExtensionMessageType.MCP_SERVERS:
			return "MCP_SERVERS"
		case ExtensionMessageType.RELINQUISH_CONTROL:
			return "RELINQUISH_CONTROL"
		case ExtensionMessageType.VS_CODE_LM_MODELS:
			return "VS_CODE_LM_MODELS"
		case ExtensionMessageType.EXTENSION_REQUEST_VS_CODE_LM_MODELS:
			return "EXTENSION_REQUEST_VS_CODE_LM_MODELS"
		case ExtensionMessageType.EXTENSION_AUTH_CALLBACK:
			return "EXTENSION_AUTH_CALLBACK"
		case ExtensionMessageType.MCP_MARKETPLACE_CATALOG:
			return "MCP_MARKETPLACE_CATALOG"
		case ExtensionMessageType.MCP_DOWNLOAD_DETAILS:
			return "MCP_DOWNLOAD_DETAILS"
		case ExtensionMessageType.COMMIT_SEARCH_RESULTS:
			return "COMMIT_SEARCH_RESULTS"
		case ExtensionMessageType.OPEN_GRAPH_DATA:
			return "OPEN_GRAPH_DATA"
		case ExtensionMessageType.IS_IMAGE_URL_RESULT:
			return "IS_IMAGE_URL_RESULT"
		case ExtensionMessageType.DID_UPDATE_SETTINGS:
			return "DID_UPDATE_SETTINGS"
		case ExtensionMessageType.ADD_REMOTE_SERVER_RESULT:
			return "ADD_REMOTE_SERVER_RESULT"
		case ExtensionMessageType.USER_CREDITS_BALANCE:
			return "USER_CREDITS_BALANCE"
		case ExtensionMessageType.USER_CREDITS_USAGE:
			return "USER_CREDITS_USAGE"
		case ExtensionMessageType.USER_CREDITS_PAYMENTS:
			return "USER_CREDITS_PAYMENTS"
		case ExtensionMessageType.TOTAL_TASKS_SIZE:
			return "TOTAL_TASKS_SIZE"
		case ExtensionMessageType.ADD_TO_INPUT:
			return "ADD_TO_INPUT"
		case ExtensionMessageType.BROWSER_CONNECTION_RESULT:
			return "BROWSER_CONNECTION_RESULT"
		case ExtensionMessageType.DETECTED_CHROME_PATH:
			return "DETECTED_CHROME_PATH"
		case ExtensionMessageType.SCROLL_TO_SETTINGS:
			return "SCROLL_TO_SETTINGS"
		case ExtensionMessageType.BROWSER_RELAUNCH_RESULT:
			return "BROWSER_RELAUNCH_RESULT"
		case ExtensionMessageType.RELATIVE_PATHS_RESPONSE:
			return "RELATIVE_PATHS_RESPONSE"
		case ExtensionMessageType.FILE_SEARCH_RESULTS:
			return "FILE_SEARCH_RESULTS"
		case ExtensionMessageType.GRPC_RESPONSE:
			return "GRPC_RESPONSE"
		case ExtensionMessageType.TASK_STARTED:
			return "TASK_STARTED"
		case ExtensionMessageType.ERROR:
			return "ERROR"
		case ExtensionMessageType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum ActionType {
	ACTION_TYPE_UNSPECIFIED = 0,
	CHAT_BUTTON_CLICKED = 1,
	MCP_BUTTON_CLICKED = 2,
	SETTINGS_BUTTON_CLICKED = 3,
	HISTORY_BUTTON_CLICKED = 4,
	DID_BECOME_VISIBLE = 5,
	/** ACTION_ACCOUNT_LOGIN_CLICKED - PREFIXED */
	ACTION_ACCOUNT_LOGIN_CLICKED = 6,
	/** ACTION_ACCOUNT_LOGOUT_CLICKED - PREFIXED */
	ACTION_ACCOUNT_LOGOUT_CLICKED = 7,
	/** ACCOUNT_BUTTON_CLICKED - Maps to SHOW_ACCOUNT_VIEW_CLICKED? */
	ACCOUNT_BUTTON_CLICKED = 8,
	FOCUS_CHAT_INPUT = 9,
	UNRECOGNIZED = -1,
}

export function actionTypeFromJSON(object: any): ActionType {
	switch (object) {
		case 0:
		case "ACTION_TYPE_UNSPECIFIED":
			return ActionType.ACTION_TYPE_UNSPECIFIED
		case 1:
		case "CHAT_BUTTON_CLICKED":
			return ActionType.CHAT_BUTTON_CLICKED
		case 2:
		case "MCP_BUTTON_CLICKED":
			return ActionType.MCP_BUTTON_CLICKED
		case 3:
		case "SETTINGS_BUTTON_CLICKED":
			return ActionType.SETTINGS_BUTTON_CLICKED
		case 4:
		case "HISTORY_BUTTON_CLICKED":
			return ActionType.HISTORY_BUTTON_CLICKED
		case 5:
		case "DID_BECOME_VISIBLE":
			return ActionType.DID_BECOME_VISIBLE
		case 6:
		case "ACTION_ACCOUNT_LOGIN_CLICKED":
			return ActionType.ACTION_ACCOUNT_LOGIN_CLICKED
		case 7:
		case "ACTION_ACCOUNT_LOGOUT_CLICKED":
			return ActionType.ACTION_ACCOUNT_LOGOUT_CLICKED
		case 8:
		case "ACCOUNT_BUTTON_CLICKED":
			return ActionType.ACCOUNT_BUTTON_CLICKED
		case 9:
		case "FOCUS_CHAT_INPUT":
			return ActionType.FOCUS_CHAT_INPUT
		case -1:
		case "UNRECOGNIZED":
		default:
			return ActionType.UNRECOGNIZED
	}
}

export function actionTypeToJSON(object: ActionType): string {
	switch (object) {
		case ActionType.ACTION_TYPE_UNSPECIFIED:
			return "ACTION_TYPE_UNSPECIFIED"
		case ActionType.CHAT_BUTTON_CLICKED:
			return "CHAT_BUTTON_CLICKED"
		case ActionType.MCP_BUTTON_CLICKED:
			return "MCP_BUTTON_CLICKED"
		case ActionType.SETTINGS_BUTTON_CLICKED:
			return "SETTINGS_BUTTON_CLICKED"
		case ActionType.HISTORY_BUTTON_CLICKED:
			return "HISTORY_BUTTON_CLICKED"
		case ActionType.DID_BECOME_VISIBLE:
			return "DID_BECOME_VISIBLE"
		case ActionType.ACTION_ACCOUNT_LOGIN_CLICKED:
			return "ACTION_ACCOUNT_LOGIN_CLICKED"
		case ActionType.ACTION_ACCOUNT_LOGOUT_CLICKED:
			return "ACTION_ACCOUNT_LOGOUT_CLICKED"
		case ActionType.ACCOUNT_BUTTON_CLICKED:
			return "ACCOUNT_BUTTON_CLICKED"
		case ActionType.FOCUS_CHAT_INPUT:
			return "FOCUS_CHAT_INPUT"
		case ActionType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum InvokeType {
	INVOKE_TYPE_UNSPECIFIED = 0,
	SEND_MESSAGE = 1,
	PRIMARY_BUTTON_CLICK = 2,
	SECONDARY_BUTTON_CLICK = 3,
	UNRECOGNIZED = -1,
}

export function invokeTypeFromJSON(object: any): InvokeType {
	switch (object) {
		case 0:
		case "INVOKE_TYPE_UNSPECIFIED":
			return InvokeType.INVOKE_TYPE_UNSPECIFIED
		case 1:
		case "SEND_MESSAGE":
			return InvokeType.SEND_MESSAGE
		case 2:
		case "PRIMARY_BUTTON_CLICK":
			return InvokeType.PRIMARY_BUTTON_CLICK
		case 3:
		case "SECONDARY_BUTTON_CLICK":
			return InvokeType.SECONDARY_BUTTON_CLICK
		case -1:
		case "UNRECOGNIZED":
		default:
			return InvokeType.UNRECOGNIZED
	}
}

export function invokeTypeToJSON(object: InvokeType): string {
	switch (object) {
		case InvokeType.INVOKE_TYPE_UNSPECIFIED:
			return "INVOKE_TYPE_UNSPECIFIED"
		case InvokeType.SEND_MESSAGE:
			return "SEND_MESSAGE"
		case InvokeType.PRIMARY_BUTTON_CLICK:
			return "PRIMARY_BUTTON_CLICK"
		case InvokeType.SECONDARY_BUTTON_CLICK:
			return "SECONDARY_BUTTON_CLICK"
		case InvokeType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum AskResponseType {
	ASK_RESPONSE_TYPE_UNSPECIFIED = 0,
	YES_BUTTON_CLICKED = 1,
	NO_BUTTON_CLICKED = 2,
	MESSAGE_RESPONSE = 3,
	UNRECOGNIZED = -1,
}

export function askResponseTypeFromJSON(object: any): AskResponseType {
	switch (object) {
		case 0:
		case "ASK_RESPONSE_TYPE_UNSPECIFIED":
			return AskResponseType.ASK_RESPONSE_TYPE_UNSPECIFIED
		case 1:
		case "YES_BUTTON_CLICKED":
			return AskResponseType.YES_BUTTON_CLICKED
		case 2:
		case "NO_BUTTON_CLICKED":
			return AskResponseType.NO_BUTTON_CLICKED
		case 3:
		case "MESSAGE_RESPONSE":
			return AskResponseType.MESSAGE_RESPONSE
		case -1:
		case "UNRECOGNIZED":
		default:
			return AskResponseType.UNRECOGNIZED
	}
}

export function askResponseTypeToJSON(object: AskResponseType): string {
	switch (object) {
		case AskResponseType.ASK_RESPONSE_TYPE_UNSPECIFIED:
			return "ASK_RESPONSE_TYPE_UNSPECIFIED"
		case AskResponseType.YES_BUTTON_CLICKED:
			return "YES_BUTTON_CLICKED"
		case AskResponseType.NO_BUTTON_CLICKED:
			return "NO_BUTTON_CLICKED"
		case AskResponseType.MESSAGE_RESPONSE:
			return "MESSAGE_RESPONSE"
		case AskResponseType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum ClineCheckpointRestoreType {
	CLINE_CHECKPOINT_RESTORE_TYPE_UNSPECIFIED = 0,
	/** RESTORE_TASK - PREFIXED */
	RESTORE_TASK = 1,
	/** RESTORE_WORKSPACE - PREFIXED */
	RESTORE_WORKSPACE = 2,
	/** RESTORE_TASK_AND_WORKSPACE - PREFIXED */
	RESTORE_TASK_AND_WORKSPACE = 3,
	UNRECOGNIZED = -1,
}

export function clineCheckpointRestoreTypeFromJSON(object: any): ClineCheckpointRestoreType {
	switch (object) {
		case 0:
		case "CLINE_CHECKPOINT_RESTORE_TYPE_UNSPECIFIED":
			return ClineCheckpointRestoreType.CLINE_CHECKPOINT_RESTORE_TYPE_UNSPECIFIED
		case 1:
		case "RESTORE_TASK":
			return ClineCheckpointRestoreType.RESTORE_TASK
		case 2:
		case "RESTORE_WORKSPACE":
			return ClineCheckpointRestoreType.RESTORE_WORKSPACE
		case 3:
		case "RESTORE_TASK_AND_WORKSPACE":
			return ClineCheckpointRestoreType.RESTORE_TASK_AND_WORKSPACE
		case -1:
		case "UNRECOGNIZED":
		default:
			return ClineCheckpointRestoreType.UNRECOGNIZED
	}
}

export function clineCheckpointRestoreTypeToJSON(object: ClineCheckpointRestoreType): string {
	switch (object) {
		case ClineCheckpointRestoreType.CLINE_CHECKPOINT_RESTORE_TYPE_UNSPECIFIED:
			return "CLINE_CHECKPOINT_RESTORE_TYPE_UNSPECIFIED"
		case ClineCheckpointRestoreType.RESTORE_TASK:
			return "RESTORE_TASK"
		case ClineCheckpointRestoreType.RESTORE_WORKSPACE:
			return "RESTORE_WORKSPACE"
		case ClineCheckpointRestoreType.RESTORE_TASK_AND_WORKSPACE:
			return "RESTORE_TASK_AND_WORKSPACE"
		case ClineCheckpointRestoreType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export enum TaskFeedbackType {
	TASK_FEEDBACK_TYPE_UNSPECIFIED = 0,
	THUMBS_UP = 1,
	THUMBS_DOWN = 2,
	UNRECOGNIZED = -1,
}

export function taskFeedbackTypeFromJSON(object: any): TaskFeedbackType {
	switch (object) {
		case 0:
		case "TASK_FEEDBACK_TYPE_UNSPECIFIED":
			return TaskFeedbackType.TASK_FEEDBACK_TYPE_UNSPECIFIED
		case 1:
		case "THUMBS_UP":
			return TaskFeedbackType.THUMBS_UP
		case 2:
		case "THUMBS_DOWN":
			return TaskFeedbackType.THUMBS_DOWN
		case -1:
		case "UNRECOGNIZED":
		default:
			return TaskFeedbackType.UNRECOGNIZED
	}
}

export function taskFeedbackTypeToJSON(object: TaskFeedbackType): string {
	switch (object) {
		case TaskFeedbackType.TASK_FEEDBACK_TYPE_UNSPECIFIED:
			return "TASK_FEEDBACK_TYPE_UNSPECIFIED"
		case TaskFeedbackType.THUMBS_UP:
			return "THUMBS_UP"
		case TaskFeedbackType.THUMBS_DOWN:
			return "THUMBS_DOWN"
		case TaskFeedbackType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export interface PriceTier {
	/** Use a large number (e.g., MAX_DOUBLE) or specific convention for Infinity */
	tokenLimit: number
	/** Price per million tokens */
	price: number
}

export interface ModelInfo {
	maxTokens?: number | undefined
	contextWindow?: number | undefined
	supportsImages?: boolean | undefined
	/** Hardcoded for now in TS */
	supportsPromptCache: boolean
	inputPrice?: number | undefined
	inputPriceTiers: PriceTier[]
	outputPrice?: number | undefined
	outputPriceTiers: PriceTier[]
	thinkingConfig?: ModelInfo_ThinkingConfig | undefined
	cacheWritesPrice?: number | undefined
	cacheReadsPrice?: number | undefined
	description?: string | undefined
}

export interface ModelInfo_ThinkingConfig {
	maxBudget?: number | undefined
	outputPrice?: number | undefined
	outputPriceTiers: PriceTier[]
}

export interface OpenAiCompatibleModelInfo {
	baseInfo?: ModelInfo | undefined
	temperature?: number | undefined
	isR1FormatRequired?: boolean | undefined
}

export interface LanguageModelChatSelector {
	/** Simplified representation based on TS `LanguageModelChatSelector` usage */
	id: string
}

export interface ApiConfiguration {
	/** ApiHandlerOptions fields */
	apiModelId?: string | undefined
	/** anthropic specific field in TS comment */
	apiKey?: string | undefined
	clineApiKey?: string | undefined
	taskId?: string | undefined
	liteLlmBaseUrl?: string | undefined
	liteLlmModelId?: string | undefined
	liteLlmApiKey?: string | undefined
	liteLlmUsePromptCache?: boolean | undefined
	openAiHeaders: { [key: string]: string }
	anthropicBaseUrl?: string | undefined
	openRouterApiKey?: string | undefined
	openRouterModelId?: string | undefined
	openRouterModelInfo?: ModelInfo | undefined
	openRouterProviderSorting?: string | undefined
	awsAccessKey?: string | undefined
	awsSecretKey?: string | undefined
	awsSessionToken?: string | undefined
	awsRegion?: string | undefined
	awsUseCrossRegionInference?: boolean | undefined
	awsBedrockUsePromptCache?: boolean | undefined
	awsUseProfile?: boolean | undefined
	awsProfile?: string | undefined
	awsBedrockEndpoint?: string | undefined
	vertexProjectId?: string | undefined
	vertexRegion?: string | undefined
	openAiBaseUrl?: string | undefined
	openAiApiKey?: string | undefined
	openAiModelId?: string | undefined
	openAiModelInfo?: OpenAiCompatibleModelInfo | undefined
	ollamaModelId?: string | undefined
	ollamaBaseUrl?: string | undefined
	ollamaApiOptionsCtxNum?: string | undefined
	lmStudioModelId?: string | undefined
	lmStudioBaseUrl?: string | undefined
	geminiApiKey?: string | undefined
	geminiBaseUrl?: string | undefined
	openAiNativeApiKey?: string | undefined
	deepSeekApiKey?: string | undefined
	requestyApiKey?: string | undefined
	requestyModelId?: string | undefined
	requestyModelInfo?: ModelInfo | undefined
	togetherApiKey?: string | undefined
	togetherModelId?: string | undefined
	qwenApiKey?: string | undefined
	doubaoApiKey?: string | undefined
	mistralApiKey?: string | undefined
	azureApiVersion?: string | undefined
	vsCodeLmModelSelector?: LanguageModelChatSelector | undefined
	o3MiniReasoningEffort?: string | undefined
	qwenApiLine?: string | undefined
	asksageApiUrl?: string | undefined
	asksageApiKey?: string | undefined
	xaiApiKey?: string | undefined
	/** TS uses number, double seems appropriate */
	thinkingBudgetTokens?: number | undefined
	reasoningEffort?: string | undefined
	sambanovaApiKey?: string | undefined
	/** ApiConfiguration specific fields */
	apiProvider?: ApiProvider | undefined
	favoritedModelIds: string[]
}

export interface ApiConfiguration_OpenAiHeadersEntry {
	key: string
	value: string
}

export interface ChatSettings {
	mode: ChatMode
}

/**
 * From src/shared/BrowserSettings.ts
 * ----------------------------------
 */
export interface BrowserViewport {
	/** TS uses number, int32 appropriate for pixels */
	width: number
	/** TS uses number, int32 appropriate for pixels */
	height: number
}

export interface BrowserSettings {
	viewport?: BrowserViewport | undefined
	remoteBrowserHost?: string | undefined
	remoteBrowserEnabled?: boolean | undefined
}

/**
 * From src/shared/AutoApprovalSettings.ts
 * ---------------------------------------
 */
export interface AutoApprovalActions {
	readFiles: boolean
	readFilesExternally?: boolean | undefined
	editFiles: boolean
	editFilesExternally?: boolean | undefined
	executeSafeCommands?: boolean | undefined
	executeAllCommands?: boolean | undefined
	useBrowser: boolean
	useMcp: boolean
}

export interface AutoApprovalSettings {
	/** TS uses number, int64 is safer for potential increments */
	version: number
	enabled: boolean
	actions?: AutoApprovalActions | undefined
	/** TS uses number, int32 sufficient */
	maxRequests: number
	enableNotifications: boolean
}

/**
 * From src/shared/UserInfo.ts
 * ---------------------------
 */
export interface UserInfo {
	/** Handles TS string | null */
	displayName?: string | undefined
	/** Handles TS string | null */
	email?: string | undefined
	/** Handles TS string | null */
	photoUrl?: string | undefined
}

/**
 * From src/shared/ChatContent.ts
 * ------------------------------
 */
export interface ChatContent {
	message?: string | undefined
	/** Base64 encoded or URIs */
	images: string[]
}

/**
 * From src/shared/HistoryItem.ts
 * -------------------------------
 */
export interface HistoryItem {
	id: string
	/** TS number (timestamp), int64 suitable */
	ts: number
	task: string
	/** TS number, int64 suitable */
	tokensIn: number
	/** TS number, int64 suitable */
	tokensOut: number
	/** TS number?, int64 suitable */
	cacheWrites?: number | undefined
	/** TS number?, int64 suitable */
	cacheReads?: number | undefined
	/** TS number, double suitable for cost */
	totalCost: number
	/** TS number?, int64 suitable for bytes */
	size?: number | undefined
	shadowGitConfigWorkTree?: string | undefined
	conversationHistoryDeletedRange?: HistoryItem_ConversationHistoryDeletedRange | undefined
}

export interface HistoryItem_ConversationHistoryDeletedRange {
	/** TS number[], int64 suitable */
	startIndex: number
	/** TS number[], int64 suitable */
	endIndex: number
}

export interface McpTool {
	name: string
	description?: string | undefined
	/** TS object -> Struct */
	inputSchema?: { [key: string]: any } | undefined
	autoApprove?: boolean | undefined
}

export interface McpResource {
	uri: string
	name: string
	mimeType?: string | undefined
	description?: string | undefined
}

export interface McpResourceTemplate {
	uriTemplate: string
	name: string
	description?: string | undefined
	mimeType?: string | undefined
}

export interface McpServer {
	name: string
	/** Path or identifier for the config */
	config: string
	status: McpServerStatus
	error?: string | undefined
	tools: McpTool[]
	resources: McpResource[]
	resourceTemplates: McpResourceTemplate[]
	disabled?: boolean | undefined
	/** TS number?, int32 suitable for seconds */
	timeout?: number | undefined
}

/** --- Types related to MCP Marketplace --- */
export interface McpMarketplaceItem {
	mcpId: string
	githubUrl: string
	name: string
	author: string
	description: string
	codiconIcon: string
	logoUrl: string
	category: string
	tags: string[]
	requiresApiKey: boolean
	readmeContent?: string | undefined
	llmsInstallationContent?: string | undefined
	isRecommended: boolean
	/** TS number, int64 suitable */
	githubStars: number
	/** TS number, int64 suitable */
	downloadCount: number
	/** TS string (ISO date), keep as string or use google.protobuf.Timestamp */
	createdAt: string
	/** TS string (ISO date), keep as string or use google.protobuf.Timestamp */
	updatedAt: string
	/** TS string (ISO date), keep as string or use google.protobuf.Timestamp */
	lastGithubSync: string
}

export interface McpMarketplaceCatalog {
	items: McpMarketplaceItem[]
}

export interface McpDownloadResponse {
	mcpId: string
	githubUrl: string
	name: string
	author: string
	description: string
	readmeContent: string
	llmsInstallationContent: string
	requiresApiKey: boolean
}

/**
 * From src/shared/cline-rules.ts
 * ------------------------------
 */
export interface ClineRulesToggles {
	/** TS Record<string, boolean> -> map<string, bool> */
	toggles: { [key: string]: boolean }
}

export interface ClineRulesToggles_TogglesEntry {
	key: string
	value: boolean
}

/**
 * From src/utils/git.ts
 * ---------------------
 */
export interface GitCommit {
	hash: string
	shortHash: string
	subject: string
	author: string
	/** TS string (short date), string is fine */
	date: string
}

/**
 * From src/shared/ClineAccount.ts (Refined in Step 8)
 * -------------------------------------------
 */
export interface BalanceResponse {
	/** TS number -> double */
	currentBalance: number
}

export interface UsageTransaction {
	/** TS string (ISO date) */
	spentAt: string
	/** TS string */
	credits: string
	/** TS string */
	modelProvider: string
	/** TS string */
	model: string
	/** TS string (represents number) */
	promptTokens: string
	/** TS string (represents number) */
	completionTokens: string
}

export interface PaymentTransaction {
	/** TS string (ISO date) */
	paidAt: string
	/** TS string (represents number) */
	amountCents: string
	/** TS string (represents number) */
	credits: string
}

/**
 * For RelativePathsResponsePayload (Refined in Step 8)
 * -------------------------------------------
 * Using Wrapped Type for Nullable String in Repeated Field
 * message NullableString {
 *   optional string value = 1;
 * }
 * Alternative: Using google.protobuf.StringValue
 */
export interface RelativePathsResponsePayload {
	/** Represents (string | null)[] */
	paths: string[]
}

/** Corresponds to TS ClineAskQuestion */
export interface AskFollowupPayload {
	question: string
	options: string[]
	/** If response was pre-selected/sent back */
	selected?: string | undefined
}

/** Corresponds to TS ClinePlanModeResponse */
export interface AskPlanModeRespondPayload {
	response: string
	options: string[]
	/** If response was pre-selected/sent back */
	selected?: string | undefined
}

/** Corresponds to TS ClineAsk = "command" (no specific interface) */
export interface AskCommandPayload {
	/** Assuming the ask simply involves the command text */
	commandText: string
}

/** Corresponds to TS ClineAsk = "command_output" (no specific interface) */
export interface AskCommandOutputPayload {
	/** Assuming the ask involves the output text */
	outputText: string
}

/** Corresponds to TS ClineAsk = "completion_result" (no specific interface) */
export interface AskCompletionResultPayload {
	/** Assuming the ask involves the result text */
	resultText: string
}

/**
 * Corresponds to TS ClineAsk = "tool" (no specific interface)
 * Uses the structure defined for SAY_TOOL for consistency
 */
export interface AskToolPayload {
	/** Reusing SayToolPayload structure */
	toolDetails?: SayToolPayload | undefined
}

/** Corresponds to TS ClineAsk = "api_req_failed" (no specific interface) */
export interface AskApiReqFailedPayload {
	/** Assuming the ask involves the error message */
	errorMessage: string
}

/** Corresponds to TS ClineAsk = "resume_task" (no specific interface) */
export interface AskResumeTaskPayload {
	/** Assuming the ask includes the task ID */
	taskId: string
}

/** Corresponds to TS ClineAsk = "resume_completed_task" (no specific interface) */
export interface AskResumeCompletedTaskPayload {
	/** Assuming the ask includes the task ID */
	taskId: string
}

/** Corresponds to TS ClineAsk = "mistake_limit_reached" (no specific interface) */
export interface AskMistakeLimitReachedPayload {}

/** Corresponds to TS ClineAsk = "auto_approval_max_req_reached" (no specific interface) */
export interface AskAutoApprovalMaxReqReachedPayload {}

/** Corresponds to TS ClineAsk = "browser_action_launch" (no specific interface) */
export interface AskBrowserActionLaunchPayload {
	/** Assuming the ask includes the URL to be launched */
	url: string
}

/** Corresponds to TS ClineAskUseMcpServer */
export interface AskUseMcpServerPayload {
	serverName: string
	type: AskUseMcpServerPayload_McpRequestType
	toolName?: string | undefined
	/** TS arguments?: string */
	argumentsJson?: string | undefined
	uri?: string | undefined
}

export enum AskUseMcpServerPayload_McpRequestType {
	MCP_REQUEST_TYPE_UNSPECIFIED = 0,
	USE_MCP_TOOL = 1,
	ACCESS_MCP_RESOURCE = 2,
	UNRECOGNIZED = -1,
}

export function askUseMcpServerPayload_McpRequestTypeFromJSON(object: any): AskUseMcpServerPayload_McpRequestType {
	switch (object) {
		case 0:
		case "MCP_REQUEST_TYPE_UNSPECIFIED":
			return AskUseMcpServerPayload_McpRequestType.MCP_REQUEST_TYPE_UNSPECIFIED
		case 1:
		case "USE_MCP_TOOL":
			return AskUseMcpServerPayload_McpRequestType.USE_MCP_TOOL
		case 2:
		case "ACCESS_MCP_RESOURCE":
			return AskUseMcpServerPayload_McpRequestType.ACCESS_MCP_RESOURCE
		case -1:
		case "UNRECOGNIZED":
		default:
			return AskUseMcpServerPayload_McpRequestType.UNRECOGNIZED
	}
}

export function askUseMcpServerPayload_McpRequestTypeToJSON(object: AskUseMcpServerPayload_McpRequestType): string {
	switch (object) {
		case AskUseMcpServerPayload_McpRequestType.MCP_REQUEST_TYPE_UNSPECIFIED:
			return "MCP_REQUEST_TYPE_UNSPECIFIED"
		case AskUseMcpServerPayload_McpRequestType.USE_MCP_TOOL:
			return "USE_MCP_TOOL"
		case AskUseMcpServerPayload_McpRequestType.ACCESS_MCP_RESOURCE:
			return "ACCESS_MCP_RESOURCE"
		case AskUseMcpServerPayload_McpRequestType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

/** Corresponds to TS ClineAskNewTask */
export interface AskNewTaskPayload {
	context: string
}

/** Corresponds to TS ClineSay = "task" (no specific interface) */
export interface SayTaskPayload {
	/** Assuming the initial task message text */
	taskDescription: string
}

/** Corresponds to TS ClineSay = "error" (no specific interface) */
export interface SayErrorPayload {
	errorMessage: string
}

/** Corresponds to TS ClineApiReqInfo (used for "api_req_started", "api_req_finished", "api_req_retried") */
export interface SayApiReqInfoPayload {
	request?: string | undefined
	tokensIn?: number | undefined
	tokensOut?: number | undefined
	cacheWrites?: number | undefined
	cacheReads?: number | undefined
	cost?: number | undefined
	cancelReason?: ClineApiReqCancelReason | undefined
	streamingFailedMessage?: string | undefined
}

/** Corresponds to TS ClineSay = "text" (no specific interface) */
export interface SayTextPayload {
	textContent: string
}

/** Corresponds to TS ClineSay = "reasoning" (no specific interface) */
export interface SayReasoningPayload {
	reasoningText: string
}

/** Corresponds to TS ClineSay = "completion_result" (no specific interface) */
export interface SayCompletionResultPayload {
	/** Assuming the say involves the result text */
	resultText: string
	/** Maps to COMPLETION_RESULT_CHANGES_FLAG concept */
	hasChanges?: boolean | undefined
}

/** Corresponds to TS ClineSay = "user_feedback" (no specific interface) */
export interface SayUserFeedbackPayload {
	feedbackText: string
}

/** Corresponds to TS ClineSay = "user_feedback_diff" (no specific interface) */
export interface SayUserFeedbackDiffPayload {
	diffContent: string
}

/** Corresponds to TS ClineSay = "command" (no specific interface) */
export interface SayCommandPayload {
	/** Assuming the say involves the command text */
	commandText: string
}

/** Corresponds to TS ClineSay = "command_output" (no specific interface) */
export interface SayCommandOutputPayload {
	/** Assuming the say involves the output text */
	outputText: string
}

export interface SayToolPayload {
	tool: SayToolType
	path?: string | undefined
	diff?: string | undefined
	content?: string | undefined
	regex?: string | undefined
	filePattern?: string | undefined
	operationIsLocatedInWorkspace?: boolean | undefined
}

/** Corresponds to TS ClineSay = "shell_integration_warning" (no specific interface) */
export interface SayShellIntegrationWarningPayload {
	warningMessage: string
}

/** Corresponds to TS ClineSay = "browser_action_launch" (no specific interface) */
export interface SayBrowserActionLaunchPayload {
	/** Assuming the say involves the launched URL */
	url: string
}

export interface SayBrowserActionPayload {
	action: BrowserActionType
	coordinate?: string | undefined
	text?: string | undefined
}

/** Corresponds to TS BrowserActionResult */
export interface SayBrowserActionResultPayload {
	/** Base64 encoded image data */
	screenshot?: string | undefined
	logs?: string | undefined
	currentUrl?: string | undefined
	/** e.g., "x,y" */
	currentMousePosition?: string | undefined
}

/** Corresponds to TS ClineSay = "mcp_server_request_started" (no specific interface) */
export interface SayMcpServerRequestStartedPayload {
	/** No other details specified in TS type name */
	serverName: string
}

/** Corresponds to TS ClineSay = "mcp_server_response" (no specific interface) */
export interface SayMcpServerResponsePayload {
	serverName: string
	/** Placeholder - actual structure depends on MCP response format */
	responseContent: string
}

/**
 * Corresponds to TS ClineSay = "use_mcp_server" (no specific interface)
 * Reusing AskUseMcpServerPayload for consistency
 */
export interface SayUseMcpServerPayload {
	details?: AskUseMcpServerPayload | undefined
}

/** Corresponds to TS ClineSay = "diff_error" (no specific interface) */
export interface SayDiffErrorPayload {
	errorMessage: string
	/** Assuming error relates to a specific path */
	path: string
}

/** Corresponds to TS ClineSay = "deleted_api_reqs" (no specific interface) */
export interface SayDeletedApiReqsPayload {
	/** Assuming the message includes the count */
	count: number
}

/** Corresponds to TS ClineSay = "clineignore_error" (no specific interface) */
export interface SayClineignoreErrorPayload {
	errorMessage: string
}

/** Corresponds to TS ClineSay = "checkpoint_created" (no specific interface) */
export interface SayCheckpointCreatedPayload {
	checkpointHash: string
}

/** Corresponds to TS ClineSay = "load_mcp_documentation" (no specific interface) */
export interface SayLoadMcpDocumentationPayload {}

/** --- Main ClineMessage --- */
export interface ClineMessage {
	/** Timestamp in milliseconds since epoch */
	ts: number
	type: ClineMessage_Type
	/** General text, often used as fallback or primary content */
	text?: string | undefined
	reasoning?: string | undefined
	/** Base64 encoded or URIs */
	images: string[]
	partial?: boolean | undefined
	lastCheckpointHash?: string | undefined
	isCheckpointCheckedOut?: boolean | undefined
	isOperationOutsideWorkspace?: boolean | undefined
	conversationHistoryIndex?: number | undefined
	conversationHistoryDeletedRange?: HistoryItem_ConversationHistoryDeletedRange | undefined
	/** Explicit discriminator for ask_payload */
	actualAskType?: ClineAskType | undefined
	/** Explicit discriminator for say_payload */
	actualSayType?: ClineSayType | undefined
	/** ClineAskType ask_type = 20; // Discriminator enum MOVED to actual_ask_type field */
	askFollowupPayload?: AskFollowupPayload | undefined
	/** type=PLAN_MODE_RESPOND */
	askPlanModeRespondPayload?: AskPlanModeRespondPayload | undefined
	/** type=COMMAND */
	askCommandPayload?: AskCommandPayload | undefined
	/** type=COMMAND_OUTPUT */
	askCommandOutputPayload?: AskCommandOutputPayload | undefined
	/** type=COMPLETION_RESULT */
	askCompletionResultPayload?: AskCompletionResultPayload | undefined
	/** type=TOOL */
	askToolPayload?: AskToolPayload | undefined
	/** type=API_REQ_FAILED */
	askApiReqFailedPayload?: AskApiReqFailedPayload | undefined
	/** type=RESUME_TASK */
	askResumeTaskPayload?: AskResumeTaskPayload | undefined
	/** type=RESUME_COMPLETED_TASK */
	askResumeCompletedTaskPayload?: AskResumeCompletedTaskPayload | undefined
	/** type=MISTAKE_LIMIT_REACHED */
	askMistakeLimitReachedPayload?: AskMistakeLimitReachedPayload | undefined
	/** type=AUTO_APPROVAL_MAX_REQ_REACHED */
	askAutoApprovalMaxReqReachedPayload?: AskAutoApprovalMaxReqReachedPayload | undefined
	/** type=BROWSER_ACTION_LAUNCH */
	askBrowserActionLaunchPayload?: AskBrowserActionLaunchPayload | undefined
	/** type=USE_MCP_SERVER */
	askUseMcpServerPayload?: AskUseMcpServerPayload | undefined
	/** type=NEW_TASK */
	askNewTaskPayload?: AskNewTaskPayload | undefined
	/** ClineSayType say_type = 40; // Discriminator enum MOVED to actual_say_type field */
	sayTaskPayload?: SayTaskPayload | undefined
	/** type=SAY_ERROR */
	sayErrorPayload?: SayErrorPayload | undefined
	/** type=API_REQ_STARTED, API_REQ_FINISHED, API_REQ_RETRIED */
	sayApiReqInfoPayload?: SayApiReqInfoPayload | undefined
	/** type=SAY_TEXT */
	sayTextPayload?: SayTextPayload | undefined
	/** type=REASONING */
	sayReasoningPayload?: SayReasoningPayload | undefined
	/** type=SAY_COMPLETION_RESULT */
	sayCompletionResultPayload?: SayCompletionResultPayload | undefined
	/** type=USER_FEEDBACK */
	sayUserFeedbackPayload?: SayUserFeedbackPayload | undefined
	/** type=USER_FEEDBACK_DIFF */
	sayUserFeedbackDiffPayload?: SayUserFeedbackDiffPayload | undefined
	/** type=SAY_COMMAND */
	sayCommandPayload?: SayCommandPayload | undefined
	/** type=SAY_COMMAND_OUTPUT */
	sayCommandOutputPayload?: SayCommandOutputPayload | undefined
	/** type=SAY_TOOL */
	sayToolPayload?: SayToolPayload | undefined
	/** type=SHELL_INTEGRATION_WARNING */
	sayShellIntegrationWarningPayload?: SayShellIntegrationWarningPayload | undefined
	/** type=SAY_BROWSER_ACTION_LAUNCH */
	sayBrowserActionLaunchPayload?: SayBrowserActionLaunchPayload | undefined
	/** type=BROWSER_ACTION */
	sayBrowserActionPayload?: SayBrowserActionPayload | undefined
	/** type=BROWSER_ACTION_RESULT */
	sayBrowserActionResultPayload?: SayBrowserActionResultPayload | undefined
	/** type=MCP_SERVER_REQUEST_STARTED */
	sayMcpServerRequestStartedPayload?: SayMcpServerRequestStartedPayload | undefined
	/** type=MCP_SERVER_RESPONSE */
	sayMcpServerResponsePayload?: SayMcpServerResponsePayload | undefined
	/** type=SAY_USE_MCP_SERVER */
	sayUseMcpServerPayload?: SayUseMcpServerPayload | undefined
	/** type=DIFF_ERROR */
	sayDiffErrorPayload?: SayDiffErrorPayload | undefined
	/** type=DELETED_API_REQS */
	sayDeletedApiReqsPayload?: SayDeletedApiReqsPayload | undefined
	/** type=CLINEIGNORE_ERROR */
	sayClineignoreErrorPayload?: SayClineignoreErrorPayload | undefined
	/** type=CHECKPOINT_CREATED */
	sayCheckpointCreatedPayload?: SayCheckpointCreatedPayload | undefined
	/** type=LOAD_MCP_DOCUMENTATION */
	sayLoadMcpDocumentationPayload?: SayLoadMcpDocumentationPayload | undefined
}

export enum ClineMessage_Type {
	CLINE_MESSAGE_TYPE_UNSPECIFIED = 0,
	ASK = 1,
	SAY = 2,
	UNRECOGNIZED = -1,
}

export function clineMessage_TypeFromJSON(object: any): ClineMessage_Type {
	switch (object) {
		case 0:
		case "CLINE_MESSAGE_TYPE_UNSPECIFIED":
			return ClineMessage_Type.CLINE_MESSAGE_TYPE_UNSPECIFIED
		case 1:
		case "ASK":
			return ClineMessage_Type.ASK
		case 2:
		case "SAY":
			return ClineMessage_Type.SAY
		case -1:
		case "UNRECOGNIZED":
		default:
			return ClineMessage_Type.UNRECOGNIZED
	}
}

export function clineMessage_TypeToJSON(object: ClineMessage_Type): string {
	switch (object) {
		case ClineMessage_Type.CLINE_MESSAGE_TYPE_UNSPECIFIED:
			return "CLINE_MESSAGE_TYPE_UNSPECIFIED"
		case ClineMessage_Type.ASK:
			return "ASK"
		case ClineMessage_Type.SAY:
			return "SAY"
		case ClineMessage_Type.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export interface ExtensionState {
	apiConfiguration?: ApiConfiguration | undefined
	autoApprovalSettings?: AutoApprovalSettings | undefined
	browserSettings?: BrowserSettings | undefined
	/** Note: Also exists in BrowserSettings, check consolidation need */
	remoteBrowserHost?: string | undefined
	chatSettings?: ChatSettings | undefined
	checkpointTrackerErrorMessage?: string | undefined
	clineMessages: ClineMessage[]
	currentTaskItem?: HistoryItem | undefined
	customInstructions?: string | undefined
	mcpMarketplaceEnabled?: boolean | undefined
	planActSeparateModelsSetting: boolean
	platform: Platform
	shouldShowAnnouncement: boolean
	taskHistory: HistoryItem[]
	telemetrySetting: TelemetrySettingValue
	uriScheme?: string | undefined
	userInfo?: UserInfo | undefined
	version: string
	vscMachineId: string
	globalClineRulesToggles?: ClineRulesToggles | undefined
	localClineRulesToggles?: ClineRulesToggles | undefined
}

/** ** Moved TaskStartedInfo definition here *** */
export interface TaskStartedInfo {
	taskId: string
	version: string
}

/** Corrected ExtensionMessage structure */
export interface ExtensionMessage {
	type: ExtensionMessageType
	/** Use dedicated fields for common simple payloads instead of relying solely on 'oneof' */
	genericText?: string | undefined
	/** Use specifically for ERROR type (99) */
	errorMessage?: string | undefined
	/**
	 * The 'oneof' defines the *specific* payload based on the 'type' field
	 * Temporarily making task_started a direct field for debugging oneof issue
	 */
	taskStarted?: TaskStartedInfo | undefined
	/** type=STATE (1) */
	state?: ExtensionState | undefined
	/** type=PARTIAL_MESSAGE (2) */
	partialMessage?: ClineMessage | undefined
	/** type=TEXT (3) - Use ClineMessage for consistency */
	textMessage?: ClineMessage | undefined
	/** type=TOOL_USE (4) */
	toolUse?: ToolUseBlock | undefined
	/** type=TOOL_RESULT (5) */
	toolResult?: ToolResultBlock | undefined
	/** type=SELECTED_IMAGES (6) */
	selectedImages?: ExtensionMessage_RepeatedStringWrapper | undefined
	/** type=OLLAMA_MODELS (7) */
	ollamaModels?: ExtensionMessage_RepeatedStringWrapper | undefined
	/** type=LM_STUDIO_MODELS (8) */
	lmStudioModels?: ExtensionMessage_RepeatedStringWrapper | undefined
	/**
	 * THEME (9) uses generic_text field
	 * WORKSPACE_UPDATED (10) might use a dedicated payload or be signal only
	 */
	invoke?: InvokeType | undefined
	/** type=OPEN_ROUTER_MODELS (12) */
	openRouterModels?: ExtensionMessage_OpenRouterModelsWrapper | undefined
	/** type=OPEN_AI_MODELS (13) */
	openAiModels?: ExtensionMessage_RepeatedStringWrapper | undefined
	/** type=REQUESTY_MODELS (14) */
	requestyModels?: ExtensionMessage_RequestyModelsWrapper | undefined
	/** type=MCP_SERVERS (15) */
	mcpServers?: ExtensionMessage_McpServerListWrapper | undefined
	/** RELINQUISH_CONTROL (16) has no payload */
	vsCodeLmModels?: ExtensionMessage_VsCodeLmModelListWrapper | undefined
	/** EXTENSION_REQUEST_VS_CODE_LM_MODELS (18) has no payload */
	authCallbackCustomToken?: string | undefined
	/** type=MCP_MARKETPLACE_CATALOG (20) */
	mcpMarketplaceCatalog?: McpMarketplaceCatalog | undefined
	/** type=MCP_DOWNLOAD_DETAILS (21) */
	mcpDownloadDetails?: McpDownloadResponse | undefined
	/** type=COMMIT_SEARCH_RESULTS (22) */
	commitSearchResults?: ExtensionMessage_GitCommitListWrapper | undefined
	/** type=OPEN_GRAPH_DATA (23) */
	openGraphData?: OpenGraphData | undefined
	/** type=IS_IMAGE_URL_RESULT (24) */
	isImageUrlResult?: boolean | undefined
	/** DID_UPDATE_SETTINGS (25) has no payload */
	addRemoteServerResult?: AddRemoteServerResult | undefined
	/** type=USER_CREDITS_BALANCE (27) */
	userCreditsBalance?: BalanceResponse | undefined
	/** type=USER_CREDITS_USAGE (28) */
	userCreditsUsage?: ExtensionMessage_UsageTransactionListWrapper | undefined
	/** type=USER_CREDITS_PAYMENTS (29) */
	userCreditsPayments?: ExtensionMessage_PaymentTransactionListWrapper | undefined
	/** type=TOTAL_TASKS_SIZE (30) */
	totalTasksSize?: number | undefined
	/** ADD_TO_INPUT (31) uses generic_text field */
	browserConnectionResult?: BrowserConnectionResult | undefined
	/**
	 * DETECTED_CHROME_PATH (33) uses generic_text field
	 * SCROLL_TO_SETTINGS (34) uses generic_text field
	 */
	browserRelaunchResult?: BrowserRelaunchResult | undefined
	/** type=RELATIVE_PATHS_RESPONSE (36) */
	relativePathsResponse?: RelativePathsResponsePayload | undefined
	/** type=FILE_SEARCH_RESULTS (37) */
	fileSearchResults?: ExtensionMessage_FileSearchResultListWrapper | undefined
	/** type=GRPC_RESPONSE (38) */
	grpcResponse?: GrpcResponse | undefined
	/** TaskStartedInfo task_started = 38; // Moved out of oneof */
	newChatMessage?: ClineMessage | undefined
}

/** Define wrapper types *outside* the oneof, if they are complex */
export interface ExtensionMessage_OpenRouterModelsWrapper {
	models: { [key: string]: ModelInfo }
}

export interface ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry {
	key: string
	value?: ModelInfo | undefined
}

export interface ExtensionMessage_RequestyModelsWrapper {
	models: { [key: string]: ModelInfo }
}

export interface ExtensionMessage_RequestyModelsWrapper_ModelsEntry {
	key: string
	value?: ModelInfo | undefined
}

export interface ExtensionMessage_RepeatedStringWrapper {
	values: string[]
}

export interface ExtensionMessage_McpServerListWrapper {
	servers: McpServer[]
}

export interface ExtensionMessage_VsCodeLmModelListWrapper {
	models: VsCodeLmModel[]
}

export interface ExtensionMessage_GitCommitListWrapper {
	commits: GitCommit[]
}

export interface ExtensionMessage_UsageTransactionListWrapper {
	transactions: UsageTransaction[]
}

export interface ExtensionMessage_PaymentTransactionListWrapper {
	transactions: PaymentTransaction[]
}

export interface ExtensionMessage_FileSearchResultListWrapper {
	results: FileSearchResult[]
}

/** Define ToolUseBlock and ToolResultBlock */
export interface ToolUseBlock {
	/** Corresponds to `id` in Anthropic.ToolUseBlock */
	toolUseId: string
	name: string
	/** Represents the JSON object input Anthropic.ToolUseBlock['input'] */
	input?: any | undefined
}

export interface ToolResultBlock {
	toolUseId: string
	textContent?: string | undefined
	/** For structured results */
	jsonContent?: any | undefined
	/** Flag if the result is an error */
	isError?: boolean | undefined
}

export interface VsCodeLmModel {
	vendor?: string | undefined
	family?: string | undefined
	version?: string | undefined
	id?: string | undefined
}

export interface OpenGraphData {
	title?: string | undefined
	description?: string | undefined
	image?: string | undefined
	url?: string | undefined
	siteName?: string | undefined
	type?: string | undefined
}

export interface AddRemoteServerResult {
	success: boolean
	serverName: string
	error?: string | undefined
}

export interface BrowserConnectionResult {
	success: boolean
	endpoint?: string | undefined
	isBundled?: boolean | undefined
	isConnected?: boolean | undefined
	isRemote?: boolean | undefined
	host?: string | undefined
	error?: string | undefined
}

export interface BrowserRelaunchResult {
	success: boolean
	error?: string | undefined
}

export interface FileSearchResult {
	path: string
	type: FileSearchResult_Type
	label?: string | undefined
}

export enum FileSearchResult_Type {
	TYPE_UNSPECIFIED = 0,
	FILE = 1,
	FOLDER = 2,
	UNRECOGNIZED = -1,
}

export function fileSearchResult_TypeFromJSON(object: any): FileSearchResult_Type {
	switch (object) {
		case 0:
		case "TYPE_UNSPECIFIED":
			return FileSearchResult_Type.TYPE_UNSPECIFIED
		case 1:
		case "FILE":
			return FileSearchResult_Type.FILE
		case 2:
		case "FOLDER":
			return FileSearchResult_Type.FOLDER
		case -1:
		case "UNRECOGNIZED":
		default:
			return FileSearchResult_Type.UNRECOGNIZED
	}
}

export function fileSearchResult_TypeToJSON(object: FileSearchResult_Type): string {
	switch (object) {
		case FileSearchResult_Type.TYPE_UNSPECIFIED:
			return "TYPE_UNSPECIFIED"
		case FileSearchResult_Type.FILE:
			return "FILE"
		case FileSearchResult_Type.FOLDER:
			return "FOLDER"
		case FileSearchResult_Type.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED"
	}
}

export interface GrpcResponse {
	requestId: string
	/** Represents arbitrary JSON payload */
	message?: any | undefined
}

/** Define the wrapper message for all client-to-server communication */
export interface ClientMessage {
	/** Corresponds to WebviewMessageType.NEW_TASK */
	newTask?: NewTaskRequest | undefined
	/** Corresponds to WebviewMessageType.ASK_RESPONSE */
	askResponse?: AskResponseRequest | undefined
	/** Corresponds to WebviewMessageType.CLEAR_TASK */
	clearTask?: Empty | undefined
	/** Corresponds to WebviewMessageType.DID_SHOW_ANNOUNCEMENT */
	didShowAnnouncement?: Empty | undefined
	/** SELECT_IMAGES (UI action) - No direct message payload */
	exportCurrentTask?: Empty | undefined
	/** Corresponds to WebviewMessageType.SHOW_TASK_WITH_ID */
	showTaskWithId?: ShowTaskWithIdRequest | undefined
	/** Corresponds to WebviewMessageType.DELETE_TASK_WITH_ID */
	deleteTaskWithId?: DeleteTaskWithIdRequest | undefined
	/** Corresponds to WebviewMessageType.EXPORT_TASK_WITH_ID */
	exportTaskWithId?: ExportTaskWithIdRequest | undefined
	/** Corresponds to WebviewMessageType.RESET_STATE */
	resetState?: Empty | undefined
	/** Corresponds to WebviewMessageType.REQUEST_OLLAMA_MODELS */
	requestOllamaModels?: Empty | undefined
	/** Corresponds to WebviewMessageType.REQUEST_LM_STUDIO_MODELS */
	requestLmStudioModels?: Empty | undefined
	/** Corresponds to WebviewMessageType.OPEN_IMAGE */
	openImage?: OpenImageRequest | undefined
	/** Corresponds to WebviewMessageType.OPEN_IN_BROWSER */
	openInBrowser?: OpenInBrowserRequest | undefined
	/** Corresponds to WebviewMessageType.OPEN_FILE */
	openFile?: OpenFileRequest | undefined
	/** Corresponds to WebviewMessageType.CREATE_RULE_FILE */
	createRuleFile?: CreateRuleFileRequest | undefined
	/** Corresponds to WebviewMessageType.OPEN_MENTION */
	openMention?: OpenMentionRequest | undefined
	/** Corresponds to WebviewMessageType.CANCEL_TASK */
	cancelTask?: Empty | undefined
	/** Corresponds to WebviewMessageType.SHOW_CHAT_VIEW */
	showChatView?: Empty | undefined
	/** Corresponds to WebviewMessageType.REFRESH_OPEN_ROUTER_MODELS */
	refreshOpenRouterModels?: Empty | undefined
	/** Corresponds to WebviewMessageType.REFRESH_REQUESTY_MODELS */
	refreshRequestyModels?: Empty | undefined
	/** Corresponds to WebviewMessageType.REFRESH_OPEN_AI_MODELS */
	refreshOpenAiModels?: Empty | undefined
	/** Corresponds to WebviewMessageType.REFRESH_CLINE_RULES */
	refreshClineRules?: Empty | undefined
	/** Corresponds to WebviewMessageType.OPEN_MCP_SETTINGS */
	openMcpSettings?: Empty | undefined
	/** Corresponds to WebviewMessageType.RESTART_MCP_SERVER */
	restartMcpServer?: RestartMcpServerRequest | undefined
	/** Corresponds to WebviewMessageType.DELETE_MCP_SERVER */
	deleteMcpServer?: DeleteMcpServerRequest | undefined
	/** Corresponds to WebviewMessageType.AUTO_APPROVAL_SETTINGS */
	autoApprovalSettings?: ApplyAutoApprovalSettingsRequest | undefined
	/** Corresponds to WebviewMessageType.BROWSER_SETTINGS */
	browserSettings?: ApplyBrowserSettingsRequest | undefined
	/** Corresponds to WebviewMessageType.TOGGLE_PLAN_ACT_MODE */
	togglePlanActMode?: Empty | undefined
	/** Corresponds to WebviewMessageType.CHECKPOINT_RESTORE */
	checkpointRestore?: CheckpointRestoreRequest | undefined
	/** Corresponds to WebviewMessageType.TASK_COMPLETION_VIEW_CHANGES */
	taskCompletionViewChanges?: Empty | undefined
	/** Corresponds to WebviewMessageType.OPEN_EXTENSION_SETTINGS */
	openExtensionSettings?: Empty | undefined
	/** Corresponds to WebviewMessageType.REQUEST_VS_CODE_LM_MODELS */
	requestVsCodeLmModels?: Empty | undefined
	/** Corresponds to WebviewMessageType.TOGGLE_TOOL_AUTO_APPROVE */
	toggleToolAutoApprove?: ToggleToolAutoApproveRequest | undefined
	/** Corresponds to WebviewMessageType.TOGGLE_MCP_SERVER */
	toggleMcpServer?: ToggleMcpServerRequest | undefined
	/** Corresponds to WebviewMessageType.GET_LATEST_STATE */
	getLatestState?: Empty | undefined
	/** Corresponds to WebviewMessageType.ACCOUNT_LOGIN_CLICKED */
	accountLoginClicked?: Empty | undefined
	/** Corresponds to WebviewMessageType.ACCOUNT_LOGOUT_CLICKED */
	accountLogoutClicked?: Empty | undefined
	/** Corresponds to WebviewMessageType.SHOW_ACCOUNT_VIEW_CLICKED */
	showAccountViewClicked?: Empty | undefined
	/** Corresponds to WebviewMessageType.AUTH_STATE_CHANGED */
	authStateChanged?: AuthStateChangedRequest | undefined
	/** Corresponds to WebviewMessageType.AUTH_CALLBACK */
	authCallback?: AuthCallbackRequest | undefined
	/** Corresponds to WebviewMessageType.FETCH_MCP_MARKETPLACE */
	fetchMcpMarketplace?: Empty | undefined
	/** Corresponds to WebviewMessageType.DOWNLOAD_MCP */
	downloadMcp?: DownloadMcpRequest | undefined
	/** Corresponds to WebviewMessageType.SILENTLY_REFRESH_MCP_MARKETPLACE */
	silentlyRefreshMcpMarketplace?: Empty | undefined
	/** Corresponds to WebviewMessageType.SEARCH_COMMITS */
	searchCommits?: SearchCommitsRequest | undefined
	/** Corresponds to WebviewMessageType.SHOW_MCP_VIEW */
	showMcpView?: ShowMcpViewRequest | undefined
	/** Corresponds to WebviewMessageType.FETCH_LATEST_MCP_SERVERS_FROM_HUB */
	fetchLatestMcpServersFromHub?: Empty | undefined
	/** Corresponds to WebviewMessageType.TELEMETRY_SETTING */
	telemetrySetting?: ApplyTelemetrySettingRequest | undefined
	/** Corresponds to WebviewMessageType.OPEN_SETTINGS */
	openSettings?: Empty | undefined
	/** Corresponds to WebviewMessageType.UPDATE_MCP_TIMEOUT */
	updateMcpTimeout?: UpdateMcpTimeoutRequest | undefined
	/** Corresponds to WebviewMessageType.FETCH_OPEN_GRAPH_DATA */
	fetchOpenGraphData?: FetchOpenGraphDataRequest | undefined
	/** Corresponds to WebviewMessageType.CHECK_IS_IMAGE_URL */
	checkIsImageUrl?: CheckIsImageUrlRequest | undefined
	/** Corresponds to WebviewMessageType.INVOKE (used for user input) */
	invoke?: InvokeRequest | undefined
	/** Corresponds to WebviewMessageType.UPDATE_SETTINGS */
	updateSettings?: UpdateSettingsRequest | undefined
	/** Corresponds to WebviewMessageType.CLEAR_ALL_TASK_HISTORY */
	clearAllTaskHistory?: Empty | undefined
	/** Corresponds to WebviewMessageType.FETCH_USER_CREDITS_DATA */
	fetchUserCreditsData?: Empty | undefined
	/** Corresponds to WebviewMessageType.OPTIONS_RESPONSE */
	optionsResponse?: OptionsResponseRequest | undefined
	/** Corresponds to WebviewMessageType.REQUEST_TOTAL_TASKS_SIZE */
	requestTotalTasksSize?: Empty | undefined
	/** Corresponds to WebviewMessageType.RELAUNCH_CHROME_DEBUG_MODE */
	relaunchChromeDebugMode?: Empty | undefined
	/** Corresponds to WebviewMessageType.TASK_FEEDBACK */
	taskFeedback?: TaskFeedbackRequest | undefined
	/** Corresponds to WebviewMessageType.GET_DETECTED_CHROME_PATH */
	getDetectedChromePath?: Empty | undefined
	/** Corresponds to WebviewMessageType.GET_RELATIVE_PATHS */
	getRelativePaths?: GetRelativePathsRequest | undefined
	/** Corresponds to WebviewMessageType.SEARCH_FILES */
	searchFiles?: SearchFilesRequest | undefined
	/** Corresponds to WebviewMessageType.TOGGLE_FAVORITE_MODEL */
	toggleFavoriteModel?: ToggleFavoriteModelRequest | undefined
	/** Corresponds to WebviewMessageType.GRPC_REQUEST */
	grpcRequest?: GrpcRequest | undefined
	/** Corresponds to WebviewMessageType.TOGGLE_CLINE_RULE */
	toggleClineRule?: ToggleClineRuleRequest | undefined
	/** Corresponds to WebviewMessageType.DELETE_CLINE_RULE */
	deleteClineRule?: DeleteClineRuleRequest | undefined
	/** Corresponds to WebviewMessageType.CONDENSE */
	condense?: Empty | undefined
	/** Corresponds to WebviewMessageType.COPY_TO_CLIPBOARD (payload is string) */
	copyToClipboard?: string | undefined
	/** Corresponds to WebviewMessageType.UPDATE_TERMINAL_CONNECTION_TIMEOUT (payload is number) */
	updateTerminalConnectionTimeout?: number | undefined
}

/** For NEW_TASK */
export interface NewTaskRequest {
	text?: string | undefined
	/** If initial message has images */
	chatContent?: ChatContent | undefined
}

/** For ASK_RESPONSE */
export interface AskResponseRequest {
	askResponseType: AskResponseType
	/** For MESSAGE_RESPONSE */
	text?: string | undefined
}

/** For SHOW_TASK_WITH_ID */
export interface ShowTaskWithIdRequest {
	/** Corresponds to text? in TS */
	taskId: string
}

/** For DELETE_TASK_WITH_ID */
export interface DeleteTaskWithIdRequest {
	/** Corresponds to text? in TS */
	taskId: string
}

/** For EXPORT_TASK_WITH_ID */
export interface ExportTaskWithIdRequest {
	/** Corresponds to text? in TS */
	taskId: string
}

/** For OPEN_IMAGE */
export interface OpenImageRequest {
	/** Corresponds to text? in TS */
	imageUri: string
}

/** For OPEN_IN_BROWSER */
export interface OpenInBrowserRequest {
	/** Corresponds to url? in TS */
	url: string
}

/** For OPEN_FILE */
export interface OpenFileRequest {
	/** Corresponds to text? in TS */
	filePath: string
}

/** For CREATE_RULE_FILE */
export interface CreateRuleFileRequest {
	/** Corresponds to filename? in TS */
	filename?: string | undefined
}

/** For OPEN_MENTION */
export interface OpenMentionRequest {
	/** Corresponds to text? in TS - Placeholder */
	mentionIdentifier: string
}

/** For RESTART_MCP_SERVER */
export interface RestartMcpServerRequest {
	/** Corresponds to mcpId? in TS */
	mcpId: string
}

/** For DELETE_MCP_SERVER */
export interface DeleteMcpServerRequest {
	/** Corresponds to mcpId? in TS */
	mcpId: string
}

/** For AUTO_APPROVAL_SETTINGS */
export interface ApplyAutoApprovalSettingsRequest {
	/** Corresponds to autoApprovalSettings? in TS */
	settings?: AutoApprovalSettings | undefined
}

/** For BROWSER_SETTINGS */
export interface ApplyBrowserSettingsRequest {
	/** Corresponds to browserSettings? in TS */
	settings?: BrowserSettings | undefined
}

/** For CHECKPOINT_RESTORE */
export interface CheckpointRestoreRequest {
	/** Corresponds to text? holding enum value in TS */
	restoreType: ClineCheckpointRestoreType
}

/** For TOGGLE_TOOL_AUTO_APPROVE */
export interface ToggleToolAutoApproveRequest {
	serverName: string
	toolNames: string[]
	autoApprove: boolean
}

/** For TOGGLE_MCP_SERVER */
export interface ToggleMcpServerRequest {
	/** Corresponds to mcpId? in TS */
	mcpId: string
	/** Corresponds to enabled? in TS */
	enabled: boolean
}

/** For AUTH_STATE_CHANGED */
export interface AuthStateChangedRequest {
	/** Corresponds to user? in TS */
	user?: UserInfo | undefined
}

/** For AUTH_CALLBACK */
export interface AuthCallbackRequest {
	/** Corresponds to customToken? in TS */
	customToken: string
}

/** For DOWNLOAD_MCP */
export interface DownloadMcpRequest {
	/** Corresponds to mcpId? in TS */
	mcpId: string
}

/** For SEARCH_COMMITS */
export interface SearchCommitsRequest {
	/** Corresponds to query? in TS */
	query: string
}

/** For SHOW_MCP_VIEW */
export interface ShowMcpViewRequest {
	/** Corresponds to tab? in TS */
	tab: McpViewTab
}

/** For TELEMETRY_SETTING */
export interface ApplyTelemetrySettingRequest {
	/** Corresponds to telemetrySetting? in TS */
	setting: TelemetrySettingValue
}

/** For UPDATE_MCP_TIMEOUT */
export interface UpdateMcpTimeoutRequest {
	/** Corresponds to mcpId? in TS */
	mcpId: string
	/** Corresponds to timeout? in TS */
	timeout: number
}

/** For FETCH_OPEN_GRAPH_DATA */
export interface FetchOpenGraphDataRequest {
	/** Corresponds to url? in TS */
	url: string
}

/** For CHECK_IS_IMAGE_URL */
export interface CheckIsImageUrlRequest {
	/** Corresponds to url? in TS */
	url: string
}

/** For INVOKE */
export interface InvokeRequest {
	text?: string | undefined
	/** Base64 or URIs */
	images: string[]
}

/** For UPDATE_SETTINGS */
export interface UpdateSettingsRequest {
	/**
	 * Using Struct to represent the diverse settings object in TS
	 * Alternatives: oneof for each setting type, or dedicated fields
	 */
	settingsUpdate?: { [key: string]: any } | undefined
	/** Specific known settings can be added as optional fields for type safety: */
	apiConfiguration?: ApiConfiguration | undefined
	/** Corresponds to chatSettings? */
	chatSettings?: ChatSettings | undefined
	/** Corresponds to planActSeparateModelsSetting? */
	planActSeparateModelsSetting?: boolean | undefined
	/** Corresponds to customInstructionsSetting? */
	customInstructionsSetting?: string | undefined
}

/** For OPTIONS_RESPONSE */
export interface OptionsResponseRequest {
	/** Corresponds to text? in TS */
	selectedOption: string
}

/** For TASK_FEEDBACK */
export interface TaskFeedbackRequest {
	/** Corresponds to feedbackType? in TS */
	feedbackType: TaskFeedbackType
	/** Corresponds to text? in TS */
	text?: string | undefined
}

/** For GET_RELATIVE_PATHS */
export interface GetRelativePathsRequest {
	/** Corresponds to uris? in TS */
	uris: string[]
}

/** For SEARCH_FILES */
export interface SearchFilesRequest {
	/** Corresponds to query? in TS */
	query: string
}

/** For TOGGLE_FAVORITE_MODEL */
export interface ToggleFavoriteModelRequest {
	/** Corresponds to modelId? in TS */
	modelId: string
	/** Corresponds to bool? in TS (assuming that's the favorite status) */
	isFavorite: boolean
}

/** For GRPC_REQUEST (Tunneling) */
export interface GrpcRequest {
	service: string
	method: string
	/** JSON serialized protobuf message from TS `any` */
	message?: any | undefined
	requestId: string
}

/** For TOGGLE_CLINE_RULE */
export interface ToggleClineRuleRequest {
	/** Corresponds to rulePath? in TS */
	rulePath: string
	/** Corresponds to isGlobal? in TS */
	isGlobal: boolean
	/** Corresponds to enabled? in TS */
	enabled: boolean
}

/** For DELETE_CLINE_RULE */
export interface DeleteClineRuleRequest {
	/** Corresponds to rulePath? in TS */
	rulePath: string
	/** Corresponds to isGlobal? in TS */
	isGlobal: boolean
}

/** For ADD_REMOTE_SERVER */
export interface AddRemoteServerRequestPayload {
	/** Corresponds to text? in TS */
	serverConfig: string
}

function createBasePriceTier(): PriceTier {
	return { tokenLimit: 0, price: 0 }
}

export const PriceTier: MessageFns<PriceTier> = {
	encode(message: PriceTier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.tokenLimit !== 0) {
			writer.uint32(9).double(message.tokenLimit)
		}
		if (message.price !== 0) {
			writer.uint32(17).double(message.price)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): PriceTier {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBasePriceTier()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 9) {
						break
					}

					message.tokenLimit = reader.double()
					continue
				}
				case 2: {
					if (tag !== 17) {
						break
					}

					message.price = reader.double()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): PriceTier {
		return {
			tokenLimit: isSet(object.tokenLimit) ? globalThis.Number(object.tokenLimit) : 0,
			price: isSet(object.price) ? globalThis.Number(object.price) : 0,
		}
	},

	toJSON(message: PriceTier): unknown {
		const obj: any = {}
		if (message.tokenLimit !== 0) {
			obj.tokenLimit = message.tokenLimit
		}
		if (message.price !== 0) {
			obj.price = message.price
		}
		return obj
	},

	create<I extends Exact<DeepPartial<PriceTier>, I>>(base?: I): PriceTier {
		return PriceTier.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<PriceTier>, I>>(object: I): PriceTier {
		const message = createBasePriceTier()
		message.tokenLimit = object.tokenLimit ?? 0
		message.price = object.price ?? 0
		return message
	},
}

function createBaseModelInfo(): ModelInfo {
	return {
		maxTokens: undefined,
		contextWindow: undefined,
		supportsImages: undefined,
		supportsPromptCache: false,
		inputPrice: undefined,
		inputPriceTiers: [],
		outputPrice: undefined,
		outputPriceTiers: [],
		thinkingConfig: undefined,
		cacheWritesPrice: undefined,
		cacheReadsPrice: undefined,
		description: undefined,
	}
}

export const ModelInfo: MessageFns<ModelInfo> = {
	encode(message: ModelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.maxTokens !== undefined) {
			writer.uint32(8).int64(message.maxTokens)
		}
		if (message.contextWindow !== undefined) {
			writer.uint32(16).int64(message.contextWindow)
		}
		if (message.supportsImages !== undefined) {
			writer.uint32(24).bool(message.supportsImages)
		}
		if (message.supportsPromptCache !== false) {
			writer.uint32(32).bool(message.supportsPromptCache)
		}
		if (message.inputPrice !== undefined) {
			writer.uint32(41).double(message.inputPrice)
		}
		for (const v of message.inputPriceTiers) {
			PriceTier.encode(v!, writer.uint32(50).fork()).join()
		}
		if (message.outputPrice !== undefined) {
			writer.uint32(57).double(message.outputPrice)
		}
		for (const v of message.outputPriceTiers) {
			PriceTier.encode(v!, writer.uint32(66).fork()).join()
		}
		if (message.thinkingConfig !== undefined) {
			ModelInfo_ThinkingConfig.encode(message.thinkingConfig, writer.uint32(74).fork()).join()
		}
		if (message.cacheWritesPrice !== undefined) {
			writer.uint32(81).double(message.cacheWritesPrice)
		}
		if (message.cacheReadsPrice !== undefined) {
			writer.uint32(89).double(message.cacheReadsPrice)
		}
		if (message.description !== undefined) {
			writer.uint32(98).string(message.description)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ModelInfo {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseModelInfo()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.maxTokens = longToNumber(reader.int64())
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.contextWindow = longToNumber(reader.int64())
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.supportsImages = reader.bool()
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.supportsPromptCache = reader.bool()
					continue
				}
				case 5: {
					if (tag !== 41) {
						break
					}

					message.inputPrice = reader.double()
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.inputPriceTiers.push(PriceTier.decode(reader, reader.uint32()))
					continue
				}
				case 7: {
					if (tag !== 57) {
						break
					}

					message.outputPrice = reader.double()
					continue
				}
				case 8: {
					if (tag !== 66) {
						break
					}

					message.outputPriceTiers.push(PriceTier.decode(reader, reader.uint32()))
					continue
				}
				case 9: {
					if (tag !== 74) {
						break
					}

					message.thinkingConfig = ModelInfo_ThinkingConfig.decode(reader, reader.uint32())
					continue
				}
				case 10: {
					if (tag !== 81) {
						break
					}

					message.cacheWritesPrice = reader.double()
					continue
				}
				case 11: {
					if (tag !== 89) {
						break
					}

					message.cacheReadsPrice = reader.double()
					continue
				}
				case 12: {
					if (tag !== 98) {
						break
					}

					message.description = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ModelInfo {
		return {
			maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
			contextWindow: isSet(object.contextWindow) ? globalThis.Number(object.contextWindow) : undefined,
			supportsImages: isSet(object.supportsImages) ? globalThis.Boolean(object.supportsImages) : undefined,
			supportsPromptCache: isSet(object.supportsPromptCache) ? globalThis.Boolean(object.supportsPromptCache) : false,
			inputPrice: isSet(object.inputPrice) ? globalThis.Number(object.inputPrice) : undefined,
			inputPriceTiers: globalThis.Array.isArray(object?.inputPriceTiers)
				? object.inputPriceTiers.map((e: any) => PriceTier.fromJSON(e))
				: [],
			outputPrice: isSet(object.outputPrice) ? globalThis.Number(object.outputPrice) : undefined,
			outputPriceTiers: globalThis.Array.isArray(object?.outputPriceTiers)
				? object.outputPriceTiers.map((e: any) => PriceTier.fromJSON(e))
				: [],
			thinkingConfig: isSet(object.thinkingConfig) ? ModelInfo_ThinkingConfig.fromJSON(object.thinkingConfig) : undefined,
			cacheWritesPrice: isSet(object.cacheWritesPrice) ? globalThis.Number(object.cacheWritesPrice) : undefined,
			cacheReadsPrice: isSet(object.cacheReadsPrice) ? globalThis.Number(object.cacheReadsPrice) : undefined,
			description: isSet(object.description) ? globalThis.String(object.description) : undefined,
		}
	},

	toJSON(message: ModelInfo): unknown {
		const obj: any = {}
		if (message.maxTokens !== undefined) {
			obj.maxTokens = Math.round(message.maxTokens)
		}
		if (message.contextWindow !== undefined) {
			obj.contextWindow = Math.round(message.contextWindow)
		}
		if (message.supportsImages !== undefined) {
			obj.supportsImages = message.supportsImages
		}
		if (message.supportsPromptCache !== false) {
			obj.supportsPromptCache = message.supportsPromptCache
		}
		if (message.inputPrice !== undefined) {
			obj.inputPrice = message.inputPrice
		}
		if (message.inputPriceTiers?.length) {
			obj.inputPriceTiers = message.inputPriceTiers.map((e) => PriceTier.toJSON(e))
		}
		if (message.outputPrice !== undefined) {
			obj.outputPrice = message.outputPrice
		}
		if (message.outputPriceTiers?.length) {
			obj.outputPriceTiers = message.outputPriceTiers.map((e) => PriceTier.toJSON(e))
		}
		if (message.thinkingConfig !== undefined) {
			obj.thinkingConfig = ModelInfo_ThinkingConfig.toJSON(message.thinkingConfig)
		}
		if (message.cacheWritesPrice !== undefined) {
			obj.cacheWritesPrice = message.cacheWritesPrice
		}
		if (message.cacheReadsPrice !== undefined) {
			obj.cacheReadsPrice = message.cacheReadsPrice
		}
		if (message.description !== undefined) {
			obj.description = message.description
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ModelInfo>, I>>(base?: I): ModelInfo {
		return ModelInfo.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ModelInfo>, I>>(object: I): ModelInfo {
		const message = createBaseModelInfo()
		message.maxTokens = object.maxTokens ?? undefined
		message.contextWindow = object.contextWindow ?? undefined
		message.supportsImages = object.supportsImages ?? undefined
		message.supportsPromptCache = object.supportsPromptCache ?? false
		message.inputPrice = object.inputPrice ?? undefined
		message.inputPriceTiers = object.inputPriceTiers?.map((e) => PriceTier.fromPartial(e)) || []
		message.outputPrice = object.outputPrice ?? undefined
		message.outputPriceTiers = object.outputPriceTiers?.map((e) => PriceTier.fromPartial(e)) || []
		message.thinkingConfig =
			object.thinkingConfig !== undefined && object.thinkingConfig !== null
				? ModelInfo_ThinkingConfig.fromPartial(object.thinkingConfig)
				: undefined
		message.cacheWritesPrice = object.cacheWritesPrice ?? undefined
		message.cacheReadsPrice = object.cacheReadsPrice ?? undefined
		message.description = object.description ?? undefined
		return message
	},
}

function createBaseModelInfo_ThinkingConfig(): ModelInfo_ThinkingConfig {
	return { maxBudget: undefined, outputPrice: undefined, outputPriceTiers: [] }
}

export const ModelInfo_ThinkingConfig: MessageFns<ModelInfo_ThinkingConfig> = {
	encode(message: ModelInfo_ThinkingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.maxBudget !== undefined) {
			writer.uint32(9).double(message.maxBudget)
		}
		if (message.outputPrice !== undefined) {
			writer.uint32(17).double(message.outputPrice)
		}
		for (const v of message.outputPriceTiers) {
			PriceTier.encode(v!, writer.uint32(26).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ModelInfo_ThinkingConfig {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseModelInfo_ThinkingConfig()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 9) {
						break
					}

					message.maxBudget = reader.double()
					continue
				}
				case 2: {
					if (tag !== 17) {
						break
					}

					message.outputPrice = reader.double()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.outputPriceTiers.push(PriceTier.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ModelInfo_ThinkingConfig {
		return {
			maxBudget: isSet(object.maxBudget) ? globalThis.Number(object.maxBudget) : undefined,
			outputPrice: isSet(object.outputPrice) ? globalThis.Number(object.outputPrice) : undefined,
			outputPriceTiers: globalThis.Array.isArray(object?.outputPriceTiers)
				? object.outputPriceTiers.map((e: any) => PriceTier.fromJSON(e))
				: [],
		}
	},

	toJSON(message: ModelInfo_ThinkingConfig): unknown {
		const obj: any = {}
		if (message.maxBudget !== undefined) {
			obj.maxBudget = message.maxBudget
		}
		if (message.outputPrice !== undefined) {
			obj.outputPrice = message.outputPrice
		}
		if (message.outputPriceTiers?.length) {
			obj.outputPriceTiers = message.outputPriceTiers.map((e) => PriceTier.toJSON(e))
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ModelInfo_ThinkingConfig>, I>>(base?: I): ModelInfo_ThinkingConfig {
		return ModelInfo_ThinkingConfig.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ModelInfo_ThinkingConfig>, I>>(object: I): ModelInfo_ThinkingConfig {
		const message = createBaseModelInfo_ThinkingConfig()
		message.maxBudget = object.maxBudget ?? undefined
		message.outputPrice = object.outputPrice ?? undefined
		message.outputPriceTiers = object.outputPriceTiers?.map((e) => PriceTier.fromPartial(e)) || []
		return message
	},
}

function createBaseOpenAiCompatibleModelInfo(): OpenAiCompatibleModelInfo {
	return { baseInfo: undefined, temperature: undefined, isR1FormatRequired: undefined }
}

export const OpenAiCompatibleModelInfo: MessageFns<OpenAiCompatibleModelInfo> = {
	encode(message: OpenAiCompatibleModelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.baseInfo !== undefined) {
			ModelInfo.encode(message.baseInfo, writer.uint32(10).fork()).join()
		}
		if (message.temperature !== undefined) {
			writer.uint32(17).double(message.temperature)
		}
		if (message.isR1FormatRequired !== undefined) {
			writer.uint32(24).bool(message.isR1FormatRequired)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): OpenAiCompatibleModelInfo {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseOpenAiCompatibleModelInfo()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.baseInfo = ModelInfo.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 17) {
						break
					}

					message.temperature = reader.double()
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.isR1FormatRequired = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): OpenAiCompatibleModelInfo {
		return {
			baseInfo: isSet(object.baseInfo) ? ModelInfo.fromJSON(object.baseInfo) : undefined,
			temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
			isR1FormatRequired: isSet(object.isR1FormatRequired) ? globalThis.Boolean(object.isR1FormatRequired) : undefined,
		}
	},

	toJSON(message: OpenAiCompatibleModelInfo): unknown {
		const obj: any = {}
		if (message.baseInfo !== undefined) {
			obj.baseInfo = ModelInfo.toJSON(message.baseInfo)
		}
		if (message.temperature !== undefined) {
			obj.temperature = message.temperature
		}
		if (message.isR1FormatRequired !== undefined) {
			obj.isR1FormatRequired = message.isR1FormatRequired
		}
		return obj
	},

	create<I extends Exact<DeepPartial<OpenAiCompatibleModelInfo>, I>>(base?: I): OpenAiCompatibleModelInfo {
		return OpenAiCompatibleModelInfo.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<OpenAiCompatibleModelInfo>, I>>(object: I): OpenAiCompatibleModelInfo {
		const message = createBaseOpenAiCompatibleModelInfo()
		message.baseInfo =
			object.baseInfo !== undefined && object.baseInfo !== null ? ModelInfo.fromPartial(object.baseInfo) : undefined
		message.temperature = object.temperature ?? undefined
		message.isR1FormatRequired = object.isR1FormatRequired ?? undefined
		return message
	},
}

function createBaseLanguageModelChatSelector(): LanguageModelChatSelector {
	return { id: "" }
}

export const LanguageModelChatSelector: MessageFns<LanguageModelChatSelector> = {
	encode(message: LanguageModelChatSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.id !== "") {
			writer.uint32(10).string(message.id)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): LanguageModelChatSelector {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseLanguageModelChatSelector()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.id = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): LanguageModelChatSelector {
		return { id: isSet(object.id) ? globalThis.String(object.id) : "" }
	},

	toJSON(message: LanguageModelChatSelector): unknown {
		const obj: any = {}
		if (message.id !== "") {
			obj.id = message.id
		}
		return obj
	},

	create<I extends Exact<DeepPartial<LanguageModelChatSelector>, I>>(base?: I): LanguageModelChatSelector {
		return LanguageModelChatSelector.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<LanguageModelChatSelector>, I>>(object: I): LanguageModelChatSelector {
		const message = createBaseLanguageModelChatSelector()
		message.id = object.id ?? ""
		return message
	},
}

function createBaseApiConfiguration(): ApiConfiguration {
	return {
		apiModelId: undefined,
		apiKey: undefined,
		clineApiKey: undefined,
		taskId: undefined,
		liteLlmBaseUrl: undefined,
		liteLlmModelId: undefined,
		liteLlmApiKey: undefined,
		liteLlmUsePromptCache: undefined,
		openAiHeaders: {},
		anthropicBaseUrl: undefined,
		openRouterApiKey: undefined,
		openRouterModelId: undefined,
		openRouterModelInfo: undefined,
		openRouterProviderSorting: undefined,
		awsAccessKey: undefined,
		awsSecretKey: undefined,
		awsSessionToken: undefined,
		awsRegion: undefined,
		awsUseCrossRegionInference: undefined,
		awsBedrockUsePromptCache: undefined,
		awsUseProfile: undefined,
		awsProfile: undefined,
		awsBedrockEndpoint: undefined,
		vertexProjectId: undefined,
		vertexRegion: undefined,
		openAiBaseUrl: undefined,
		openAiApiKey: undefined,
		openAiModelId: undefined,
		openAiModelInfo: undefined,
		ollamaModelId: undefined,
		ollamaBaseUrl: undefined,
		ollamaApiOptionsCtxNum: undefined,
		lmStudioModelId: undefined,
		lmStudioBaseUrl: undefined,
		geminiApiKey: undefined,
		geminiBaseUrl: undefined,
		openAiNativeApiKey: undefined,
		deepSeekApiKey: undefined,
		requestyApiKey: undefined,
		requestyModelId: undefined,
		requestyModelInfo: undefined,
		togetherApiKey: undefined,
		togetherModelId: undefined,
		qwenApiKey: undefined,
		doubaoApiKey: undefined,
		mistralApiKey: undefined,
		azureApiVersion: undefined,
		vsCodeLmModelSelector: undefined,
		o3MiniReasoningEffort: undefined,
		qwenApiLine: undefined,
		asksageApiUrl: undefined,
		asksageApiKey: undefined,
		xaiApiKey: undefined,
		thinkingBudgetTokens: undefined,
		reasoningEffort: undefined,
		sambanovaApiKey: undefined,
		apiProvider: undefined,
		favoritedModelIds: [],
	}
}

export const ApiConfiguration: MessageFns<ApiConfiguration> = {
	encode(message: ApiConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.apiModelId !== undefined) {
			writer.uint32(10).string(message.apiModelId)
		}
		if (message.apiKey !== undefined) {
			writer.uint32(18).string(message.apiKey)
		}
		if (message.clineApiKey !== undefined) {
			writer.uint32(26).string(message.clineApiKey)
		}
		if (message.taskId !== undefined) {
			writer.uint32(34).string(message.taskId)
		}
		if (message.liteLlmBaseUrl !== undefined) {
			writer.uint32(42).string(message.liteLlmBaseUrl)
		}
		if (message.liteLlmModelId !== undefined) {
			writer.uint32(50).string(message.liteLlmModelId)
		}
		if (message.liteLlmApiKey !== undefined) {
			writer.uint32(58).string(message.liteLlmApiKey)
		}
		if (message.liteLlmUsePromptCache !== undefined) {
			writer.uint32(64).bool(message.liteLlmUsePromptCache)
		}
		Object.entries(message.openAiHeaders).forEach(([key, value]) => {
			ApiConfiguration_OpenAiHeadersEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join()
		})
		if (message.anthropicBaseUrl !== undefined) {
			writer.uint32(82).string(message.anthropicBaseUrl)
		}
		if (message.openRouterApiKey !== undefined) {
			writer.uint32(90).string(message.openRouterApiKey)
		}
		if (message.openRouterModelId !== undefined) {
			writer.uint32(98).string(message.openRouterModelId)
		}
		if (message.openRouterModelInfo !== undefined) {
			ModelInfo.encode(message.openRouterModelInfo, writer.uint32(106).fork()).join()
		}
		if (message.openRouterProviderSorting !== undefined) {
			writer.uint32(114).string(message.openRouterProviderSorting)
		}
		if (message.awsAccessKey !== undefined) {
			writer.uint32(122).string(message.awsAccessKey)
		}
		if (message.awsSecretKey !== undefined) {
			writer.uint32(130).string(message.awsSecretKey)
		}
		if (message.awsSessionToken !== undefined) {
			writer.uint32(138).string(message.awsSessionToken)
		}
		if (message.awsRegion !== undefined) {
			writer.uint32(146).string(message.awsRegion)
		}
		if (message.awsUseCrossRegionInference !== undefined) {
			writer.uint32(152).bool(message.awsUseCrossRegionInference)
		}
		if (message.awsBedrockUsePromptCache !== undefined) {
			writer.uint32(160).bool(message.awsBedrockUsePromptCache)
		}
		if (message.awsUseProfile !== undefined) {
			writer.uint32(168).bool(message.awsUseProfile)
		}
		if (message.awsProfile !== undefined) {
			writer.uint32(178).string(message.awsProfile)
		}
		if (message.awsBedrockEndpoint !== undefined) {
			writer.uint32(186).string(message.awsBedrockEndpoint)
		}
		if (message.vertexProjectId !== undefined) {
			writer.uint32(194).string(message.vertexProjectId)
		}
		if (message.vertexRegion !== undefined) {
			writer.uint32(202).string(message.vertexRegion)
		}
		if (message.openAiBaseUrl !== undefined) {
			writer.uint32(210).string(message.openAiBaseUrl)
		}
		if (message.openAiApiKey !== undefined) {
			writer.uint32(218).string(message.openAiApiKey)
		}
		if (message.openAiModelId !== undefined) {
			writer.uint32(226).string(message.openAiModelId)
		}
		if (message.openAiModelInfo !== undefined) {
			OpenAiCompatibleModelInfo.encode(message.openAiModelInfo, writer.uint32(234).fork()).join()
		}
		if (message.ollamaModelId !== undefined) {
			writer.uint32(242).string(message.ollamaModelId)
		}
		if (message.ollamaBaseUrl !== undefined) {
			writer.uint32(250).string(message.ollamaBaseUrl)
		}
		if (message.ollamaApiOptionsCtxNum !== undefined) {
			writer.uint32(258).string(message.ollamaApiOptionsCtxNum)
		}
		if (message.lmStudioModelId !== undefined) {
			writer.uint32(266).string(message.lmStudioModelId)
		}
		if (message.lmStudioBaseUrl !== undefined) {
			writer.uint32(274).string(message.lmStudioBaseUrl)
		}
		if (message.geminiApiKey !== undefined) {
			writer.uint32(282).string(message.geminiApiKey)
		}
		if (message.geminiBaseUrl !== undefined) {
			writer.uint32(290).string(message.geminiBaseUrl)
		}
		if (message.openAiNativeApiKey !== undefined) {
			writer.uint32(298).string(message.openAiNativeApiKey)
		}
		if (message.deepSeekApiKey !== undefined) {
			writer.uint32(306).string(message.deepSeekApiKey)
		}
		if (message.requestyApiKey !== undefined) {
			writer.uint32(314).string(message.requestyApiKey)
		}
		if (message.requestyModelId !== undefined) {
			writer.uint32(322).string(message.requestyModelId)
		}
		if (message.requestyModelInfo !== undefined) {
			ModelInfo.encode(message.requestyModelInfo, writer.uint32(330).fork()).join()
		}
		if (message.togetherApiKey !== undefined) {
			writer.uint32(338).string(message.togetherApiKey)
		}
		if (message.togetherModelId !== undefined) {
			writer.uint32(346).string(message.togetherModelId)
		}
		if (message.qwenApiKey !== undefined) {
			writer.uint32(354).string(message.qwenApiKey)
		}
		if (message.doubaoApiKey !== undefined) {
			writer.uint32(362).string(message.doubaoApiKey)
		}
		if (message.mistralApiKey !== undefined) {
			writer.uint32(370).string(message.mistralApiKey)
		}
		if (message.azureApiVersion !== undefined) {
			writer.uint32(378).string(message.azureApiVersion)
		}
		if (message.vsCodeLmModelSelector !== undefined) {
			LanguageModelChatSelector.encode(message.vsCodeLmModelSelector, writer.uint32(386).fork()).join()
		}
		if (message.o3MiniReasoningEffort !== undefined) {
			writer.uint32(394).string(message.o3MiniReasoningEffort)
		}
		if (message.qwenApiLine !== undefined) {
			writer.uint32(402).string(message.qwenApiLine)
		}
		if (message.asksageApiUrl !== undefined) {
			writer.uint32(410).string(message.asksageApiUrl)
		}
		if (message.asksageApiKey !== undefined) {
			writer.uint32(418).string(message.asksageApiKey)
		}
		if (message.xaiApiKey !== undefined) {
			writer.uint32(426).string(message.xaiApiKey)
		}
		if (message.thinkingBudgetTokens !== undefined) {
			writer.uint32(433).double(message.thinkingBudgetTokens)
		}
		if (message.reasoningEffort !== undefined) {
			writer.uint32(442).string(message.reasoningEffort)
		}
		if (message.sambanovaApiKey !== undefined) {
			writer.uint32(450).string(message.sambanovaApiKey)
		}
		if (message.apiProvider !== undefined) {
			writer.uint32(456).int32(message.apiProvider)
		}
		for (const v of message.favoritedModelIds) {
			writer.uint32(466).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ApiConfiguration {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseApiConfiguration()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.apiModelId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.apiKey = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.clineApiKey = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.taskId = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.liteLlmBaseUrl = reader.string()
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.liteLlmModelId = reader.string()
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.liteLlmApiKey = reader.string()
					continue
				}
				case 8: {
					if (tag !== 64) {
						break
					}

					message.liteLlmUsePromptCache = reader.bool()
					continue
				}
				case 9: {
					if (tag !== 74) {
						break
					}

					const entry9 = ApiConfiguration_OpenAiHeadersEntry.decode(reader, reader.uint32())
					if (entry9.value !== undefined) {
						message.openAiHeaders[entry9.key] = entry9.value
					}
					continue
				}
				case 10: {
					if (tag !== 82) {
						break
					}

					message.anthropicBaseUrl = reader.string()
					continue
				}
				case 11: {
					if (tag !== 90) {
						break
					}

					message.openRouterApiKey = reader.string()
					continue
				}
				case 12: {
					if (tag !== 98) {
						break
					}

					message.openRouterModelId = reader.string()
					continue
				}
				case 13: {
					if (tag !== 106) {
						break
					}

					message.openRouterModelInfo = ModelInfo.decode(reader, reader.uint32())
					continue
				}
				case 14: {
					if (tag !== 114) {
						break
					}

					message.openRouterProviderSorting = reader.string()
					continue
				}
				case 15: {
					if (tag !== 122) {
						break
					}

					message.awsAccessKey = reader.string()
					continue
				}
				case 16: {
					if (tag !== 130) {
						break
					}

					message.awsSecretKey = reader.string()
					continue
				}
				case 17: {
					if (tag !== 138) {
						break
					}

					message.awsSessionToken = reader.string()
					continue
				}
				case 18: {
					if (tag !== 146) {
						break
					}

					message.awsRegion = reader.string()
					continue
				}
				case 19: {
					if (tag !== 152) {
						break
					}

					message.awsUseCrossRegionInference = reader.bool()
					continue
				}
				case 20: {
					if (tag !== 160) {
						break
					}

					message.awsBedrockUsePromptCache = reader.bool()
					continue
				}
				case 21: {
					if (tag !== 168) {
						break
					}

					message.awsUseProfile = reader.bool()
					continue
				}
				case 22: {
					if (tag !== 178) {
						break
					}

					message.awsProfile = reader.string()
					continue
				}
				case 23: {
					if (tag !== 186) {
						break
					}

					message.awsBedrockEndpoint = reader.string()
					continue
				}
				case 24: {
					if (tag !== 194) {
						break
					}

					message.vertexProjectId = reader.string()
					continue
				}
				case 25: {
					if (tag !== 202) {
						break
					}

					message.vertexRegion = reader.string()
					continue
				}
				case 26: {
					if (tag !== 210) {
						break
					}

					message.openAiBaseUrl = reader.string()
					continue
				}
				case 27: {
					if (tag !== 218) {
						break
					}

					message.openAiApiKey = reader.string()
					continue
				}
				case 28: {
					if (tag !== 226) {
						break
					}

					message.openAiModelId = reader.string()
					continue
				}
				case 29: {
					if (tag !== 234) {
						break
					}

					message.openAiModelInfo = OpenAiCompatibleModelInfo.decode(reader, reader.uint32())
					continue
				}
				case 30: {
					if (tag !== 242) {
						break
					}

					message.ollamaModelId = reader.string()
					continue
				}
				case 31: {
					if (tag !== 250) {
						break
					}

					message.ollamaBaseUrl = reader.string()
					continue
				}
				case 32: {
					if (tag !== 258) {
						break
					}

					message.ollamaApiOptionsCtxNum = reader.string()
					continue
				}
				case 33: {
					if (tag !== 266) {
						break
					}

					message.lmStudioModelId = reader.string()
					continue
				}
				case 34: {
					if (tag !== 274) {
						break
					}

					message.lmStudioBaseUrl = reader.string()
					continue
				}
				case 35: {
					if (tag !== 282) {
						break
					}

					message.geminiApiKey = reader.string()
					continue
				}
				case 36: {
					if (tag !== 290) {
						break
					}

					message.geminiBaseUrl = reader.string()
					continue
				}
				case 37: {
					if (tag !== 298) {
						break
					}

					message.openAiNativeApiKey = reader.string()
					continue
				}
				case 38: {
					if (tag !== 306) {
						break
					}

					message.deepSeekApiKey = reader.string()
					continue
				}
				case 39: {
					if (tag !== 314) {
						break
					}

					message.requestyApiKey = reader.string()
					continue
				}
				case 40: {
					if (tag !== 322) {
						break
					}

					message.requestyModelId = reader.string()
					continue
				}
				case 41: {
					if (tag !== 330) {
						break
					}

					message.requestyModelInfo = ModelInfo.decode(reader, reader.uint32())
					continue
				}
				case 42: {
					if (tag !== 338) {
						break
					}

					message.togetherApiKey = reader.string()
					continue
				}
				case 43: {
					if (tag !== 346) {
						break
					}

					message.togetherModelId = reader.string()
					continue
				}
				case 44: {
					if (tag !== 354) {
						break
					}

					message.qwenApiKey = reader.string()
					continue
				}
				case 45: {
					if (tag !== 362) {
						break
					}

					message.doubaoApiKey = reader.string()
					continue
				}
				case 46: {
					if (tag !== 370) {
						break
					}

					message.mistralApiKey = reader.string()
					continue
				}
				case 47: {
					if (tag !== 378) {
						break
					}

					message.azureApiVersion = reader.string()
					continue
				}
				case 48: {
					if (tag !== 386) {
						break
					}

					message.vsCodeLmModelSelector = LanguageModelChatSelector.decode(reader, reader.uint32())
					continue
				}
				case 49: {
					if (tag !== 394) {
						break
					}

					message.o3MiniReasoningEffort = reader.string()
					continue
				}
				case 50: {
					if (tag !== 402) {
						break
					}

					message.qwenApiLine = reader.string()
					continue
				}
				case 51: {
					if (tag !== 410) {
						break
					}

					message.asksageApiUrl = reader.string()
					continue
				}
				case 52: {
					if (tag !== 418) {
						break
					}

					message.asksageApiKey = reader.string()
					continue
				}
				case 53: {
					if (tag !== 426) {
						break
					}

					message.xaiApiKey = reader.string()
					continue
				}
				case 54: {
					if (tag !== 433) {
						break
					}

					message.thinkingBudgetTokens = reader.double()
					continue
				}
				case 55: {
					if (tag !== 442) {
						break
					}

					message.reasoningEffort = reader.string()
					continue
				}
				case 56: {
					if (tag !== 450) {
						break
					}

					message.sambanovaApiKey = reader.string()
					continue
				}
				case 57: {
					if (tag !== 456) {
						break
					}

					message.apiProvider = reader.int32() as any
					continue
				}
				case 58: {
					if (tag !== 466) {
						break
					}

					message.favoritedModelIds.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ApiConfiguration {
		return {
			apiModelId: isSet(object.apiModelId) ? globalThis.String(object.apiModelId) : undefined,
			apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : undefined,
			clineApiKey: isSet(object.clineApiKey) ? globalThis.String(object.clineApiKey) : undefined,
			taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : undefined,
			liteLlmBaseUrl: isSet(object.liteLlmBaseUrl) ? globalThis.String(object.liteLlmBaseUrl) : undefined,
			liteLlmModelId: isSet(object.liteLlmModelId) ? globalThis.String(object.liteLlmModelId) : undefined,
			liteLlmApiKey: isSet(object.liteLlmApiKey) ? globalThis.String(object.liteLlmApiKey) : undefined,
			liteLlmUsePromptCache: isSet(object.liteLlmUsePromptCache)
				? globalThis.Boolean(object.liteLlmUsePromptCache)
				: undefined,
			openAiHeaders: isObject(object.openAiHeaders)
				? Object.entries(object.openAiHeaders).reduce<{ [key: string]: string }>((acc, [key, value]) => {
						acc[key] = String(value)
						return acc
					}, {})
				: {},
			anthropicBaseUrl: isSet(object.anthropicBaseUrl) ? globalThis.String(object.anthropicBaseUrl) : undefined,
			openRouterApiKey: isSet(object.openRouterApiKey) ? globalThis.String(object.openRouterApiKey) : undefined,
			openRouterModelId: isSet(object.openRouterModelId) ? globalThis.String(object.openRouterModelId) : undefined,
			openRouterModelInfo: isSet(object.openRouterModelInfo) ? ModelInfo.fromJSON(object.openRouterModelInfo) : undefined,
			openRouterProviderSorting: isSet(object.openRouterProviderSorting)
				? globalThis.String(object.openRouterProviderSorting)
				: undefined,
			awsAccessKey: isSet(object.awsAccessKey) ? globalThis.String(object.awsAccessKey) : undefined,
			awsSecretKey: isSet(object.awsSecretKey) ? globalThis.String(object.awsSecretKey) : undefined,
			awsSessionToken: isSet(object.awsSessionToken) ? globalThis.String(object.awsSessionToken) : undefined,
			awsRegion: isSet(object.awsRegion) ? globalThis.String(object.awsRegion) : undefined,
			awsUseCrossRegionInference: isSet(object.awsUseCrossRegionInference)
				? globalThis.Boolean(object.awsUseCrossRegionInference)
				: undefined,
			awsBedrockUsePromptCache: isSet(object.awsBedrockUsePromptCache)
				? globalThis.Boolean(object.awsBedrockUsePromptCache)
				: undefined,
			awsUseProfile: isSet(object.awsUseProfile) ? globalThis.Boolean(object.awsUseProfile) : undefined,
			awsProfile: isSet(object.awsProfile) ? globalThis.String(object.awsProfile) : undefined,
			awsBedrockEndpoint: isSet(object.awsBedrockEndpoint) ? globalThis.String(object.awsBedrockEndpoint) : undefined,
			vertexProjectId: isSet(object.vertexProjectId) ? globalThis.String(object.vertexProjectId) : undefined,
			vertexRegion: isSet(object.vertexRegion) ? globalThis.String(object.vertexRegion) : undefined,
			openAiBaseUrl: isSet(object.openAiBaseUrl) ? globalThis.String(object.openAiBaseUrl) : undefined,
			openAiApiKey: isSet(object.openAiApiKey) ? globalThis.String(object.openAiApiKey) : undefined,
			openAiModelId: isSet(object.openAiModelId) ? globalThis.String(object.openAiModelId) : undefined,
			openAiModelInfo: isSet(object.openAiModelInfo)
				? OpenAiCompatibleModelInfo.fromJSON(object.openAiModelInfo)
				: undefined,
			ollamaModelId: isSet(object.ollamaModelId) ? globalThis.String(object.ollamaModelId) : undefined,
			ollamaBaseUrl: isSet(object.ollamaBaseUrl) ? globalThis.String(object.ollamaBaseUrl) : undefined,
			ollamaApiOptionsCtxNum: isSet(object.ollamaApiOptionsCtxNum)
				? globalThis.String(object.ollamaApiOptionsCtxNum)
				: undefined,
			lmStudioModelId: isSet(object.lmStudioModelId) ? globalThis.String(object.lmStudioModelId) : undefined,
			lmStudioBaseUrl: isSet(object.lmStudioBaseUrl) ? globalThis.String(object.lmStudioBaseUrl) : undefined,
			geminiApiKey: isSet(object.geminiApiKey) ? globalThis.String(object.geminiApiKey) : undefined,
			geminiBaseUrl: isSet(object.geminiBaseUrl) ? globalThis.String(object.geminiBaseUrl) : undefined,
			openAiNativeApiKey: isSet(object.openAiNativeApiKey) ? globalThis.String(object.openAiNativeApiKey) : undefined,
			deepSeekApiKey: isSet(object.deepSeekApiKey) ? globalThis.String(object.deepSeekApiKey) : undefined,
			requestyApiKey: isSet(object.requestyApiKey) ? globalThis.String(object.requestyApiKey) : undefined,
			requestyModelId: isSet(object.requestyModelId) ? globalThis.String(object.requestyModelId) : undefined,
			requestyModelInfo: isSet(object.requestyModelInfo) ? ModelInfo.fromJSON(object.requestyModelInfo) : undefined,
			togetherApiKey: isSet(object.togetherApiKey) ? globalThis.String(object.togetherApiKey) : undefined,
			togetherModelId: isSet(object.togetherModelId) ? globalThis.String(object.togetherModelId) : undefined,
			qwenApiKey: isSet(object.qwenApiKey) ? globalThis.String(object.qwenApiKey) : undefined,
			doubaoApiKey: isSet(object.doubaoApiKey) ? globalThis.String(object.doubaoApiKey) : undefined,
			mistralApiKey: isSet(object.mistralApiKey) ? globalThis.String(object.mistralApiKey) : undefined,
			azureApiVersion: isSet(object.azureApiVersion) ? globalThis.String(object.azureApiVersion) : undefined,
			vsCodeLmModelSelector: isSet(object.vsCodeLmModelSelector)
				? LanguageModelChatSelector.fromJSON(object.vsCodeLmModelSelector)
				: undefined,
			o3MiniReasoningEffort: isSet(object.o3MiniReasoningEffort)
				? globalThis.String(object.o3MiniReasoningEffort)
				: undefined,
			qwenApiLine: isSet(object.qwenApiLine) ? globalThis.String(object.qwenApiLine) : undefined,
			asksageApiUrl: isSet(object.asksageApiUrl) ? globalThis.String(object.asksageApiUrl) : undefined,
			asksageApiKey: isSet(object.asksageApiKey) ? globalThis.String(object.asksageApiKey) : undefined,
			xaiApiKey: isSet(object.xaiApiKey) ? globalThis.String(object.xaiApiKey) : undefined,
			thinkingBudgetTokens: isSet(object.thinkingBudgetTokens) ? globalThis.Number(object.thinkingBudgetTokens) : undefined,
			reasoningEffort: isSet(object.reasoningEffort) ? globalThis.String(object.reasoningEffort) : undefined,
			sambanovaApiKey: isSet(object.sambanovaApiKey) ? globalThis.String(object.sambanovaApiKey) : undefined,
			apiProvider: isSet(object.apiProvider) ? apiProviderFromJSON(object.apiProvider) : undefined,
			favoritedModelIds: globalThis.Array.isArray(object?.favoritedModelIds)
				? object.favoritedModelIds.map((e: any) => globalThis.String(e))
				: [],
		}
	},

	toJSON(message: ApiConfiguration): unknown {
		const obj: any = {}
		if (message.apiModelId !== undefined) {
			obj.apiModelId = message.apiModelId
		}
		if (message.apiKey !== undefined) {
			obj.apiKey = message.apiKey
		}
		if (message.clineApiKey !== undefined) {
			obj.clineApiKey = message.clineApiKey
		}
		if (message.taskId !== undefined) {
			obj.taskId = message.taskId
		}
		if (message.liteLlmBaseUrl !== undefined) {
			obj.liteLlmBaseUrl = message.liteLlmBaseUrl
		}
		if (message.liteLlmModelId !== undefined) {
			obj.liteLlmModelId = message.liteLlmModelId
		}
		if (message.liteLlmApiKey !== undefined) {
			obj.liteLlmApiKey = message.liteLlmApiKey
		}
		if (message.liteLlmUsePromptCache !== undefined) {
			obj.liteLlmUsePromptCache = message.liteLlmUsePromptCache
		}
		if (message.openAiHeaders) {
			const entries = Object.entries(message.openAiHeaders)
			if (entries.length > 0) {
				obj.openAiHeaders = {}
				entries.forEach(([k, v]) => {
					obj.openAiHeaders[k] = v
				})
			}
		}
		if (message.anthropicBaseUrl !== undefined) {
			obj.anthropicBaseUrl = message.anthropicBaseUrl
		}
		if (message.openRouterApiKey !== undefined) {
			obj.openRouterApiKey = message.openRouterApiKey
		}
		if (message.openRouterModelId !== undefined) {
			obj.openRouterModelId = message.openRouterModelId
		}
		if (message.openRouterModelInfo !== undefined) {
			obj.openRouterModelInfo = ModelInfo.toJSON(message.openRouterModelInfo)
		}
		if (message.openRouterProviderSorting !== undefined) {
			obj.openRouterProviderSorting = message.openRouterProviderSorting
		}
		if (message.awsAccessKey !== undefined) {
			obj.awsAccessKey = message.awsAccessKey
		}
		if (message.awsSecretKey !== undefined) {
			obj.awsSecretKey = message.awsSecretKey
		}
		if (message.awsSessionToken !== undefined) {
			obj.awsSessionToken = message.awsSessionToken
		}
		if (message.awsRegion !== undefined) {
			obj.awsRegion = message.awsRegion
		}
		if (message.awsUseCrossRegionInference !== undefined) {
			obj.awsUseCrossRegionInference = message.awsUseCrossRegionInference
		}
		if (message.awsBedrockUsePromptCache !== undefined) {
			obj.awsBedrockUsePromptCache = message.awsBedrockUsePromptCache
		}
		if (message.awsUseProfile !== undefined) {
			obj.awsUseProfile = message.awsUseProfile
		}
		if (message.awsProfile !== undefined) {
			obj.awsProfile = message.awsProfile
		}
		if (message.awsBedrockEndpoint !== undefined) {
			obj.awsBedrockEndpoint = message.awsBedrockEndpoint
		}
		if (message.vertexProjectId !== undefined) {
			obj.vertexProjectId = message.vertexProjectId
		}
		if (message.vertexRegion !== undefined) {
			obj.vertexRegion = message.vertexRegion
		}
		if (message.openAiBaseUrl !== undefined) {
			obj.openAiBaseUrl = message.openAiBaseUrl
		}
		if (message.openAiApiKey !== undefined) {
			obj.openAiApiKey = message.openAiApiKey
		}
		if (message.openAiModelId !== undefined) {
			obj.openAiModelId = message.openAiModelId
		}
		if (message.openAiModelInfo !== undefined) {
			obj.openAiModelInfo = OpenAiCompatibleModelInfo.toJSON(message.openAiModelInfo)
		}
		if (message.ollamaModelId !== undefined) {
			obj.ollamaModelId = message.ollamaModelId
		}
		if (message.ollamaBaseUrl !== undefined) {
			obj.ollamaBaseUrl = message.ollamaBaseUrl
		}
		if (message.ollamaApiOptionsCtxNum !== undefined) {
			obj.ollamaApiOptionsCtxNum = message.ollamaApiOptionsCtxNum
		}
		if (message.lmStudioModelId !== undefined) {
			obj.lmStudioModelId = message.lmStudioModelId
		}
		if (message.lmStudioBaseUrl !== undefined) {
			obj.lmStudioBaseUrl = message.lmStudioBaseUrl
		}
		if (message.geminiApiKey !== undefined) {
			obj.geminiApiKey = message.geminiApiKey
		}
		if (message.geminiBaseUrl !== undefined) {
			obj.geminiBaseUrl = message.geminiBaseUrl
		}
		if (message.openAiNativeApiKey !== undefined) {
			obj.openAiNativeApiKey = message.openAiNativeApiKey
		}
		if (message.deepSeekApiKey !== undefined) {
			obj.deepSeekApiKey = message.deepSeekApiKey
		}
		if (message.requestyApiKey !== undefined) {
			obj.requestyApiKey = message.requestyApiKey
		}
		if (message.requestyModelId !== undefined) {
			obj.requestyModelId = message.requestyModelId
		}
		if (message.requestyModelInfo !== undefined) {
			obj.requestyModelInfo = ModelInfo.toJSON(message.requestyModelInfo)
		}
		if (message.togetherApiKey !== undefined) {
			obj.togetherApiKey = message.togetherApiKey
		}
		if (message.togetherModelId !== undefined) {
			obj.togetherModelId = message.togetherModelId
		}
		if (message.qwenApiKey !== undefined) {
			obj.qwenApiKey = message.qwenApiKey
		}
		if (message.doubaoApiKey !== undefined) {
			obj.doubaoApiKey = message.doubaoApiKey
		}
		if (message.mistralApiKey !== undefined) {
			obj.mistralApiKey = message.mistralApiKey
		}
		if (message.azureApiVersion !== undefined) {
			obj.azureApiVersion = message.azureApiVersion
		}
		if (message.vsCodeLmModelSelector !== undefined) {
			obj.vsCodeLmModelSelector = LanguageModelChatSelector.toJSON(message.vsCodeLmModelSelector)
		}
		if (message.o3MiniReasoningEffort !== undefined) {
			obj.o3MiniReasoningEffort = message.o3MiniReasoningEffort
		}
		if (message.qwenApiLine !== undefined) {
			obj.qwenApiLine = message.qwenApiLine
		}
		if (message.asksageApiUrl !== undefined) {
			obj.asksageApiUrl = message.asksageApiUrl
		}
		if (message.asksageApiKey !== undefined) {
			obj.asksageApiKey = message.asksageApiKey
		}
		if (message.xaiApiKey !== undefined) {
			obj.xaiApiKey = message.xaiApiKey
		}
		if (message.thinkingBudgetTokens !== undefined) {
			obj.thinkingBudgetTokens = message.thinkingBudgetTokens
		}
		if (message.reasoningEffort !== undefined) {
			obj.reasoningEffort = message.reasoningEffort
		}
		if (message.sambanovaApiKey !== undefined) {
			obj.sambanovaApiKey = message.sambanovaApiKey
		}
		if (message.apiProvider !== undefined) {
			obj.apiProvider = apiProviderToJSON(message.apiProvider)
		}
		if (message.favoritedModelIds?.length) {
			obj.favoritedModelIds = message.favoritedModelIds
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ApiConfiguration>, I>>(base?: I): ApiConfiguration {
		return ApiConfiguration.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ApiConfiguration>, I>>(object: I): ApiConfiguration {
		const message = createBaseApiConfiguration()
		message.apiModelId = object.apiModelId ?? undefined
		message.apiKey = object.apiKey ?? undefined
		message.clineApiKey = object.clineApiKey ?? undefined
		message.taskId = object.taskId ?? undefined
		message.liteLlmBaseUrl = object.liteLlmBaseUrl ?? undefined
		message.liteLlmModelId = object.liteLlmModelId ?? undefined
		message.liteLlmApiKey = object.liteLlmApiKey ?? undefined
		message.liteLlmUsePromptCache = object.liteLlmUsePromptCache ?? undefined
		message.openAiHeaders = Object.entries(object.openAiHeaders ?? {}).reduce<{ [key: string]: string }>(
			(acc, [key, value]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value)
				}
				return acc
			},
			{},
		)
		message.anthropicBaseUrl = object.anthropicBaseUrl ?? undefined
		message.openRouterApiKey = object.openRouterApiKey ?? undefined
		message.openRouterModelId = object.openRouterModelId ?? undefined
		message.openRouterModelInfo =
			object.openRouterModelInfo !== undefined && object.openRouterModelInfo !== null
				? ModelInfo.fromPartial(object.openRouterModelInfo)
				: undefined
		message.openRouterProviderSorting = object.openRouterProviderSorting ?? undefined
		message.awsAccessKey = object.awsAccessKey ?? undefined
		message.awsSecretKey = object.awsSecretKey ?? undefined
		message.awsSessionToken = object.awsSessionToken ?? undefined
		message.awsRegion = object.awsRegion ?? undefined
		message.awsUseCrossRegionInference = object.awsUseCrossRegionInference ?? undefined
		message.awsBedrockUsePromptCache = object.awsBedrockUsePromptCache ?? undefined
		message.awsUseProfile = object.awsUseProfile ?? undefined
		message.awsProfile = object.awsProfile ?? undefined
		message.awsBedrockEndpoint = object.awsBedrockEndpoint ?? undefined
		message.vertexProjectId = object.vertexProjectId ?? undefined
		message.vertexRegion = object.vertexRegion ?? undefined
		message.openAiBaseUrl = object.openAiBaseUrl ?? undefined
		message.openAiApiKey = object.openAiApiKey ?? undefined
		message.openAiModelId = object.openAiModelId ?? undefined
		message.openAiModelInfo =
			object.openAiModelInfo !== undefined && object.openAiModelInfo !== null
				? OpenAiCompatibleModelInfo.fromPartial(object.openAiModelInfo)
				: undefined
		message.ollamaModelId = object.ollamaModelId ?? undefined
		message.ollamaBaseUrl = object.ollamaBaseUrl ?? undefined
		message.ollamaApiOptionsCtxNum = object.ollamaApiOptionsCtxNum ?? undefined
		message.lmStudioModelId = object.lmStudioModelId ?? undefined
		message.lmStudioBaseUrl = object.lmStudioBaseUrl ?? undefined
		message.geminiApiKey = object.geminiApiKey ?? undefined
		message.geminiBaseUrl = object.geminiBaseUrl ?? undefined
		message.openAiNativeApiKey = object.openAiNativeApiKey ?? undefined
		message.deepSeekApiKey = object.deepSeekApiKey ?? undefined
		message.requestyApiKey = object.requestyApiKey ?? undefined
		message.requestyModelId = object.requestyModelId ?? undefined
		message.requestyModelInfo =
			object.requestyModelInfo !== undefined && object.requestyModelInfo !== null
				? ModelInfo.fromPartial(object.requestyModelInfo)
				: undefined
		message.togetherApiKey = object.togetherApiKey ?? undefined
		message.togetherModelId = object.togetherModelId ?? undefined
		message.qwenApiKey = object.qwenApiKey ?? undefined
		message.doubaoApiKey = object.doubaoApiKey ?? undefined
		message.mistralApiKey = object.mistralApiKey ?? undefined
		message.azureApiVersion = object.azureApiVersion ?? undefined
		message.vsCodeLmModelSelector =
			object.vsCodeLmModelSelector !== undefined && object.vsCodeLmModelSelector !== null
				? LanguageModelChatSelector.fromPartial(object.vsCodeLmModelSelector)
				: undefined
		message.o3MiniReasoningEffort = object.o3MiniReasoningEffort ?? undefined
		message.qwenApiLine = object.qwenApiLine ?? undefined
		message.asksageApiUrl = object.asksageApiUrl ?? undefined
		message.asksageApiKey = object.asksageApiKey ?? undefined
		message.xaiApiKey = object.xaiApiKey ?? undefined
		message.thinkingBudgetTokens = object.thinkingBudgetTokens ?? undefined
		message.reasoningEffort = object.reasoningEffort ?? undefined
		message.sambanovaApiKey = object.sambanovaApiKey ?? undefined
		message.apiProvider = object.apiProvider ?? undefined
		message.favoritedModelIds = object.favoritedModelIds?.map((e) => e) || []
		return message
	},
}

function createBaseApiConfiguration_OpenAiHeadersEntry(): ApiConfiguration_OpenAiHeadersEntry {
	return { key: "", value: "" }
}

export const ApiConfiguration_OpenAiHeadersEntry: MessageFns<ApiConfiguration_OpenAiHeadersEntry> = {
	encode(message: ApiConfiguration_OpenAiHeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.key !== "") {
			writer.uint32(10).string(message.key)
		}
		if (message.value !== "") {
			writer.uint32(18).string(message.value)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ApiConfiguration_OpenAiHeadersEntry {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseApiConfiguration_OpenAiHeadersEntry()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.key = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.value = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ApiConfiguration_OpenAiHeadersEntry {
		return {
			key: isSet(object.key) ? globalThis.String(object.key) : "",
			value: isSet(object.value) ? globalThis.String(object.value) : "",
		}
	},

	toJSON(message: ApiConfiguration_OpenAiHeadersEntry): unknown {
		const obj: any = {}
		if (message.key !== "") {
			obj.key = message.key
		}
		if (message.value !== "") {
			obj.value = message.value
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ApiConfiguration_OpenAiHeadersEntry>, I>>(base?: I): ApiConfiguration_OpenAiHeadersEntry {
		return ApiConfiguration_OpenAiHeadersEntry.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ApiConfiguration_OpenAiHeadersEntry>, I>>(
		object: I,
	): ApiConfiguration_OpenAiHeadersEntry {
		const message = createBaseApiConfiguration_OpenAiHeadersEntry()
		message.key = object.key ?? ""
		message.value = object.value ?? ""
		return message
	},
}

function createBaseChatSettings(): ChatSettings {
	return { mode: 0 }
}

export const ChatSettings: MessageFns<ChatSettings> = {
	encode(message: ChatSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mode !== 0) {
			writer.uint32(8).int32(message.mode)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ChatSettings {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseChatSettings()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.mode = reader.int32() as any
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ChatSettings {
		return { mode: isSet(object.mode) ? chatModeFromJSON(object.mode) : 0 }
	},

	toJSON(message: ChatSettings): unknown {
		const obj: any = {}
		if (message.mode !== 0) {
			obj.mode = chatModeToJSON(message.mode)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ChatSettings>, I>>(base?: I): ChatSettings {
		return ChatSettings.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ChatSettings>, I>>(object: I): ChatSettings {
		const message = createBaseChatSettings()
		message.mode = object.mode ?? 0
		return message
	},
}

function createBaseBrowserViewport(): BrowserViewport {
	return { width: 0, height: 0 }
}

export const BrowserViewport: MessageFns<BrowserViewport> = {
	encode(message: BrowserViewport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.width !== 0) {
			writer.uint32(8).int32(message.width)
		}
		if (message.height !== 0) {
			writer.uint32(16).int32(message.height)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BrowserViewport {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseBrowserViewport()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.width = reader.int32()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.height = reader.int32()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): BrowserViewport {
		return {
			width: isSet(object.width) ? globalThis.Number(object.width) : 0,
			height: isSet(object.height) ? globalThis.Number(object.height) : 0,
		}
	},

	toJSON(message: BrowserViewport): unknown {
		const obj: any = {}
		if (message.width !== 0) {
			obj.width = Math.round(message.width)
		}
		if (message.height !== 0) {
			obj.height = Math.round(message.height)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<BrowserViewport>, I>>(base?: I): BrowserViewport {
		return BrowserViewport.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<BrowserViewport>, I>>(object: I): BrowserViewport {
		const message = createBaseBrowserViewport()
		message.width = object.width ?? 0
		message.height = object.height ?? 0
		return message
	},
}

function createBaseBrowserSettings(): BrowserSettings {
	return { viewport: undefined, remoteBrowserHost: undefined, remoteBrowserEnabled: undefined }
}

export const BrowserSettings: MessageFns<BrowserSettings> = {
	encode(message: BrowserSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.viewport !== undefined) {
			BrowserViewport.encode(message.viewport, writer.uint32(10).fork()).join()
		}
		if (message.remoteBrowserHost !== undefined) {
			writer.uint32(18).string(message.remoteBrowserHost)
		}
		if (message.remoteBrowserEnabled !== undefined) {
			writer.uint32(24).bool(message.remoteBrowserEnabled)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BrowserSettings {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseBrowserSettings()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.viewport = BrowserViewport.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.remoteBrowserHost = reader.string()
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.remoteBrowserEnabled = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): BrowserSettings {
		return {
			viewport: isSet(object.viewport) ? BrowserViewport.fromJSON(object.viewport) : undefined,
			remoteBrowserHost: isSet(object.remoteBrowserHost) ? globalThis.String(object.remoteBrowserHost) : undefined,
			remoteBrowserEnabled: isSet(object.remoteBrowserEnabled)
				? globalThis.Boolean(object.remoteBrowserEnabled)
				: undefined,
		}
	},

	toJSON(message: BrowserSettings): unknown {
		const obj: any = {}
		if (message.viewport !== undefined) {
			obj.viewport = BrowserViewport.toJSON(message.viewport)
		}
		if (message.remoteBrowserHost !== undefined) {
			obj.remoteBrowserHost = message.remoteBrowserHost
		}
		if (message.remoteBrowserEnabled !== undefined) {
			obj.remoteBrowserEnabled = message.remoteBrowserEnabled
		}
		return obj
	},

	create<I extends Exact<DeepPartial<BrowserSettings>, I>>(base?: I): BrowserSettings {
		return BrowserSettings.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<BrowserSettings>, I>>(object: I): BrowserSettings {
		const message = createBaseBrowserSettings()
		message.viewport =
			object.viewport !== undefined && object.viewport !== null ? BrowserViewport.fromPartial(object.viewport) : undefined
		message.remoteBrowserHost = object.remoteBrowserHost ?? undefined
		message.remoteBrowserEnabled = object.remoteBrowserEnabled ?? undefined
		return message
	},
}

function createBaseAutoApprovalActions(): AutoApprovalActions {
	return {
		readFiles: false,
		readFilesExternally: undefined,
		editFiles: false,
		editFilesExternally: undefined,
		executeSafeCommands: undefined,
		executeAllCommands: undefined,
		useBrowser: false,
		useMcp: false,
	}
}

export const AutoApprovalActions: MessageFns<AutoApprovalActions> = {
	encode(message: AutoApprovalActions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.readFiles !== false) {
			writer.uint32(8).bool(message.readFiles)
		}
		if (message.readFilesExternally !== undefined) {
			writer.uint32(16).bool(message.readFilesExternally)
		}
		if (message.editFiles !== false) {
			writer.uint32(24).bool(message.editFiles)
		}
		if (message.editFilesExternally !== undefined) {
			writer.uint32(32).bool(message.editFilesExternally)
		}
		if (message.executeSafeCommands !== undefined) {
			writer.uint32(40).bool(message.executeSafeCommands)
		}
		if (message.executeAllCommands !== undefined) {
			writer.uint32(48).bool(message.executeAllCommands)
		}
		if (message.useBrowser !== false) {
			writer.uint32(56).bool(message.useBrowser)
		}
		if (message.useMcp !== false) {
			writer.uint32(64).bool(message.useMcp)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AutoApprovalActions {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAutoApprovalActions()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.readFiles = reader.bool()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.readFilesExternally = reader.bool()
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.editFiles = reader.bool()
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.editFilesExternally = reader.bool()
					continue
				}
				case 5: {
					if (tag !== 40) {
						break
					}

					message.executeSafeCommands = reader.bool()
					continue
				}
				case 6: {
					if (tag !== 48) {
						break
					}

					message.executeAllCommands = reader.bool()
					continue
				}
				case 7: {
					if (tag !== 56) {
						break
					}

					message.useBrowser = reader.bool()
					continue
				}
				case 8: {
					if (tag !== 64) {
						break
					}

					message.useMcp = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AutoApprovalActions {
		return {
			readFiles: isSet(object.readFiles) ? globalThis.Boolean(object.readFiles) : false,
			readFilesExternally: isSet(object.readFilesExternally) ? globalThis.Boolean(object.readFilesExternally) : undefined,
			editFiles: isSet(object.editFiles) ? globalThis.Boolean(object.editFiles) : false,
			editFilesExternally: isSet(object.editFilesExternally) ? globalThis.Boolean(object.editFilesExternally) : undefined,
			executeSafeCommands: isSet(object.executeSafeCommands) ? globalThis.Boolean(object.executeSafeCommands) : undefined,
			executeAllCommands: isSet(object.executeAllCommands) ? globalThis.Boolean(object.executeAllCommands) : undefined,
			useBrowser: isSet(object.useBrowser) ? globalThis.Boolean(object.useBrowser) : false,
			useMcp: isSet(object.useMcp) ? globalThis.Boolean(object.useMcp) : false,
		}
	},

	toJSON(message: AutoApprovalActions): unknown {
		const obj: any = {}
		if (message.readFiles !== false) {
			obj.readFiles = message.readFiles
		}
		if (message.readFilesExternally !== undefined) {
			obj.readFilesExternally = message.readFilesExternally
		}
		if (message.editFiles !== false) {
			obj.editFiles = message.editFiles
		}
		if (message.editFilesExternally !== undefined) {
			obj.editFilesExternally = message.editFilesExternally
		}
		if (message.executeSafeCommands !== undefined) {
			obj.executeSafeCommands = message.executeSafeCommands
		}
		if (message.executeAllCommands !== undefined) {
			obj.executeAllCommands = message.executeAllCommands
		}
		if (message.useBrowser !== false) {
			obj.useBrowser = message.useBrowser
		}
		if (message.useMcp !== false) {
			obj.useMcp = message.useMcp
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AutoApprovalActions>, I>>(base?: I): AutoApprovalActions {
		return AutoApprovalActions.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AutoApprovalActions>, I>>(object: I): AutoApprovalActions {
		const message = createBaseAutoApprovalActions()
		message.readFiles = object.readFiles ?? false
		message.readFilesExternally = object.readFilesExternally ?? undefined
		message.editFiles = object.editFiles ?? false
		message.editFilesExternally = object.editFilesExternally ?? undefined
		message.executeSafeCommands = object.executeSafeCommands ?? undefined
		message.executeAllCommands = object.executeAllCommands ?? undefined
		message.useBrowser = object.useBrowser ?? false
		message.useMcp = object.useMcp ?? false
		return message
	},
}

function createBaseAutoApprovalSettings(): AutoApprovalSettings {
	return { version: 0, enabled: false, actions: undefined, maxRequests: 0, enableNotifications: false }
}

export const AutoApprovalSettings: MessageFns<AutoApprovalSettings> = {
	encode(message: AutoApprovalSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.version !== 0) {
			writer.uint32(8).int64(message.version)
		}
		if (message.enabled !== false) {
			writer.uint32(16).bool(message.enabled)
		}
		if (message.actions !== undefined) {
			AutoApprovalActions.encode(message.actions, writer.uint32(26).fork()).join()
		}
		if (message.maxRequests !== 0) {
			writer.uint32(32).int32(message.maxRequests)
		}
		if (message.enableNotifications !== false) {
			writer.uint32(40).bool(message.enableNotifications)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AutoApprovalSettings {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAutoApprovalSettings()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.version = longToNumber(reader.int64())
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.enabled = reader.bool()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.actions = AutoApprovalActions.decode(reader, reader.uint32())
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.maxRequests = reader.int32()
					continue
				}
				case 5: {
					if (tag !== 40) {
						break
					}

					message.enableNotifications = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AutoApprovalSettings {
		return {
			version: isSet(object.version) ? globalThis.Number(object.version) : 0,
			enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
			actions: isSet(object.actions) ? AutoApprovalActions.fromJSON(object.actions) : undefined,
			maxRequests: isSet(object.maxRequests) ? globalThis.Number(object.maxRequests) : 0,
			enableNotifications: isSet(object.enableNotifications) ? globalThis.Boolean(object.enableNotifications) : false,
		}
	},

	toJSON(message: AutoApprovalSettings): unknown {
		const obj: any = {}
		if (message.version !== 0) {
			obj.version = Math.round(message.version)
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled
		}
		if (message.actions !== undefined) {
			obj.actions = AutoApprovalActions.toJSON(message.actions)
		}
		if (message.maxRequests !== 0) {
			obj.maxRequests = Math.round(message.maxRequests)
		}
		if (message.enableNotifications !== false) {
			obj.enableNotifications = message.enableNotifications
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AutoApprovalSettings>, I>>(base?: I): AutoApprovalSettings {
		return AutoApprovalSettings.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AutoApprovalSettings>, I>>(object: I): AutoApprovalSettings {
		const message = createBaseAutoApprovalSettings()
		message.version = object.version ?? 0
		message.enabled = object.enabled ?? false
		message.actions =
			object.actions !== undefined && object.actions !== null ? AutoApprovalActions.fromPartial(object.actions) : undefined
		message.maxRequests = object.maxRequests ?? 0
		message.enableNotifications = object.enableNotifications ?? false
		return message
	},
}

function createBaseUserInfo(): UserInfo {
	return { displayName: undefined, email: undefined, photoUrl: undefined }
}

export const UserInfo: MessageFns<UserInfo> = {
	encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.displayName !== undefined) {
			writer.uint32(10).string(message.displayName)
		}
		if (message.email !== undefined) {
			writer.uint32(18).string(message.email)
		}
		if (message.photoUrl !== undefined) {
			writer.uint32(26).string(message.photoUrl)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseUserInfo()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.displayName = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.email = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.photoUrl = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): UserInfo {
		return {
			displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
			email: isSet(object.email) ? globalThis.String(object.email) : undefined,
			photoUrl: isSet(object.photoUrl) ? globalThis.String(object.photoUrl) : undefined,
		}
	},

	toJSON(message: UserInfo): unknown {
		const obj: any = {}
		if (message.displayName !== undefined) {
			obj.displayName = message.displayName
		}
		if (message.email !== undefined) {
			obj.email = message.email
		}
		if (message.photoUrl !== undefined) {
			obj.photoUrl = message.photoUrl
		}
		return obj
	},

	create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
		return UserInfo.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
		const message = createBaseUserInfo()
		message.displayName = object.displayName ?? undefined
		message.email = object.email ?? undefined
		message.photoUrl = object.photoUrl ?? undefined
		return message
	},
}

function createBaseChatContent(): ChatContent {
	return { message: undefined, images: [] }
}

export const ChatContent: MessageFns<ChatContent> = {
	encode(message: ChatContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.message !== undefined) {
			writer.uint32(10).string(message.message)
		}
		for (const v of message.images) {
			writer.uint32(18).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ChatContent {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseChatContent()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.message = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.images.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ChatContent {
		return {
			message: isSet(object.message) ? globalThis.String(object.message) : undefined,
			images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => globalThis.String(e)) : [],
		}
	},

	toJSON(message: ChatContent): unknown {
		const obj: any = {}
		if (message.message !== undefined) {
			obj.message = message.message
		}
		if (message.images?.length) {
			obj.images = message.images
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ChatContent>, I>>(base?: I): ChatContent {
		return ChatContent.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ChatContent>, I>>(object: I): ChatContent {
		const message = createBaseChatContent()
		message.message = object.message ?? undefined
		message.images = object.images?.map((e) => e) || []
		return message
	},
}

function createBaseHistoryItem(): HistoryItem {
	return {
		id: "",
		ts: 0,
		task: "",
		tokensIn: 0,
		tokensOut: 0,
		cacheWrites: undefined,
		cacheReads: undefined,
		totalCost: 0,
		size: undefined,
		shadowGitConfigWorkTree: undefined,
		conversationHistoryDeletedRange: undefined,
	}
}

export const HistoryItem: MessageFns<HistoryItem> = {
	encode(message: HistoryItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.id !== "") {
			writer.uint32(10).string(message.id)
		}
		if (message.ts !== 0) {
			writer.uint32(16).int64(message.ts)
		}
		if (message.task !== "") {
			writer.uint32(26).string(message.task)
		}
		if (message.tokensIn !== 0) {
			writer.uint32(32).int64(message.tokensIn)
		}
		if (message.tokensOut !== 0) {
			writer.uint32(40).int64(message.tokensOut)
		}
		if (message.cacheWrites !== undefined) {
			writer.uint32(48).int64(message.cacheWrites)
		}
		if (message.cacheReads !== undefined) {
			writer.uint32(56).int64(message.cacheReads)
		}
		if (message.totalCost !== 0) {
			writer.uint32(65).double(message.totalCost)
		}
		if (message.size !== undefined) {
			writer.uint32(72).int64(message.size)
		}
		if (message.shadowGitConfigWorkTree !== undefined) {
			writer.uint32(82).string(message.shadowGitConfigWorkTree)
		}
		if (message.conversationHistoryDeletedRange !== undefined) {
			HistoryItem_ConversationHistoryDeletedRange.encode(
				message.conversationHistoryDeletedRange,
				writer.uint32(90).fork(),
			).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): HistoryItem {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseHistoryItem()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.id = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.ts = longToNumber(reader.int64())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.task = reader.string()
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.tokensIn = longToNumber(reader.int64())
					continue
				}
				case 5: {
					if (tag !== 40) {
						break
					}

					message.tokensOut = longToNumber(reader.int64())
					continue
				}
				case 6: {
					if (tag !== 48) {
						break
					}

					message.cacheWrites = longToNumber(reader.int64())
					continue
				}
				case 7: {
					if (tag !== 56) {
						break
					}

					message.cacheReads = longToNumber(reader.int64())
					continue
				}
				case 8: {
					if (tag !== 65) {
						break
					}

					message.totalCost = reader.double()
					continue
				}
				case 9: {
					if (tag !== 72) {
						break
					}

					message.size = longToNumber(reader.int64())
					continue
				}
				case 10: {
					if (tag !== 82) {
						break
					}

					message.shadowGitConfigWorkTree = reader.string()
					continue
				}
				case 11: {
					if (tag !== 90) {
						break
					}

					message.conversationHistoryDeletedRange = HistoryItem_ConversationHistoryDeletedRange.decode(
						reader,
						reader.uint32(),
					)
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): HistoryItem {
		return {
			id: isSet(object.id) ? globalThis.String(object.id) : "",
			ts: isSet(object.ts) ? globalThis.Number(object.ts) : 0,
			task: isSet(object.task) ? globalThis.String(object.task) : "",
			tokensIn: isSet(object.tokensIn) ? globalThis.Number(object.tokensIn) : 0,
			tokensOut: isSet(object.tokensOut) ? globalThis.Number(object.tokensOut) : 0,
			cacheWrites: isSet(object.cacheWrites) ? globalThis.Number(object.cacheWrites) : undefined,
			cacheReads: isSet(object.cacheReads) ? globalThis.Number(object.cacheReads) : undefined,
			totalCost: isSet(object.totalCost) ? globalThis.Number(object.totalCost) : 0,
			size: isSet(object.size) ? globalThis.Number(object.size) : undefined,
			shadowGitConfigWorkTree: isSet(object.shadowGitConfigWorkTree)
				? globalThis.String(object.shadowGitConfigWorkTree)
				: undefined,
			conversationHistoryDeletedRange: isSet(object.conversationHistoryDeletedRange)
				? HistoryItem_ConversationHistoryDeletedRange.fromJSON(object.conversationHistoryDeletedRange)
				: undefined,
		}
	},

	toJSON(message: HistoryItem): unknown {
		const obj: any = {}
		if (message.id !== "") {
			obj.id = message.id
		}
		if (message.ts !== 0) {
			obj.ts = Math.round(message.ts)
		}
		if (message.task !== "") {
			obj.task = message.task
		}
		if (message.tokensIn !== 0) {
			obj.tokensIn = Math.round(message.tokensIn)
		}
		if (message.tokensOut !== 0) {
			obj.tokensOut = Math.round(message.tokensOut)
		}
		if (message.cacheWrites !== undefined) {
			obj.cacheWrites = Math.round(message.cacheWrites)
		}
		if (message.cacheReads !== undefined) {
			obj.cacheReads = Math.round(message.cacheReads)
		}
		if (message.totalCost !== 0) {
			obj.totalCost = message.totalCost
		}
		if (message.size !== undefined) {
			obj.size = Math.round(message.size)
		}
		if (message.shadowGitConfigWorkTree !== undefined) {
			obj.shadowGitConfigWorkTree = message.shadowGitConfigWorkTree
		}
		if (message.conversationHistoryDeletedRange !== undefined) {
			obj.conversationHistoryDeletedRange = HistoryItem_ConversationHistoryDeletedRange.toJSON(
				message.conversationHistoryDeletedRange,
			)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<HistoryItem>, I>>(base?: I): HistoryItem {
		return HistoryItem.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<HistoryItem>, I>>(object: I): HistoryItem {
		const message = createBaseHistoryItem()
		message.id = object.id ?? ""
		message.ts = object.ts ?? 0
		message.task = object.task ?? ""
		message.tokensIn = object.tokensIn ?? 0
		message.tokensOut = object.tokensOut ?? 0
		message.cacheWrites = object.cacheWrites ?? undefined
		message.cacheReads = object.cacheReads ?? undefined
		message.totalCost = object.totalCost ?? 0
		message.size = object.size ?? undefined
		message.shadowGitConfigWorkTree = object.shadowGitConfigWorkTree ?? undefined
		message.conversationHistoryDeletedRange =
			object.conversationHistoryDeletedRange !== undefined && object.conversationHistoryDeletedRange !== null
				? HistoryItem_ConversationHistoryDeletedRange.fromPartial(object.conversationHistoryDeletedRange)
				: undefined
		return message
	},
}

function createBaseHistoryItem_ConversationHistoryDeletedRange(): HistoryItem_ConversationHistoryDeletedRange {
	return { startIndex: 0, endIndex: 0 }
}

export const HistoryItem_ConversationHistoryDeletedRange: MessageFns<HistoryItem_ConversationHistoryDeletedRange> = {
	encode(message: HistoryItem_ConversationHistoryDeletedRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.startIndex !== 0) {
			writer.uint32(8).int64(message.startIndex)
		}
		if (message.endIndex !== 0) {
			writer.uint32(16).int64(message.endIndex)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): HistoryItem_ConversationHistoryDeletedRange {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseHistoryItem_ConversationHistoryDeletedRange()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.startIndex = longToNumber(reader.int64())
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.endIndex = longToNumber(reader.int64())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): HistoryItem_ConversationHistoryDeletedRange {
		return {
			startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
			endIndex: isSet(object.endIndex) ? globalThis.Number(object.endIndex) : 0,
		}
	},

	toJSON(message: HistoryItem_ConversationHistoryDeletedRange): unknown {
		const obj: any = {}
		if (message.startIndex !== 0) {
			obj.startIndex = Math.round(message.startIndex)
		}
		if (message.endIndex !== 0) {
			obj.endIndex = Math.round(message.endIndex)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<HistoryItem_ConversationHistoryDeletedRange>, I>>(
		base?: I,
	): HistoryItem_ConversationHistoryDeletedRange {
		return HistoryItem_ConversationHistoryDeletedRange.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<HistoryItem_ConversationHistoryDeletedRange>, I>>(
		object: I,
	): HistoryItem_ConversationHistoryDeletedRange {
		const message = createBaseHistoryItem_ConversationHistoryDeletedRange()
		message.startIndex = object.startIndex ?? 0
		message.endIndex = object.endIndex ?? 0
		return message
	},
}

function createBaseMcpTool(): McpTool {
	return { name: "", description: undefined, inputSchema: undefined, autoApprove: undefined }
}

export const McpTool: MessageFns<McpTool> = {
	encode(message: McpTool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.name !== "") {
			writer.uint32(10).string(message.name)
		}
		if (message.description !== undefined) {
			writer.uint32(18).string(message.description)
		}
		if (message.inputSchema !== undefined) {
			Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(26).fork()).join()
		}
		if (message.autoApprove !== undefined) {
			writer.uint32(32).bool(message.autoApprove)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): McpTool {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMcpTool()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.name = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.description = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()))
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.autoApprove = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): McpTool {
		return {
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			description: isSet(object.description) ? globalThis.String(object.description) : undefined,
			inputSchema: isObject(object.inputSchema) ? object.inputSchema : undefined,
			autoApprove: isSet(object.autoApprove) ? globalThis.Boolean(object.autoApprove) : undefined,
		}
	},

	toJSON(message: McpTool): unknown {
		const obj: any = {}
		if (message.name !== "") {
			obj.name = message.name
		}
		if (message.description !== undefined) {
			obj.description = message.description
		}
		if (message.inputSchema !== undefined) {
			obj.inputSchema = message.inputSchema
		}
		if (message.autoApprove !== undefined) {
			obj.autoApprove = message.autoApprove
		}
		return obj
	},

	create<I extends Exact<DeepPartial<McpTool>, I>>(base?: I): McpTool {
		return McpTool.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<McpTool>, I>>(object: I): McpTool {
		const message = createBaseMcpTool()
		message.name = object.name ?? ""
		message.description = object.description ?? undefined
		message.inputSchema = object.inputSchema ?? undefined
		message.autoApprove = object.autoApprove ?? undefined
		return message
	},
}

function createBaseMcpResource(): McpResource {
	return { uri: "", name: "", mimeType: undefined, description: undefined }
}

export const McpResource: MessageFns<McpResource> = {
	encode(message: McpResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.uri !== "") {
			writer.uint32(10).string(message.uri)
		}
		if (message.name !== "") {
			writer.uint32(18).string(message.name)
		}
		if (message.mimeType !== undefined) {
			writer.uint32(26).string(message.mimeType)
		}
		if (message.description !== undefined) {
			writer.uint32(34).string(message.description)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): McpResource {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMcpResource()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.uri = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.name = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.mimeType = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.description = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): McpResource {
		return {
			uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : undefined,
			description: isSet(object.description) ? globalThis.String(object.description) : undefined,
		}
	},

	toJSON(message: McpResource): unknown {
		const obj: any = {}
		if (message.uri !== "") {
			obj.uri = message.uri
		}
		if (message.name !== "") {
			obj.name = message.name
		}
		if (message.mimeType !== undefined) {
			obj.mimeType = message.mimeType
		}
		if (message.description !== undefined) {
			obj.description = message.description
		}
		return obj
	},

	create<I extends Exact<DeepPartial<McpResource>, I>>(base?: I): McpResource {
		return McpResource.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<McpResource>, I>>(object: I): McpResource {
		const message = createBaseMcpResource()
		message.uri = object.uri ?? ""
		message.name = object.name ?? ""
		message.mimeType = object.mimeType ?? undefined
		message.description = object.description ?? undefined
		return message
	},
}

function createBaseMcpResourceTemplate(): McpResourceTemplate {
	return { uriTemplate: "", name: "", description: undefined, mimeType: undefined }
}

export const McpResourceTemplate: MessageFns<McpResourceTemplate> = {
	encode(message: McpResourceTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.uriTemplate !== "") {
			writer.uint32(10).string(message.uriTemplate)
		}
		if (message.name !== "") {
			writer.uint32(18).string(message.name)
		}
		if (message.description !== undefined) {
			writer.uint32(26).string(message.description)
		}
		if (message.mimeType !== undefined) {
			writer.uint32(34).string(message.mimeType)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): McpResourceTemplate {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMcpResourceTemplate()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.uriTemplate = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.name = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.description = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.mimeType = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): McpResourceTemplate {
		return {
			uriTemplate: isSet(object.uriTemplate) ? globalThis.String(object.uriTemplate) : "",
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			description: isSet(object.description) ? globalThis.String(object.description) : undefined,
			mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : undefined,
		}
	},

	toJSON(message: McpResourceTemplate): unknown {
		const obj: any = {}
		if (message.uriTemplate !== "") {
			obj.uriTemplate = message.uriTemplate
		}
		if (message.name !== "") {
			obj.name = message.name
		}
		if (message.description !== undefined) {
			obj.description = message.description
		}
		if (message.mimeType !== undefined) {
			obj.mimeType = message.mimeType
		}
		return obj
	},

	create<I extends Exact<DeepPartial<McpResourceTemplate>, I>>(base?: I): McpResourceTemplate {
		return McpResourceTemplate.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<McpResourceTemplate>, I>>(object: I): McpResourceTemplate {
		const message = createBaseMcpResourceTemplate()
		message.uriTemplate = object.uriTemplate ?? ""
		message.name = object.name ?? ""
		message.description = object.description ?? undefined
		message.mimeType = object.mimeType ?? undefined
		return message
	},
}

function createBaseMcpServer(): McpServer {
	return {
		name: "",
		config: "",
		status: 0,
		error: undefined,
		tools: [],
		resources: [],
		resourceTemplates: [],
		disabled: undefined,
		timeout: undefined,
	}
}

export const McpServer: MessageFns<McpServer> = {
	encode(message: McpServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.name !== "") {
			writer.uint32(10).string(message.name)
		}
		if (message.config !== "") {
			writer.uint32(18).string(message.config)
		}
		if (message.status !== 0) {
			writer.uint32(24).int32(message.status)
		}
		if (message.error !== undefined) {
			writer.uint32(34).string(message.error)
		}
		for (const v of message.tools) {
			McpTool.encode(v!, writer.uint32(42).fork()).join()
		}
		for (const v of message.resources) {
			McpResource.encode(v!, writer.uint32(50).fork()).join()
		}
		for (const v of message.resourceTemplates) {
			McpResourceTemplate.encode(v!, writer.uint32(58).fork()).join()
		}
		if (message.disabled !== undefined) {
			writer.uint32(64).bool(message.disabled)
		}
		if (message.timeout !== undefined) {
			writer.uint32(72).int32(message.timeout)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): McpServer {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMcpServer()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.name = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.config = reader.string()
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.status = reader.int32() as any
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.error = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.tools.push(McpTool.decode(reader, reader.uint32()))
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.resources.push(McpResource.decode(reader, reader.uint32()))
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.resourceTemplates.push(McpResourceTemplate.decode(reader, reader.uint32()))
					continue
				}
				case 8: {
					if (tag !== 64) {
						break
					}

					message.disabled = reader.bool()
					continue
				}
				case 9: {
					if (tag !== 72) {
						break
					}

					message.timeout = reader.int32()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): McpServer {
		return {
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			config: isSet(object.config) ? globalThis.String(object.config) : "",
			status: isSet(object.status) ? mcpServerStatusFromJSON(object.status) : 0,
			error: isSet(object.error) ? globalThis.String(object.error) : undefined,
			tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => McpTool.fromJSON(e)) : [],
			resources: globalThis.Array.isArray(object?.resources)
				? object.resources.map((e: any) => McpResource.fromJSON(e))
				: [],
			resourceTemplates: globalThis.Array.isArray(object?.resourceTemplates)
				? object.resourceTemplates.map((e: any) => McpResourceTemplate.fromJSON(e))
				: [],
			disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : undefined,
			timeout: isSet(object.timeout) ? globalThis.Number(object.timeout) : undefined,
		}
	},

	toJSON(message: McpServer): unknown {
		const obj: any = {}
		if (message.name !== "") {
			obj.name = message.name
		}
		if (message.config !== "") {
			obj.config = message.config
		}
		if (message.status !== 0) {
			obj.status = mcpServerStatusToJSON(message.status)
		}
		if (message.error !== undefined) {
			obj.error = message.error
		}
		if (message.tools?.length) {
			obj.tools = message.tools.map((e) => McpTool.toJSON(e))
		}
		if (message.resources?.length) {
			obj.resources = message.resources.map((e) => McpResource.toJSON(e))
		}
		if (message.resourceTemplates?.length) {
			obj.resourceTemplates = message.resourceTemplates.map((e) => McpResourceTemplate.toJSON(e))
		}
		if (message.disabled !== undefined) {
			obj.disabled = message.disabled
		}
		if (message.timeout !== undefined) {
			obj.timeout = Math.round(message.timeout)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<McpServer>, I>>(base?: I): McpServer {
		return McpServer.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<McpServer>, I>>(object: I): McpServer {
		const message = createBaseMcpServer()
		message.name = object.name ?? ""
		message.config = object.config ?? ""
		message.status = object.status ?? 0
		message.error = object.error ?? undefined
		message.tools = object.tools?.map((e) => McpTool.fromPartial(e)) || []
		message.resources = object.resources?.map((e) => McpResource.fromPartial(e)) || []
		message.resourceTemplates = object.resourceTemplates?.map((e) => McpResourceTemplate.fromPartial(e)) || []
		message.disabled = object.disabled ?? undefined
		message.timeout = object.timeout ?? undefined
		return message
	},
}

function createBaseMcpMarketplaceItem(): McpMarketplaceItem {
	return {
		mcpId: "",
		githubUrl: "",
		name: "",
		author: "",
		description: "",
		codiconIcon: "",
		logoUrl: "",
		category: "",
		tags: [],
		requiresApiKey: false,
		readmeContent: undefined,
		llmsInstallationContent: undefined,
		isRecommended: false,
		githubStars: 0,
		downloadCount: 0,
		createdAt: "",
		updatedAt: "",
		lastGithubSync: "",
	}
}

export const McpMarketplaceItem: MessageFns<McpMarketplaceItem> = {
	encode(message: McpMarketplaceItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mcpId !== "") {
			writer.uint32(10).string(message.mcpId)
		}
		if (message.githubUrl !== "") {
			writer.uint32(18).string(message.githubUrl)
		}
		if (message.name !== "") {
			writer.uint32(26).string(message.name)
		}
		if (message.author !== "") {
			writer.uint32(34).string(message.author)
		}
		if (message.description !== "") {
			writer.uint32(42).string(message.description)
		}
		if (message.codiconIcon !== "") {
			writer.uint32(50).string(message.codiconIcon)
		}
		if (message.logoUrl !== "") {
			writer.uint32(58).string(message.logoUrl)
		}
		if (message.category !== "") {
			writer.uint32(66).string(message.category)
		}
		for (const v of message.tags) {
			writer.uint32(74).string(v!)
		}
		if (message.requiresApiKey !== false) {
			writer.uint32(80).bool(message.requiresApiKey)
		}
		if (message.readmeContent !== undefined) {
			writer.uint32(90).string(message.readmeContent)
		}
		if (message.llmsInstallationContent !== undefined) {
			writer.uint32(98).string(message.llmsInstallationContent)
		}
		if (message.isRecommended !== false) {
			writer.uint32(104).bool(message.isRecommended)
		}
		if (message.githubStars !== 0) {
			writer.uint32(112).int64(message.githubStars)
		}
		if (message.downloadCount !== 0) {
			writer.uint32(120).int64(message.downloadCount)
		}
		if (message.createdAt !== "") {
			writer.uint32(130).string(message.createdAt)
		}
		if (message.updatedAt !== "") {
			writer.uint32(138).string(message.updatedAt)
		}
		if (message.lastGithubSync !== "") {
			writer.uint32(146).string(message.lastGithubSync)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): McpMarketplaceItem {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMcpMarketplaceItem()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.mcpId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.githubUrl = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.name = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.author = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.description = reader.string()
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.codiconIcon = reader.string()
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.logoUrl = reader.string()
					continue
				}
				case 8: {
					if (tag !== 66) {
						break
					}

					message.category = reader.string()
					continue
				}
				case 9: {
					if (tag !== 74) {
						break
					}

					message.tags.push(reader.string())
					continue
				}
				case 10: {
					if (tag !== 80) {
						break
					}

					message.requiresApiKey = reader.bool()
					continue
				}
				case 11: {
					if (tag !== 90) {
						break
					}

					message.readmeContent = reader.string()
					continue
				}
				case 12: {
					if (tag !== 98) {
						break
					}

					message.llmsInstallationContent = reader.string()
					continue
				}
				case 13: {
					if (tag !== 104) {
						break
					}

					message.isRecommended = reader.bool()
					continue
				}
				case 14: {
					if (tag !== 112) {
						break
					}

					message.githubStars = longToNumber(reader.int64())
					continue
				}
				case 15: {
					if (tag !== 120) {
						break
					}

					message.downloadCount = longToNumber(reader.int64())
					continue
				}
				case 16: {
					if (tag !== 130) {
						break
					}

					message.createdAt = reader.string()
					continue
				}
				case 17: {
					if (tag !== 138) {
						break
					}

					message.updatedAt = reader.string()
					continue
				}
				case 18: {
					if (tag !== 146) {
						break
					}

					message.lastGithubSync = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): McpMarketplaceItem {
		return {
			mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "",
			githubUrl: isSet(object.githubUrl) ? globalThis.String(object.githubUrl) : "",
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			author: isSet(object.author) ? globalThis.String(object.author) : "",
			description: isSet(object.description) ? globalThis.String(object.description) : "",
			codiconIcon: isSet(object.codiconIcon) ? globalThis.String(object.codiconIcon) : "",
			logoUrl: isSet(object.logoUrl) ? globalThis.String(object.logoUrl) : "",
			category: isSet(object.category) ? globalThis.String(object.category) : "",
			tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
			requiresApiKey: isSet(object.requiresApiKey) ? globalThis.Boolean(object.requiresApiKey) : false,
			readmeContent: isSet(object.readmeContent) ? globalThis.String(object.readmeContent) : undefined,
			llmsInstallationContent: isSet(object.llmsInstallationContent)
				? globalThis.String(object.llmsInstallationContent)
				: undefined,
			isRecommended: isSet(object.isRecommended) ? globalThis.Boolean(object.isRecommended) : false,
			githubStars: isSet(object.githubStars) ? globalThis.Number(object.githubStars) : 0,
			downloadCount: isSet(object.downloadCount) ? globalThis.Number(object.downloadCount) : 0,
			createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
			updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
			lastGithubSync: isSet(object.lastGithubSync) ? globalThis.String(object.lastGithubSync) : "",
		}
	},

	toJSON(message: McpMarketplaceItem): unknown {
		const obj: any = {}
		if (message.mcpId !== "") {
			obj.mcpId = message.mcpId
		}
		if (message.githubUrl !== "") {
			obj.githubUrl = message.githubUrl
		}
		if (message.name !== "") {
			obj.name = message.name
		}
		if (message.author !== "") {
			obj.author = message.author
		}
		if (message.description !== "") {
			obj.description = message.description
		}
		if (message.codiconIcon !== "") {
			obj.codiconIcon = message.codiconIcon
		}
		if (message.logoUrl !== "") {
			obj.logoUrl = message.logoUrl
		}
		if (message.category !== "") {
			obj.category = message.category
		}
		if (message.tags?.length) {
			obj.tags = message.tags
		}
		if (message.requiresApiKey !== false) {
			obj.requiresApiKey = message.requiresApiKey
		}
		if (message.readmeContent !== undefined) {
			obj.readmeContent = message.readmeContent
		}
		if (message.llmsInstallationContent !== undefined) {
			obj.llmsInstallationContent = message.llmsInstallationContent
		}
		if (message.isRecommended !== false) {
			obj.isRecommended = message.isRecommended
		}
		if (message.githubStars !== 0) {
			obj.githubStars = Math.round(message.githubStars)
		}
		if (message.downloadCount !== 0) {
			obj.downloadCount = Math.round(message.downloadCount)
		}
		if (message.createdAt !== "") {
			obj.createdAt = message.createdAt
		}
		if (message.updatedAt !== "") {
			obj.updatedAt = message.updatedAt
		}
		if (message.lastGithubSync !== "") {
			obj.lastGithubSync = message.lastGithubSync
		}
		return obj
	},

	create<I extends Exact<DeepPartial<McpMarketplaceItem>, I>>(base?: I): McpMarketplaceItem {
		return McpMarketplaceItem.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<McpMarketplaceItem>, I>>(object: I): McpMarketplaceItem {
		const message = createBaseMcpMarketplaceItem()
		message.mcpId = object.mcpId ?? ""
		message.githubUrl = object.githubUrl ?? ""
		message.name = object.name ?? ""
		message.author = object.author ?? ""
		message.description = object.description ?? ""
		message.codiconIcon = object.codiconIcon ?? ""
		message.logoUrl = object.logoUrl ?? ""
		message.category = object.category ?? ""
		message.tags = object.tags?.map((e) => e) || []
		message.requiresApiKey = object.requiresApiKey ?? false
		message.readmeContent = object.readmeContent ?? undefined
		message.llmsInstallationContent = object.llmsInstallationContent ?? undefined
		message.isRecommended = object.isRecommended ?? false
		message.githubStars = object.githubStars ?? 0
		message.downloadCount = object.downloadCount ?? 0
		message.createdAt = object.createdAt ?? ""
		message.updatedAt = object.updatedAt ?? ""
		message.lastGithubSync = object.lastGithubSync ?? ""
		return message
	},
}

function createBaseMcpMarketplaceCatalog(): McpMarketplaceCatalog {
	return { items: [] }
}

export const McpMarketplaceCatalog: MessageFns<McpMarketplaceCatalog> = {
	encode(message: McpMarketplaceCatalog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.items) {
			McpMarketplaceItem.encode(v!, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): McpMarketplaceCatalog {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMcpMarketplaceCatalog()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.items.push(McpMarketplaceItem.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): McpMarketplaceCatalog {
		return {
			items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => McpMarketplaceItem.fromJSON(e)) : [],
		}
	},

	toJSON(message: McpMarketplaceCatalog): unknown {
		const obj: any = {}
		if (message.items?.length) {
			obj.items = message.items.map((e) => McpMarketplaceItem.toJSON(e))
		}
		return obj
	},

	create<I extends Exact<DeepPartial<McpMarketplaceCatalog>, I>>(base?: I): McpMarketplaceCatalog {
		return McpMarketplaceCatalog.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<McpMarketplaceCatalog>, I>>(object: I): McpMarketplaceCatalog {
		const message = createBaseMcpMarketplaceCatalog()
		message.items = object.items?.map((e) => McpMarketplaceItem.fromPartial(e)) || []
		return message
	},
}

function createBaseMcpDownloadResponse(): McpDownloadResponse {
	return {
		mcpId: "",
		githubUrl: "",
		name: "",
		author: "",
		description: "",
		readmeContent: "",
		llmsInstallationContent: "",
		requiresApiKey: false,
	}
}

export const McpDownloadResponse: MessageFns<McpDownloadResponse> = {
	encode(message: McpDownloadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mcpId !== "") {
			writer.uint32(10).string(message.mcpId)
		}
		if (message.githubUrl !== "") {
			writer.uint32(18).string(message.githubUrl)
		}
		if (message.name !== "") {
			writer.uint32(26).string(message.name)
		}
		if (message.author !== "") {
			writer.uint32(34).string(message.author)
		}
		if (message.description !== "") {
			writer.uint32(42).string(message.description)
		}
		if (message.readmeContent !== "") {
			writer.uint32(50).string(message.readmeContent)
		}
		if (message.llmsInstallationContent !== "") {
			writer.uint32(58).string(message.llmsInstallationContent)
		}
		if (message.requiresApiKey !== false) {
			writer.uint32(64).bool(message.requiresApiKey)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): McpDownloadResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMcpDownloadResponse()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.mcpId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.githubUrl = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.name = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.author = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.description = reader.string()
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.readmeContent = reader.string()
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.llmsInstallationContent = reader.string()
					continue
				}
				case 8: {
					if (tag !== 64) {
						break
					}

					message.requiresApiKey = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): McpDownloadResponse {
		return {
			mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "",
			githubUrl: isSet(object.githubUrl) ? globalThis.String(object.githubUrl) : "",
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			author: isSet(object.author) ? globalThis.String(object.author) : "",
			description: isSet(object.description) ? globalThis.String(object.description) : "",
			readmeContent: isSet(object.readmeContent) ? globalThis.String(object.readmeContent) : "",
			llmsInstallationContent: isSet(object.llmsInstallationContent)
				? globalThis.String(object.llmsInstallationContent)
				: "",
			requiresApiKey: isSet(object.requiresApiKey) ? globalThis.Boolean(object.requiresApiKey) : false,
		}
	},

	toJSON(message: McpDownloadResponse): unknown {
		const obj: any = {}
		if (message.mcpId !== "") {
			obj.mcpId = message.mcpId
		}
		if (message.githubUrl !== "") {
			obj.githubUrl = message.githubUrl
		}
		if (message.name !== "") {
			obj.name = message.name
		}
		if (message.author !== "") {
			obj.author = message.author
		}
		if (message.description !== "") {
			obj.description = message.description
		}
		if (message.readmeContent !== "") {
			obj.readmeContent = message.readmeContent
		}
		if (message.llmsInstallationContent !== "") {
			obj.llmsInstallationContent = message.llmsInstallationContent
		}
		if (message.requiresApiKey !== false) {
			obj.requiresApiKey = message.requiresApiKey
		}
		return obj
	},

	create<I extends Exact<DeepPartial<McpDownloadResponse>, I>>(base?: I): McpDownloadResponse {
		return McpDownloadResponse.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<McpDownloadResponse>, I>>(object: I): McpDownloadResponse {
		const message = createBaseMcpDownloadResponse()
		message.mcpId = object.mcpId ?? ""
		message.githubUrl = object.githubUrl ?? ""
		message.name = object.name ?? ""
		message.author = object.author ?? ""
		message.description = object.description ?? ""
		message.readmeContent = object.readmeContent ?? ""
		message.llmsInstallationContent = object.llmsInstallationContent ?? ""
		message.requiresApiKey = object.requiresApiKey ?? false
		return message
	},
}

function createBaseClineRulesToggles(): ClineRulesToggles {
	return { toggles: {} }
}

export const ClineRulesToggles: MessageFns<ClineRulesToggles> = {
	encode(message: ClineRulesToggles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		Object.entries(message.toggles).forEach(([key, value]) => {
			ClineRulesToggles_TogglesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join()
		})
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ClineRulesToggles {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseClineRulesToggles()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					const entry1 = ClineRulesToggles_TogglesEntry.decode(reader, reader.uint32())
					if (entry1.value !== undefined) {
						message.toggles[entry1.key] = entry1.value
					}
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ClineRulesToggles {
		return {
			toggles: isObject(object.toggles)
				? Object.entries(object.toggles).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
						acc[key] = Boolean(value)
						return acc
					}, {})
				: {},
		}
	},

	toJSON(message: ClineRulesToggles): unknown {
		const obj: any = {}
		if (message.toggles) {
			const entries = Object.entries(message.toggles)
			if (entries.length > 0) {
				obj.toggles = {}
				entries.forEach(([k, v]) => {
					obj.toggles[k] = v
				})
			}
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ClineRulesToggles>, I>>(base?: I): ClineRulesToggles {
		return ClineRulesToggles.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ClineRulesToggles>, I>>(object: I): ClineRulesToggles {
		const message = createBaseClineRulesToggles()
		message.toggles = Object.entries(object.toggles ?? {}).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
			if (value !== undefined) {
				acc[key] = globalThis.Boolean(value)
			}
			return acc
		}, {})
		return message
	},
}

function createBaseClineRulesToggles_TogglesEntry(): ClineRulesToggles_TogglesEntry {
	return { key: "", value: false }
}

export const ClineRulesToggles_TogglesEntry: MessageFns<ClineRulesToggles_TogglesEntry> = {
	encode(message: ClineRulesToggles_TogglesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.key !== "") {
			writer.uint32(10).string(message.key)
		}
		if (message.value !== false) {
			writer.uint32(16).bool(message.value)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ClineRulesToggles_TogglesEntry {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseClineRulesToggles_TogglesEntry()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.key = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.value = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ClineRulesToggles_TogglesEntry {
		return {
			key: isSet(object.key) ? globalThis.String(object.key) : "",
			value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
		}
	},

	toJSON(message: ClineRulesToggles_TogglesEntry): unknown {
		const obj: any = {}
		if (message.key !== "") {
			obj.key = message.key
		}
		if (message.value !== false) {
			obj.value = message.value
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ClineRulesToggles_TogglesEntry>, I>>(base?: I): ClineRulesToggles_TogglesEntry {
		return ClineRulesToggles_TogglesEntry.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ClineRulesToggles_TogglesEntry>, I>>(object: I): ClineRulesToggles_TogglesEntry {
		const message = createBaseClineRulesToggles_TogglesEntry()
		message.key = object.key ?? ""
		message.value = object.value ?? false
		return message
	},
}

function createBaseGitCommit(): GitCommit {
	return { hash: "", shortHash: "", subject: "", author: "", date: "" }
}

export const GitCommit: MessageFns<GitCommit> = {
	encode(message: GitCommit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.hash !== "") {
			writer.uint32(10).string(message.hash)
		}
		if (message.shortHash !== "") {
			writer.uint32(18).string(message.shortHash)
		}
		if (message.subject !== "") {
			writer.uint32(26).string(message.subject)
		}
		if (message.author !== "") {
			writer.uint32(34).string(message.author)
		}
		if (message.date !== "") {
			writer.uint32(42).string(message.date)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GitCommit {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseGitCommit()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.hash = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.shortHash = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.subject = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.author = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.date = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): GitCommit {
		return {
			hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
			shortHash: isSet(object.shortHash) ? globalThis.String(object.shortHash) : "",
			subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
			author: isSet(object.author) ? globalThis.String(object.author) : "",
			date: isSet(object.date) ? globalThis.String(object.date) : "",
		}
	},

	toJSON(message: GitCommit): unknown {
		const obj: any = {}
		if (message.hash !== "") {
			obj.hash = message.hash
		}
		if (message.shortHash !== "") {
			obj.shortHash = message.shortHash
		}
		if (message.subject !== "") {
			obj.subject = message.subject
		}
		if (message.author !== "") {
			obj.author = message.author
		}
		if (message.date !== "") {
			obj.date = message.date
		}
		return obj
	},

	create<I extends Exact<DeepPartial<GitCommit>, I>>(base?: I): GitCommit {
		return GitCommit.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<GitCommit>, I>>(object: I): GitCommit {
		const message = createBaseGitCommit()
		message.hash = object.hash ?? ""
		message.shortHash = object.shortHash ?? ""
		message.subject = object.subject ?? ""
		message.author = object.author ?? ""
		message.date = object.date ?? ""
		return message
	},
}

function createBaseBalanceResponse(): BalanceResponse {
	return { currentBalance: 0 }
}

export const BalanceResponse: MessageFns<BalanceResponse> = {
	encode(message: BalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.currentBalance !== 0) {
			writer.uint32(9).double(message.currentBalance)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BalanceResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseBalanceResponse()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 9) {
						break
					}

					message.currentBalance = reader.double()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): BalanceResponse {
		return { currentBalance: isSet(object.currentBalance) ? globalThis.Number(object.currentBalance) : 0 }
	},

	toJSON(message: BalanceResponse): unknown {
		const obj: any = {}
		if (message.currentBalance !== 0) {
			obj.currentBalance = message.currentBalance
		}
		return obj
	},

	create<I extends Exact<DeepPartial<BalanceResponse>, I>>(base?: I): BalanceResponse {
		return BalanceResponse.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<BalanceResponse>, I>>(object: I): BalanceResponse {
		const message = createBaseBalanceResponse()
		message.currentBalance = object.currentBalance ?? 0
		return message
	},
}

function createBaseUsageTransaction(): UsageTransaction {
	return { spentAt: "", credits: "", modelProvider: "", model: "", promptTokens: "", completionTokens: "" }
}

export const UsageTransaction: MessageFns<UsageTransaction> = {
	encode(message: UsageTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.spentAt !== "") {
			writer.uint32(10).string(message.spentAt)
		}
		if (message.credits !== "") {
			writer.uint32(18).string(message.credits)
		}
		if (message.modelProvider !== "") {
			writer.uint32(26).string(message.modelProvider)
		}
		if (message.model !== "") {
			writer.uint32(34).string(message.model)
		}
		if (message.promptTokens !== "") {
			writer.uint32(42).string(message.promptTokens)
		}
		if (message.completionTokens !== "") {
			writer.uint32(50).string(message.completionTokens)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UsageTransaction {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseUsageTransaction()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.spentAt = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.credits = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.modelProvider = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.model = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.promptTokens = reader.string()
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.completionTokens = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): UsageTransaction {
		return {
			spentAt: isSet(object.spentAt) ? globalThis.String(object.spentAt) : "",
			credits: isSet(object.credits) ? globalThis.String(object.credits) : "",
			modelProvider: isSet(object.modelProvider) ? globalThis.String(object.modelProvider) : "",
			model: isSet(object.model) ? globalThis.String(object.model) : "",
			promptTokens: isSet(object.promptTokens) ? globalThis.String(object.promptTokens) : "",
			completionTokens: isSet(object.completionTokens) ? globalThis.String(object.completionTokens) : "",
		}
	},

	toJSON(message: UsageTransaction): unknown {
		const obj: any = {}
		if (message.spentAt !== "") {
			obj.spentAt = message.spentAt
		}
		if (message.credits !== "") {
			obj.credits = message.credits
		}
		if (message.modelProvider !== "") {
			obj.modelProvider = message.modelProvider
		}
		if (message.model !== "") {
			obj.model = message.model
		}
		if (message.promptTokens !== "") {
			obj.promptTokens = message.promptTokens
		}
		if (message.completionTokens !== "") {
			obj.completionTokens = message.completionTokens
		}
		return obj
	},

	create<I extends Exact<DeepPartial<UsageTransaction>, I>>(base?: I): UsageTransaction {
		return UsageTransaction.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<UsageTransaction>, I>>(object: I): UsageTransaction {
		const message = createBaseUsageTransaction()
		message.spentAt = object.spentAt ?? ""
		message.credits = object.credits ?? ""
		message.modelProvider = object.modelProvider ?? ""
		message.model = object.model ?? ""
		message.promptTokens = object.promptTokens ?? ""
		message.completionTokens = object.completionTokens ?? ""
		return message
	},
}

function createBasePaymentTransaction(): PaymentTransaction {
	return { paidAt: "", amountCents: "", credits: "" }
}

export const PaymentTransaction: MessageFns<PaymentTransaction> = {
	encode(message: PaymentTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.paidAt !== "") {
			writer.uint32(10).string(message.paidAt)
		}
		if (message.amountCents !== "") {
			writer.uint32(18).string(message.amountCents)
		}
		if (message.credits !== "") {
			writer.uint32(26).string(message.credits)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): PaymentTransaction {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBasePaymentTransaction()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.paidAt = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.amountCents = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.credits = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): PaymentTransaction {
		return {
			paidAt: isSet(object.paidAt) ? globalThis.String(object.paidAt) : "",
			amountCents: isSet(object.amountCents) ? globalThis.String(object.amountCents) : "",
			credits: isSet(object.credits) ? globalThis.String(object.credits) : "",
		}
	},

	toJSON(message: PaymentTransaction): unknown {
		const obj: any = {}
		if (message.paidAt !== "") {
			obj.paidAt = message.paidAt
		}
		if (message.amountCents !== "") {
			obj.amountCents = message.amountCents
		}
		if (message.credits !== "") {
			obj.credits = message.credits
		}
		return obj
	},

	create<I extends Exact<DeepPartial<PaymentTransaction>, I>>(base?: I): PaymentTransaction {
		return PaymentTransaction.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<PaymentTransaction>, I>>(object: I): PaymentTransaction {
		const message = createBasePaymentTransaction()
		message.paidAt = object.paidAt ?? ""
		message.amountCents = object.amountCents ?? ""
		message.credits = object.credits ?? ""
		return message
	},
}

function createBaseRelativePathsResponsePayload(): RelativePathsResponsePayload {
	return { paths: [] }
}

export const RelativePathsResponsePayload: MessageFns<RelativePathsResponsePayload> = {
	encode(message: RelativePathsResponsePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.paths) {
			StringValue.encode({ value: v!! }, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RelativePathsResponsePayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseRelativePathsResponsePayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.paths.push(StringValue.decode(reader, reader.uint32()).value)
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): RelativePathsResponsePayload {
		return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => String(e)) : [] }
	},

	toJSON(message: RelativePathsResponsePayload): unknown {
		const obj: any = {}
		if (message.paths?.length) {
			obj.paths = message.paths
		}
		return obj
	},

	create<I extends Exact<DeepPartial<RelativePathsResponsePayload>, I>>(base?: I): RelativePathsResponsePayload {
		return RelativePathsResponsePayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<RelativePathsResponsePayload>, I>>(object: I): RelativePathsResponsePayload {
		const message = createBaseRelativePathsResponsePayload()
		message.paths = object.paths?.map((e) => e) || []
		return message
	},
}

function createBaseAskFollowupPayload(): AskFollowupPayload {
	return { question: "", options: [], selected: undefined }
}

export const AskFollowupPayload: MessageFns<AskFollowupPayload> = {
	encode(message: AskFollowupPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.question !== "") {
			writer.uint32(10).string(message.question)
		}
		for (const v of message.options) {
			writer.uint32(18).string(v!)
		}
		if (message.selected !== undefined) {
			writer.uint32(26).string(message.selected)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskFollowupPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskFollowupPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.question = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.options.push(reader.string())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.selected = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskFollowupPayload {
		return {
			question: isSet(object.question) ? globalThis.String(object.question) : "",
			options: globalThis.Array.isArray(object?.options) ? object.options.map((e: any) => globalThis.String(e)) : [],
			selected: isSet(object.selected) ? globalThis.String(object.selected) : undefined,
		}
	},

	toJSON(message: AskFollowupPayload): unknown {
		const obj: any = {}
		if (message.question !== "") {
			obj.question = message.question
		}
		if (message.options?.length) {
			obj.options = message.options
		}
		if (message.selected !== undefined) {
			obj.selected = message.selected
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskFollowupPayload>, I>>(base?: I): AskFollowupPayload {
		return AskFollowupPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskFollowupPayload>, I>>(object: I): AskFollowupPayload {
		const message = createBaseAskFollowupPayload()
		message.question = object.question ?? ""
		message.options = object.options?.map((e) => e) || []
		message.selected = object.selected ?? undefined
		return message
	},
}

function createBaseAskPlanModeRespondPayload(): AskPlanModeRespondPayload {
	return { response: "", options: [], selected: undefined }
}

export const AskPlanModeRespondPayload: MessageFns<AskPlanModeRespondPayload> = {
	encode(message: AskPlanModeRespondPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.response !== "") {
			writer.uint32(10).string(message.response)
		}
		for (const v of message.options) {
			writer.uint32(18).string(v!)
		}
		if (message.selected !== undefined) {
			writer.uint32(26).string(message.selected)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskPlanModeRespondPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskPlanModeRespondPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.response = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.options.push(reader.string())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.selected = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskPlanModeRespondPayload {
		return {
			response: isSet(object.response) ? globalThis.String(object.response) : "",
			options: globalThis.Array.isArray(object?.options) ? object.options.map((e: any) => globalThis.String(e)) : [],
			selected: isSet(object.selected) ? globalThis.String(object.selected) : undefined,
		}
	},

	toJSON(message: AskPlanModeRespondPayload): unknown {
		const obj: any = {}
		if (message.response !== "") {
			obj.response = message.response
		}
		if (message.options?.length) {
			obj.options = message.options
		}
		if (message.selected !== undefined) {
			obj.selected = message.selected
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskPlanModeRespondPayload>, I>>(base?: I): AskPlanModeRespondPayload {
		return AskPlanModeRespondPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskPlanModeRespondPayload>, I>>(object: I): AskPlanModeRespondPayload {
		const message = createBaseAskPlanModeRespondPayload()
		message.response = object.response ?? ""
		message.options = object.options?.map((e) => e) || []
		message.selected = object.selected ?? undefined
		return message
	},
}

function createBaseAskCommandPayload(): AskCommandPayload {
	return { commandText: "" }
}

export const AskCommandPayload: MessageFns<AskCommandPayload> = {
	encode(message: AskCommandPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.commandText !== "") {
			writer.uint32(10).string(message.commandText)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskCommandPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskCommandPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.commandText = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskCommandPayload {
		return { commandText: isSet(object.commandText) ? globalThis.String(object.commandText) : "" }
	},

	toJSON(message: AskCommandPayload): unknown {
		const obj: any = {}
		if (message.commandText !== "") {
			obj.commandText = message.commandText
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskCommandPayload>, I>>(base?: I): AskCommandPayload {
		return AskCommandPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskCommandPayload>, I>>(object: I): AskCommandPayload {
		const message = createBaseAskCommandPayload()
		message.commandText = object.commandText ?? ""
		return message
	},
}

function createBaseAskCommandOutputPayload(): AskCommandOutputPayload {
	return { outputText: "" }
}

export const AskCommandOutputPayload: MessageFns<AskCommandOutputPayload> = {
	encode(message: AskCommandOutputPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.outputText !== "") {
			writer.uint32(10).string(message.outputText)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskCommandOutputPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskCommandOutputPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.outputText = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskCommandOutputPayload {
		return { outputText: isSet(object.outputText) ? globalThis.String(object.outputText) : "" }
	},

	toJSON(message: AskCommandOutputPayload): unknown {
		const obj: any = {}
		if (message.outputText !== "") {
			obj.outputText = message.outputText
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskCommandOutputPayload>, I>>(base?: I): AskCommandOutputPayload {
		return AskCommandOutputPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskCommandOutputPayload>, I>>(object: I): AskCommandOutputPayload {
		const message = createBaseAskCommandOutputPayload()
		message.outputText = object.outputText ?? ""
		return message
	},
}

function createBaseAskCompletionResultPayload(): AskCompletionResultPayload {
	return { resultText: "" }
}

export const AskCompletionResultPayload: MessageFns<AskCompletionResultPayload> = {
	encode(message: AskCompletionResultPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.resultText !== "") {
			writer.uint32(10).string(message.resultText)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskCompletionResultPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskCompletionResultPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.resultText = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskCompletionResultPayload {
		return { resultText: isSet(object.resultText) ? globalThis.String(object.resultText) : "" }
	},

	toJSON(message: AskCompletionResultPayload): unknown {
		const obj: any = {}
		if (message.resultText !== "") {
			obj.resultText = message.resultText
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskCompletionResultPayload>, I>>(base?: I): AskCompletionResultPayload {
		return AskCompletionResultPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskCompletionResultPayload>, I>>(object: I): AskCompletionResultPayload {
		const message = createBaseAskCompletionResultPayload()
		message.resultText = object.resultText ?? ""
		return message
	},
}

function createBaseAskToolPayload(): AskToolPayload {
	return { toolDetails: undefined }
}

export const AskToolPayload: MessageFns<AskToolPayload> = {
	encode(message: AskToolPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.toolDetails !== undefined) {
			SayToolPayload.encode(message.toolDetails, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskToolPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskToolPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.toolDetails = SayToolPayload.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskToolPayload {
		return { toolDetails: isSet(object.toolDetails) ? SayToolPayload.fromJSON(object.toolDetails) : undefined }
	},

	toJSON(message: AskToolPayload): unknown {
		const obj: any = {}
		if (message.toolDetails !== undefined) {
			obj.toolDetails = SayToolPayload.toJSON(message.toolDetails)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskToolPayload>, I>>(base?: I): AskToolPayload {
		return AskToolPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskToolPayload>, I>>(object: I): AskToolPayload {
		const message = createBaseAskToolPayload()
		message.toolDetails =
			object.toolDetails !== undefined && object.toolDetails !== null
				? SayToolPayload.fromPartial(object.toolDetails)
				: undefined
		return message
	},
}

function createBaseAskApiReqFailedPayload(): AskApiReqFailedPayload {
	return { errorMessage: "" }
}

export const AskApiReqFailedPayload: MessageFns<AskApiReqFailedPayload> = {
	encode(message: AskApiReqFailedPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.errorMessage !== "") {
			writer.uint32(10).string(message.errorMessage)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskApiReqFailedPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskApiReqFailedPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.errorMessage = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskApiReqFailedPayload {
		return { errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "" }
	},

	toJSON(message: AskApiReqFailedPayload): unknown {
		const obj: any = {}
		if (message.errorMessage !== "") {
			obj.errorMessage = message.errorMessage
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskApiReqFailedPayload>, I>>(base?: I): AskApiReqFailedPayload {
		return AskApiReqFailedPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskApiReqFailedPayload>, I>>(object: I): AskApiReqFailedPayload {
		const message = createBaseAskApiReqFailedPayload()
		message.errorMessage = object.errorMessage ?? ""
		return message
	},
}

function createBaseAskResumeTaskPayload(): AskResumeTaskPayload {
	return { taskId: "" }
}

export const AskResumeTaskPayload: MessageFns<AskResumeTaskPayload> = {
	encode(message: AskResumeTaskPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.taskId !== "") {
			writer.uint32(10).string(message.taskId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskResumeTaskPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskResumeTaskPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.taskId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskResumeTaskPayload {
		return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" }
	},

	toJSON(message: AskResumeTaskPayload): unknown {
		const obj: any = {}
		if (message.taskId !== "") {
			obj.taskId = message.taskId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskResumeTaskPayload>, I>>(base?: I): AskResumeTaskPayload {
		return AskResumeTaskPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskResumeTaskPayload>, I>>(object: I): AskResumeTaskPayload {
		const message = createBaseAskResumeTaskPayload()
		message.taskId = object.taskId ?? ""
		return message
	},
}

function createBaseAskResumeCompletedTaskPayload(): AskResumeCompletedTaskPayload {
	return { taskId: "" }
}

export const AskResumeCompletedTaskPayload: MessageFns<AskResumeCompletedTaskPayload> = {
	encode(message: AskResumeCompletedTaskPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.taskId !== "") {
			writer.uint32(10).string(message.taskId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskResumeCompletedTaskPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskResumeCompletedTaskPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.taskId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskResumeCompletedTaskPayload {
		return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" }
	},

	toJSON(message: AskResumeCompletedTaskPayload): unknown {
		const obj: any = {}
		if (message.taskId !== "") {
			obj.taskId = message.taskId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskResumeCompletedTaskPayload>, I>>(base?: I): AskResumeCompletedTaskPayload {
		return AskResumeCompletedTaskPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskResumeCompletedTaskPayload>, I>>(object: I): AskResumeCompletedTaskPayload {
		const message = createBaseAskResumeCompletedTaskPayload()
		message.taskId = object.taskId ?? ""
		return message
	},
}

function createBaseAskMistakeLimitReachedPayload(): AskMistakeLimitReachedPayload {
	return {}
}

export const AskMistakeLimitReachedPayload: MessageFns<AskMistakeLimitReachedPayload> = {
	encode(_: AskMistakeLimitReachedPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskMistakeLimitReachedPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskMistakeLimitReachedPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(_: any): AskMistakeLimitReachedPayload {
		return {}
	},

	toJSON(_: AskMistakeLimitReachedPayload): unknown {
		const obj: any = {}
		return obj
	},

	create<I extends Exact<DeepPartial<AskMistakeLimitReachedPayload>, I>>(base?: I): AskMistakeLimitReachedPayload {
		return AskMistakeLimitReachedPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskMistakeLimitReachedPayload>, I>>(_: I): AskMistakeLimitReachedPayload {
		const message = createBaseAskMistakeLimitReachedPayload()
		return message
	},
}

function createBaseAskAutoApprovalMaxReqReachedPayload(): AskAutoApprovalMaxReqReachedPayload {
	return {}
}

export const AskAutoApprovalMaxReqReachedPayload: MessageFns<AskAutoApprovalMaxReqReachedPayload> = {
	encode(_: AskAutoApprovalMaxReqReachedPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskAutoApprovalMaxReqReachedPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskAutoApprovalMaxReqReachedPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(_: any): AskAutoApprovalMaxReqReachedPayload {
		return {}
	},

	toJSON(_: AskAutoApprovalMaxReqReachedPayload): unknown {
		const obj: any = {}
		return obj
	},

	create<I extends Exact<DeepPartial<AskAutoApprovalMaxReqReachedPayload>, I>>(base?: I): AskAutoApprovalMaxReqReachedPayload {
		return AskAutoApprovalMaxReqReachedPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskAutoApprovalMaxReqReachedPayload>, I>>(_: I): AskAutoApprovalMaxReqReachedPayload {
		const message = createBaseAskAutoApprovalMaxReqReachedPayload()
		return message
	},
}

function createBaseAskBrowserActionLaunchPayload(): AskBrowserActionLaunchPayload {
	return { url: "" }
}

export const AskBrowserActionLaunchPayload: MessageFns<AskBrowserActionLaunchPayload> = {
	encode(message: AskBrowserActionLaunchPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.url !== "") {
			writer.uint32(10).string(message.url)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskBrowserActionLaunchPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskBrowserActionLaunchPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.url = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskBrowserActionLaunchPayload {
		return { url: isSet(object.url) ? globalThis.String(object.url) : "" }
	},

	toJSON(message: AskBrowserActionLaunchPayload): unknown {
		const obj: any = {}
		if (message.url !== "") {
			obj.url = message.url
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskBrowserActionLaunchPayload>, I>>(base?: I): AskBrowserActionLaunchPayload {
		return AskBrowserActionLaunchPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskBrowserActionLaunchPayload>, I>>(object: I): AskBrowserActionLaunchPayload {
		const message = createBaseAskBrowserActionLaunchPayload()
		message.url = object.url ?? ""
		return message
	},
}

function createBaseAskUseMcpServerPayload(): AskUseMcpServerPayload {
	return { serverName: "", type: 0, toolName: undefined, argumentsJson: undefined, uri: undefined }
}

export const AskUseMcpServerPayload: MessageFns<AskUseMcpServerPayload> = {
	encode(message: AskUseMcpServerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.serverName !== "") {
			writer.uint32(10).string(message.serverName)
		}
		if (message.type !== 0) {
			writer.uint32(16).int32(message.type)
		}
		if (message.toolName !== undefined) {
			writer.uint32(26).string(message.toolName)
		}
		if (message.argumentsJson !== undefined) {
			writer.uint32(34).string(message.argumentsJson)
		}
		if (message.uri !== undefined) {
			writer.uint32(42).string(message.uri)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskUseMcpServerPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskUseMcpServerPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.serverName = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.type = reader.int32() as any
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.toolName = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.argumentsJson = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.uri = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskUseMcpServerPayload {
		return {
			serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "",
			type: isSet(object.type) ? askUseMcpServerPayload_McpRequestTypeFromJSON(object.type) : 0,
			toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : undefined,
			argumentsJson: isSet(object.argumentsJson) ? globalThis.String(object.argumentsJson) : undefined,
			uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
		}
	},

	toJSON(message: AskUseMcpServerPayload): unknown {
		const obj: any = {}
		if (message.serverName !== "") {
			obj.serverName = message.serverName
		}
		if (message.type !== 0) {
			obj.type = askUseMcpServerPayload_McpRequestTypeToJSON(message.type)
		}
		if (message.toolName !== undefined) {
			obj.toolName = message.toolName
		}
		if (message.argumentsJson !== undefined) {
			obj.argumentsJson = message.argumentsJson
		}
		if (message.uri !== undefined) {
			obj.uri = message.uri
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskUseMcpServerPayload>, I>>(base?: I): AskUseMcpServerPayload {
		return AskUseMcpServerPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskUseMcpServerPayload>, I>>(object: I): AskUseMcpServerPayload {
		const message = createBaseAskUseMcpServerPayload()
		message.serverName = object.serverName ?? ""
		message.type = object.type ?? 0
		message.toolName = object.toolName ?? undefined
		message.argumentsJson = object.argumentsJson ?? undefined
		message.uri = object.uri ?? undefined
		return message
	},
}

function createBaseAskNewTaskPayload(): AskNewTaskPayload {
	return { context: "" }
}

export const AskNewTaskPayload: MessageFns<AskNewTaskPayload> = {
	encode(message: AskNewTaskPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.context !== "") {
			writer.uint32(10).string(message.context)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskNewTaskPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskNewTaskPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.context = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskNewTaskPayload {
		return { context: isSet(object.context) ? globalThis.String(object.context) : "" }
	},

	toJSON(message: AskNewTaskPayload): unknown {
		const obj: any = {}
		if (message.context !== "") {
			obj.context = message.context
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskNewTaskPayload>, I>>(base?: I): AskNewTaskPayload {
		return AskNewTaskPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskNewTaskPayload>, I>>(object: I): AskNewTaskPayload {
		const message = createBaseAskNewTaskPayload()
		message.context = object.context ?? ""
		return message
	},
}

function createBaseSayTaskPayload(): SayTaskPayload {
	return { taskDescription: "" }
}

export const SayTaskPayload: MessageFns<SayTaskPayload> = {
	encode(message: SayTaskPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.taskDescription !== "") {
			writer.uint32(10).string(message.taskDescription)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayTaskPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayTaskPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.taskDescription = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayTaskPayload {
		return { taskDescription: isSet(object.taskDescription) ? globalThis.String(object.taskDescription) : "" }
	},

	toJSON(message: SayTaskPayload): unknown {
		const obj: any = {}
		if (message.taskDescription !== "") {
			obj.taskDescription = message.taskDescription
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayTaskPayload>, I>>(base?: I): SayTaskPayload {
		return SayTaskPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayTaskPayload>, I>>(object: I): SayTaskPayload {
		const message = createBaseSayTaskPayload()
		message.taskDescription = object.taskDescription ?? ""
		return message
	},
}

function createBaseSayErrorPayload(): SayErrorPayload {
	return { errorMessage: "" }
}

export const SayErrorPayload: MessageFns<SayErrorPayload> = {
	encode(message: SayErrorPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.errorMessage !== "") {
			writer.uint32(10).string(message.errorMessage)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayErrorPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayErrorPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.errorMessage = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayErrorPayload {
		return { errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "" }
	},

	toJSON(message: SayErrorPayload): unknown {
		const obj: any = {}
		if (message.errorMessage !== "") {
			obj.errorMessage = message.errorMessage
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayErrorPayload>, I>>(base?: I): SayErrorPayload {
		return SayErrorPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayErrorPayload>, I>>(object: I): SayErrorPayload {
		const message = createBaseSayErrorPayload()
		message.errorMessage = object.errorMessage ?? ""
		return message
	},
}

function createBaseSayApiReqInfoPayload(): SayApiReqInfoPayload {
	return {
		request: undefined,
		tokensIn: undefined,
		tokensOut: undefined,
		cacheWrites: undefined,
		cacheReads: undefined,
		cost: undefined,
		cancelReason: undefined,
		streamingFailedMessage: undefined,
	}
}

export const SayApiReqInfoPayload: MessageFns<SayApiReqInfoPayload> = {
	encode(message: SayApiReqInfoPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.request !== undefined) {
			writer.uint32(10).string(message.request)
		}
		if (message.tokensIn !== undefined) {
			writer.uint32(16).int64(message.tokensIn)
		}
		if (message.tokensOut !== undefined) {
			writer.uint32(24).int64(message.tokensOut)
		}
		if (message.cacheWrites !== undefined) {
			writer.uint32(32).int64(message.cacheWrites)
		}
		if (message.cacheReads !== undefined) {
			writer.uint32(40).int64(message.cacheReads)
		}
		if (message.cost !== undefined) {
			writer.uint32(49).double(message.cost)
		}
		if (message.cancelReason !== undefined) {
			writer.uint32(56).int32(message.cancelReason)
		}
		if (message.streamingFailedMessage !== undefined) {
			writer.uint32(66).string(message.streamingFailedMessage)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayApiReqInfoPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayApiReqInfoPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.request = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.tokensIn = longToNumber(reader.int64())
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.tokensOut = longToNumber(reader.int64())
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.cacheWrites = longToNumber(reader.int64())
					continue
				}
				case 5: {
					if (tag !== 40) {
						break
					}

					message.cacheReads = longToNumber(reader.int64())
					continue
				}
				case 6: {
					if (tag !== 49) {
						break
					}

					message.cost = reader.double()
					continue
				}
				case 7: {
					if (tag !== 56) {
						break
					}

					message.cancelReason = reader.int32() as any
					continue
				}
				case 8: {
					if (tag !== 66) {
						break
					}

					message.streamingFailedMessage = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayApiReqInfoPayload {
		return {
			request: isSet(object.request) ? globalThis.String(object.request) : undefined,
			tokensIn: isSet(object.tokensIn) ? globalThis.Number(object.tokensIn) : undefined,
			tokensOut: isSet(object.tokensOut) ? globalThis.Number(object.tokensOut) : undefined,
			cacheWrites: isSet(object.cacheWrites) ? globalThis.Number(object.cacheWrites) : undefined,
			cacheReads: isSet(object.cacheReads) ? globalThis.Number(object.cacheReads) : undefined,
			cost: isSet(object.cost) ? globalThis.Number(object.cost) : undefined,
			cancelReason: isSet(object.cancelReason) ? clineApiReqCancelReasonFromJSON(object.cancelReason) : undefined,
			streamingFailedMessage: isSet(object.streamingFailedMessage)
				? globalThis.String(object.streamingFailedMessage)
				: undefined,
		}
	},

	toJSON(message: SayApiReqInfoPayload): unknown {
		const obj: any = {}
		if (message.request !== undefined) {
			obj.request = message.request
		}
		if (message.tokensIn !== undefined) {
			obj.tokensIn = Math.round(message.tokensIn)
		}
		if (message.tokensOut !== undefined) {
			obj.tokensOut = Math.round(message.tokensOut)
		}
		if (message.cacheWrites !== undefined) {
			obj.cacheWrites = Math.round(message.cacheWrites)
		}
		if (message.cacheReads !== undefined) {
			obj.cacheReads = Math.round(message.cacheReads)
		}
		if (message.cost !== undefined) {
			obj.cost = message.cost
		}
		if (message.cancelReason !== undefined) {
			obj.cancelReason = clineApiReqCancelReasonToJSON(message.cancelReason)
		}
		if (message.streamingFailedMessage !== undefined) {
			obj.streamingFailedMessage = message.streamingFailedMessage
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayApiReqInfoPayload>, I>>(base?: I): SayApiReqInfoPayload {
		return SayApiReqInfoPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayApiReqInfoPayload>, I>>(object: I): SayApiReqInfoPayload {
		const message = createBaseSayApiReqInfoPayload()
		message.request = object.request ?? undefined
		message.tokensIn = object.tokensIn ?? undefined
		message.tokensOut = object.tokensOut ?? undefined
		message.cacheWrites = object.cacheWrites ?? undefined
		message.cacheReads = object.cacheReads ?? undefined
		message.cost = object.cost ?? undefined
		message.cancelReason = object.cancelReason ?? undefined
		message.streamingFailedMessage = object.streamingFailedMessage ?? undefined
		return message
	},
}

function createBaseSayTextPayload(): SayTextPayload {
	return { textContent: "" }
}

export const SayTextPayload: MessageFns<SayTextPayload> = {
	encode(message: SayTextPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.textContent !== "") {
			writer.uint32(10).string(message.textContent)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayTextPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayTextPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.textContent = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayTextPayload {
		return { textContent: isSet(object.textContent) ? globalThis.String(object.textContent) : "" }
	},

	toJSON(message: SayTextPayload): unknown {
		const obj: any = {}
		if (message.textContent !== "") {
			obj.textContent = message.textContent
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayTextPayload>, I>>(base?: I): SayTextPayload {
		return SayTextPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayTextPayload>, I>>(object: I): SayTextPayload {
		const message = createBaseSayTextPayload()
		message.textContent = object.textContent ?? ""
		return message
	},
}

function createBaseSayReasoningPayload(): SayReasoningPayload {
	return { reasoningText: "" }
}

export const SayReasoningPayload: MessageFns<SayReasoningPayload> = {
	encode(message: SayReasoningPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.reasoningText !== "") {
			writer.uint32(10).string(message.reasoningText)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayReasoningPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayReasoningPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.reasoningText = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayReasoningPayload {
		return { reasoningText: isSet(object.reasoningText) ? globalThis.String(object.reasoningText) : "" }
	},

	toJSON(message: SayReasoningPayload): unknown {
		const obj: any = {}
		if (message.reasoningText !== "") {
			obj.reasoningText = message.reasoningText
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayReasoningPayload>, I>>(base?: I): SayReasoningPayload {
		return SayReasoningPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayReasoningPayload>, I>>(object: I): SayReasoningPayload {
		const message = createBaseSayReasoningPayload()
		message.reasoningText = object.reasoningText ?? ""
		return message
	},
}

function createBaseSayCompletionResultPayload(): SayCompletionResultPayload {
	return { resultText: "", hasChanges: undefined }
}

export const SayCompletionResultPayload: MessageFns<SayCompletionResultPayload> = {
	encode(message: SayCompletionResultPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.resultText !== "") {
			writer.uint32(10).string(message.resultText)
		}
		if (message.hasChanges !== undefined) {
			writer.uint32(16).bool(message.hasChanges)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayCompletionResultPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayCompletionResultPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.resultText = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.hasChanges = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayCompletionResultPayload {
		return {
			resultText: isSet(object.resultText) ? globalThis.String(object.resultText) : "",
			hasChanges: isSet(object.hasChanges) ? globalThis.Boolean(object.hasChanges) : undefined,
		}
	},

	toJSON(message: SayCompletionResultPayload): unknown {
		const obj: any = {}
		if (message.resultText !== "") {
			obj.resultText = message.resultText
		}
		if (message.hasChanges !== undefined) {
			obj.hasChanges = message.hasChanges
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayCompletionResultPayload>, I>>(base?: I): SayCompletionResultPayload {
		return SayCompletionResultPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayCompletionResultPayload>, I>>(object: I): SayCompletionResultPayload {
		const message = createBaseSayCompletionResultPayload()
		message.resultText = object.resultText ?? ""
		message.hasChanges = object.hasChanges ?? undefined
		return message
	},
}

function createBaseSayUserFeedbackPayload(): SayUserFeedbackPayload {
	return { feedbackText: "" }
}

export const SayUserFeedbackPayload: MessageFns<SayUserFeedbackPayload> = {
	encode(message: SayUserFeedbackPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.feedbackText !== "") {
			writer.uint32(10).string(message.feedbackText)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayUserFeedbackPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayUserFeedbackPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.feedbackText = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayUserFeedbackPayload {
		return { feedbackText: isSet(object.feedbackText) ? globalThis.String(object.feedbackText) : "" }
	},

	toJSON(message: SayUserFeedbackPayload): unknown {
		const obj: any = {}
		if (message.feedbackText !== "") {
			obj.feedbackText = message.feedbackText
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayUserFeedbackPayload>, I>>(base?: I): SayUserFeedbackPayload {
		return SayUserFeedbackPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayUserFeedbackPayload>, I>>(object: I): SayUserFeedbackPayload {
		const message = createBaseSayUserFeedbackPayload()
		message.feedbackText = object.feedbackText ?? ""
		return message
	},
}

function createBaseSayUserFeedbackDiffPayload(): SayUserFeedbackDiffPayload {
	return { diffContent: "" }
}

export const SayUserFeedbackDiffPayload: MessageFns<SayUserFeedbackDiffPayload> = {
	encode(message: SayUserFeedbackDiffPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.diffContent !== "") {
			writer.uint32(10).string(message.diffContent)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayUserFeedbackDiffPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayUserFeedbackDiffPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.diffContent = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayUserFeedbackDiffPayload {
		return { diffContent: isSet(object.diffContent) ? globalThis.String(object.diffContent) : "" }
	},

	toJSON(message: SayUserFeedbackDiffPayload): unknown {
		const obj: any = {}
		if (message.diffContent !== "") {
			obj.diffContent = message.diffContent
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayUserFeedbackDiffPayload>, I>>(base?: I): SayUserFeedbackDiffPayload {
		return SayUserFeedbackDiffPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayUserFeedbackDiffPayload>, I>>(object: I): SayUserFeedbackDiffPayload {
		const message = createBaseSayUserFeedbackDiffPayload()
		message.diffContent = object.diffContent ?? ""
		return message
	},
}

function createBaseSayCommandPayload(): SayCommandPayload {
	return { commandText: "" }
}

export const SayCommandPayload: MessageFns<SayCommandPayload> = {
	encode(message: SayCommandPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.commandText !== "") {
			writer.uint32(10).string(message.commandText)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayCommandPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayCommandPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.commandText = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayCommandPayload {
		return { commandText: isSet(object.commandText) ? globalThis.String(object.commandText) : "" }
	},

	toJSON(message: SayCommandPayload): unknown {
		const obj: any = {}
		if (message.commandText !== "") {
			obj.commandText = message.commandText
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayCommandPayload>, I>>(base?: I): SayCommandPayload {
		return SayCommandPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayCommandPayload>, I>>(object: I): SayCommandPayload {
		const message = createBaseSayCommandPayload()
		message.commandText = object.commandText ?? ""
		return message
	},
}

function createBaseSayCommandOutputPayload(): SayCommandOutputPayload {
	return { outputText: "" }
}

export const SayCommandOutputPayload: MessageFns<SayCommandOutputPayload> = {
	encode(message: SayCommandOutputPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.outputText !== "") {
			writer.uint32(10).string(message.outputText)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayCommandOutputPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayCommandOutputPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.outputText = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayCommandOutputPayload {
		return { outputText: isSet(object.outputText) ? globalThis.String(object.outputText) : "" }
	},

	toJSON(message: SayCommandOutputPayload): unknown {
		const obj: any = {}
		if (message.outputText !== "") {
			obj.outputText = message.outputText
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayCommandOutputPayload>, I>>(base?: I): SayCommandOutputPayload {
		return SayCommandOutputPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayCommandOutputPayload>, I>>(object: I): SayCommandOutputPayload {
		const message = createBaseSayCommandOutputPayload()
		message.outputText = object.outputText ?? ""
		return message
	},
}

function createBaseSayToolPayload(): SayToolPayload {
	return {
		tool: 0,
		path: undefined,
		diff: undefined,
		content: undefined,
		regex: undefined,
		filePattern: undefined,
		operationIsLocatedInWorkspace: undefined,
	}
}

export const SayToolPayload: MessageFns<SayToolPayload> = {
	encode(message: SayToolPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.tool !== 0) {
			writer.uint32(8).int32(message.tool)
		}
		if (message.path !== undefined) {
			writer.uint32(18).string(message.path)
		}
		if (message.diff !== undefined) {
			writer.uint32(26).string(message.diff)
		}
		if (message.content !== undefined) {
			writer.uint32(34).string(message.content)
		}
		if (message.regex !== undefined) {
			writer.uint32(42).string(message.regex)
		}
		if (message.filePattern !== undefined) {
			writer.uint32(50).string(message.filePattern)
		}
		if (message.operationIsLocatedInWorkspace !== undefined) {
			writer.uint32(56).bool(message.operationIsLocatedInWorkspace)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayToolPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayToolPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.tool = reader.int32() as any
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.path = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.diff = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.content = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.regex = reader.string()
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.filePattern = reader.string()
					continue
				}
				case 7: {
					if (tag !== 56) {
						break
					}

					message.operationIsLocatedInWorkspace = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayToolPayload {
		return {
			tool: isSet(object.tool) ? sayToolTypeFromJSON(object.tool) : 0,
			path: isSet(object.path) ? globalThis.String(object.path) : undefined,
			diff: isSet(object.diff) ? globalThis.String(object.diff) : undefined,
			content: isSet(object.content) ? globalThis.String(object.content) : undefined,
			regex: isSet(object.regex) ? globalThis.String(object.regex) : undefined,
			filePattern: isSet(object.filePattern) ? globalThis.String(object.filePattern) : undefined,
			operationIsLocatedInWorkspace: isSet(object.operationIsLocatedInWorkspace)
				? globalThis.Boolean(object.operationIsLocatedInWorkspace)
				: undefined,
		}
	},

	toJSON(message: SayToolPayload): unknown {
		const obj: any = {}
		if (message.tool !== 0) {
			obj.tool = sayToolTypeToJSON(message.tool)
		}
		if (message.path !== undefined) {
			obj.path = message.path
		}
		if (message.diff !== undefined) {
			obj.diff = message.diff
		}
		if (message.content !== undefined) {
			obj.content = message.content
		}
		if (message.regex !== undefined) {
			obj.regex = message.regex
		}
		if (message.filePattern !== undefined) {
			obj.filePattern = message.filePattern
		}
		if (message.operationIsLocatedInWorkspace !== undefined) {
			obj.operationIsLocatedInWorkspace = message.operationIsLocatedInWorkspace
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayToolPayload>, I>>(base?: I): SayToolPayload {
		return SayToolPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayToolPayload>, I>>(object: I): SayToolPayload {
		const message = createBaseSayToolPayload()
		message.tool = object.tool ?? 0
		message.path = object.path ?? undefined
		message.diff = object.diff ?? undefined
		message.content = object.content ?? undefined
		message.regex = object.regex ?? undefined
		message.filePattern = object.filePattern ?? undefined
		message.operationIsLocatedInWorkspace = object.operationIsLocatedInWorkspace ?? undefined
		return message
	},
}

function createBaseSayShellIntegrationWarningPayload(): SayShellIntegrationWarningPayload {
	return { warningMessage: "" }
}

export const SayShellIntegrationWarningPayload: MessageFns<SayShellIntegrationWarningPayload> = {
	encode(message: SayShellIntegrationWarningPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.warningMessage !== "") {
			writer.uint32(10).string(message.warningMessage)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayShellIntegrationWarningPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayShellIntegrationWarningPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.warningMessage = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayShellIntegrationWarningPayload {
		return { warningMessage: isSet(object.warningMessage) ? globalThis.String(object.warningMessage) : "" }
	},

	toJSON(message: SayShellIntegrationWarningPayload): unknown {
		const obj: any = {}
		if (message.warningMessage !== "") {
			obj.warningMessage = message.warningMessage
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayShellIntegrationWarningPayload>, I>>(base?: I): SayShellIntegrationWarningPayload {
		return SayShellIntegrationWarningPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayShellIntegrationWarningPayload>, I>>(
		object: I,
	): SayShellIntegrationWarningPayload {
		const message = createBaseSayShellIntegrationWarningPayload()
		message.warningMessage = object.warningMessage ?? ""
		return message
	},
}

function createBaseSayBrowserActionLaunchPayload(): SayBrowserActionLaunchPayload {
	return { url: "" }
}

export const SayBrowserActionLaunchPayload: MessageFns<SayBrowserActionLaunchPayload> = {
	encode(message: SayBrowserActionLaunchPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.url !== "") {
			writer.uint32(10).string(message.url)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayBrowserActionLaunchPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayBrowserActionLaunchPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.url = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayBrowserActionLaunchPayload {
		return { url: isSet(object.url) ? globalThis.String(object.url) : "" }
	},

	toJSON(message: SayBrowserActionLaunchPayload): unknown {
		const obj: any = {}
		if (message.url !== "") {
			obj.url = message.url
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayBrowserActionLaunchPayload>, I>>(base?: I): SayBrowserActionLaunchPayload {
		return SayBrowserActionLaunchPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayBrowserActionLaunchPayload>, I>>(object: I): SayBrowserActionLaunchPayload {
		const message = createBaseSayBrowserActionLaunchPayload()
		message.url = object.url ?? ""
		return message
	},
}

function createBaseSayBrowserActionPayload(): SayBrowserActionPayload {
	return { action: 0, coordinate: undefined, text: undefined }
}

export const SayBrowserActionPayload: MessageFns<SayBrowserActionPayload> = {
	encode(message: SayBrowserActionPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.action !== 0) {
			writer.uint32(8).int32(message.action)
		}
		if (message.coordinate !== undefined) {
			writer.uint32(18).string(message.coordinate)
		}
		if (message.text !== undefined) {
			writer.uint32(26).string(message.text)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayBrowserActionPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayBrowserActionPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.action = reader.int32() as any
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.coordinate = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.text = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayBrowserActionPayload {
		return {
			action: isSet(object.action) ? browserActionTypeFromJSON(object.action) : 0,
			coordinate: isSet(object.coordinate) ? globalThis.String(object.coordinate) : undefined,
			text: isSet(object.text) ? globalThis.String(object.text) : undefined,
		}
	},

	toJSON(message: SayBrowserActionPayload): unknown {
		const obj: any = {}
		if (message.action !== 0) {
			obj.action = browserActionTypeToJSON(message.action)
		}
		if (message.coordinate !== undefined) {
			obj.coordinate = message.coordinate
		}
		if (message.text !== undefined) {
			obj.text = message.text
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayBrowserActionPayload>, I>>(base?: I): SayBrowserActionPayload {
		return SayBrowserActionPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayBrowserActionPayload>, I>>(object: I): SayBrowserActionPayload {
		const message = createBaseSayBrowserActionPayload()
		message.action = object.action ?? 0
		message.coordinate = object.coordinate ?? undefined
		message.text = object.text ?? undefined
		return message
	},
}

function createBaseSayBrowserActionResultPayload(): SayBrowserActionResultPayload {
	return { screenshot: undefined, logs: undefined, currentUrl: undefined, currentMousePosition: undefined }
}

export const SayBrowserActionResultPayload: MessageFns<SayBrowserActionResultPayload> = {
	encode(message: SayBrowserActionResultPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.screenshot !== undefined) {
			writer.uint32(10).string(message.screenshot)
		}
		if (message.logs !== undefined) {
			writer.uint32(18).string(message.logs)
		}
		if (message.currentUrl !== undefined) {
			writer.uint32(26).string(message.currentUrl)
		}
		if (message.currentMousePosition !== undefined) {
			writer.uint32(34).string(message.currentMousePosition)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayBrowserActionResultPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayBrowserActionResultPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.screenshot = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.logs = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.currentUrl = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.currentMousePosition = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayBrowserActionResultPayload {
		return {
			screenshot: isSet(object.screenshot) ? globalThis.String(object.screenshot) : undefined,
			logs: isSet(object.logs) ? globalThis.String(object.logs) : undefined,
			currentUrl: isSet(object.currentUrl) ? globalThis.String(object.currentUrl) : undefined,
			currentMousePosition: isSet(object.currentMousePosition) ? globalThis.String(object.currentMousePosition) : undefined,
		}
	},

	toJSON(message: SayBrowserActionResultPayload): unknown {
		const obj: any = {}
		if (message.screenshot !== undefined) {
			obj.screenshot = message.screenshot
		}
		if (message.logs !== undefined) {
			obj.logs = message.logs
		}
		if (message.currentUrl !== undefined) {
			obj.currentUrl = message.currentUrl
		}
		if (message.currentMousePosition !== undefined) {
			obj.currentMousePosition = message.currentMousePosition
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayBrowserActionResultPayload>, I>>(base?: I): SayBrowserActionResultPayload {
		return SayBrowserActionResultPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayBrowserActionResultPayload>, I>>(object: I): SayBrowserActionResultPayload {
		const message = createBaseSayBrowserActionResultPayload()
		message.screenshot = object.screenshot ?? undefined
		message.logs = object.logs ?? undefined
		message.currentUrl = object.currentUrl ?? undefined
		message.currentMousePosition = object.currentMousePosition ?? undefined
		return message
	},
}

function createBaseSayMcpServerRequestStartedPayload(): SayMcpServerRequestStartedPayload {
	return { serverName: "" }
}

export const SayMcpServerRequestStartedPayload: MessageFns<SayMcpServerRequestStartedPayload> = {
	encode(message: SayMcpServerRequestStartedPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.serverName !== "") {
			writer.uint32(10).string(message.serverName)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayMcpServerRequestStartedPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayMcpServerRequestStartedPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.serverName = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayMcpServerRequestStartedPayload {
		return { serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "" }
	},

	toJSON(message: SayMcpServerRequestStartedPayload): unknown {
		const obj: any = {}
		if (message.serverName !== "") {
			obj.serverName = message.serverName
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayMcpServerRequestStartedPayload>, I>>(base?: I): SayMcpServerRequestStartedPayload {
		return SayMcpServerRequestStartedPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayMcpServerRequestStartedPayload>, I>>(
		object: I,
	): SayMcpServerRequestStartedPayload {
		const message = createBaseSayMcpServerRequestStartedPayload()
		message.serverName = object.serverName ?? ""
		return message
	},
}

function createBaseSayMcpServerResponsePayload(): SayMcpServerResponsePayload {
	return { serverName: "", responseContent: "" }
}

export const SayMcpServerResponsePayload: MessageFns<SayMcpServerResponsePayload> = {
	encode(message: SayMcpServerResponsePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.serverName !== "") {
			writer.uint32(10).string(message.serverName)
		}
		if (message.responseContent !== "") {
			writer.uint32(18).string(message.responseContent)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayMcpServerResponsePayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayMcpServerResponsePayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.serverName = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.responseContent = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayMcpServerResponsePayload {
		return {
			serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "",
			responseContent: isSet(object.responseContent) ? globalThis.String(object.responseContent) : "",
		}
	},

	toJSON(message: SayMcpServerResponsePayload): unknown {
		const obj: any = {}
		if (message.serverName !== "") {
			obj.serverName = message.serverName
		}
		if (message.responseContent !== "") {
			obj.responseContent = message.responseContent
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayMcpServerResponsePayload>, I>>(base?: I): SayMcpServerResponsePayload {
		return SayMcpServerResponsePayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayMcpServerResponsePayload>, I>>(object: I): SayMcpServerResponsePayload {
		const message = createBaseSayMcpServerResponsePayload()
		message.serverName = object.serverName ?? ""
		message.responseContent = object.responseContent ?? ""
		return message
	},
}

function createBaseSayUseMcpServerPayload(): SayUseMcpServerPayload {
	return { details: undefined }
}

export const SayUseMcpServerPayload: MessageFns<SayUseMcpServerPayload> = {
	encode(message: SayUseMcpServerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.details !== undefined) {
			AskUseMcpServerPayload.encode(message.details, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayUseMcpServerPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayUseMcpServerPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.details = AskUseMcpServerPayload.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayUseMcpServerPayload {
		return { details: isSet(object.details) ? AskUseMcpServerPayload.fromJSON(object.details) : undefined }
	},

	toJSON(message: SayUseMcpServerPayload): unknown {
		const obj: any = {}
		if (message.details !== undefined) {
			obj.details = AskUseMcpServerPayload.toJSON(message.details)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayUseMcpServerPayload>, I>>(base?: I): SayUseMcpServerPayload {
		return SayUseMcpServerPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayUseMcpServerPayload>, I>>(object: I): SayUseMcpServerPayload {
		const message = createBaseSayUseMcpServerPayload()
		message.details =
			object.details !== undefined && object.details !== null
				? AskUseMcpServerPayload.fromPartial(object.details)
				: undefined
		return message
	},
}

function createBaseSayDiffErrorPayload(): SayDiffErrorPayload {
	return { errorMessage: "", path: "" }
}

export const SayDiffErrorPayload: MessageFns<SayDiffErrorPayload> = {
	encode(message: SayDiffErrorPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.errorMessage !== "") {
			writer.uint32(10).string(message.errorMessage)
		}
		if (message.path !== "") {
			writer.uint32(18).string(message.path)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayDiffErrorPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayDiffErrorPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.errorMessage = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.path = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayDiffErrorPayload {
		return {
			errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
			path: isSet(object.path) ? globalThis.String(object.path) : "",
		}
	},

	toJSON(message: SayDiffErrorPayload): unknown {
		const obj: any = {}
		if (message.errorMessage !== "") {
			obj.errorMessage = message.errorMessage
		}
		if (message.path !== "") {
			obj.path = message.path
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayDiffErrorPayload>, I>>(base?: I): SayDiffErrorPayload {
		return SayDiffErrorPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayDiffErrorPayload>, I>>(object: I): SayDiffErrorPayload {
		const message = createBaseSayDiffErrorPayload()
		message.errorMessage = object.errorMessage ?? ""
		message.path = object.path ?? ""
		return message
	},
}

function createBaseSayDeletedApiReqsPayload(): SayDeletedApiReqsPayload {
	return { count: 0 }
}

export const SayDeletedApiReqsPayload: MessageFns<SayDeletedApiReqsPayload> = {
	encode(message: SayDeletedApiReqsPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.count !== 0) {
			writer.uint32(8).int32(message.count)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayDeletedApiReqsPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayDeletedApiReqsPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.count = reader.int32()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayDeletedApiReqsPayload {
		return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 }
	},

	toJSON(message: SayDeletedApiReqsPayload): unknown {
		const obj: any = {}
		if (message.count !== 0) {
			obj.count = Math.round(message.count)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayDeletedApiReqsPayload>, I>>(base?: I): SayDeletedApiReqsPayload {
		return SayDeletedApiReqsPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayDeletedApiReqsPayload>, I>>(object: I): SayDeletedApiReqsPayload {
		const message = createBaseSayDeletedApiReqsPayload()
		message.count = object.count ?? 0
		return message
	},
}

function createBaseSayClineignoreErrorPayload(): SayClineignoreErrorPayload {
	return { errorMessage: "" }
}

export const SayClineignoreErrorPayload: MessageFns<SayClineignoreErrorPayload> = {
	encode(message: SayClineignoreErrorPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.errorMessage !== "") {
			writer.uint32(10).string(message.errorMessage)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayClineignoreErrorPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayClineignoreErrorPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.errorMessage = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayClineignoreErrorPayload {
		return { errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "" }
	},

	toJSON(message: SayClineignoreErrorPayload): unknown {
		const obj: any = {}
		if (message.errorMessage !== "") {
			obj.errorMessage = message.errorMessage
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayClineignoreErrorPayload>, I>>(base?: I): SayClineignoreErrorPayload {
		return SayClineignoreErrorPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayClineignoreErrorPayload>, I>>(object: I): SayClineignoreErrorPayload {
		const message = createBaseSayClineignoreErrorPayload()
		message.errorMessage = object.errorMessage ?? ""
		return message
	},
}

function createBaseSayCheckpointCreatedPayload(): SayCheckpointCreatedPayload {
	return { checkpointHash: "" }
}

export const SayCheckpointCreatedPayload: MessageFns<SayCheckpointCreatedPayload> = {
	encode(message: SayCheckpointCreatedPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.checkpointHash !== "") {
			writer.uint32(10).string(message.checkpointHash)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayCheckpointCreatedPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayCheckpointCreatedPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.checkpointHash = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SayCheckpointCreatedPayload {
		return { checkpointHash: isSet(object.checkpointHash) ? globalThis.String(object.checkpointHash) : "" }
	},

	toJSON(message: SayCheckpointCreatedPayload): unknown {
		const obj: any = {}
		if (message.checkpointHash !== "") {
			obj.checkpointHash = message.checkpointHash
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SayCheckpointCreatedPayload>, I>>(base?: I): SayCheckpointCreatedPayload {
		return SayCheckpointCreatedPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayCheckpointCreatedPayload>, I>>(object: I): SayCheckpointCreatedPayload {
		const message = createBaseSayCheckpointCreatedPayload()
		message.checkpointHash = object.checkpointHash ?? ""
		return message
	},
}

function createBaseSayLoadMcpDocumentationPayload(): SayLoadMcpDocumentationPayload {
	return {}
}

export const SayLoadMcpDocumentationPayload: MessageFns<SayLoadMcpDocumentationPayload> = {
	encode(_: SayLoadMcpDocumentationPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SayLoadMcpDocumentationPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSayLoadMcpDocumentationPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(_: any): SayLoadMcpDocumentationPayload {
		return {}
	},

	toJSON(_: SayLoadMcpDocumentationPayload): unknown {
		const obj: any = {}
		return obj
	},

	create<I extends Exact<DeepPartial<SayLoadMcpDocumentationPayload>, I>>(base?: I): SayLoadMcpDocumentationPayload {
		return SayLoadMcpDocumentationPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SayLoadMcpDocumentationPayload>, I>>(_: I): SayLoadMcpDocumentationPayload {
		const message = createBaseSayLoadMcpDocumentationPayload()
		return message
	},
}

function createBaseClineMessage(): ClineMessage {
	return {
		ts: 0,
		type: 0,
		text: undefined,
		reasoning: undefined,
		images: [],
		partial: undefined,
		lastCheckpointHash: undefined,
		isCheckpointCheckedOut: undefined,
		isOperationOutsideWorkspace: undefined,
		conversationHistoryIndex: undefined,
		conversationHistoryDeletedRange: undefined,
		actualAskType: undefined,
		actualSayType: undefined,
		askFollowupPayload: undefined,
		askPlanModeRespondPayload: undefined,
		askCommandPayload: undefined,
		askCommandOutputPayload: undefined,
		askCompletionResultPayload: undefined,
		askToolPayload: undefined,
		askApiReqFailedPayload: undefined,
		askResumeTaskPayload: undefined,
		askResumeCompletedTaskPayload: undefined,
		askMistakeLimitReachedPayload: undefined,
		askAutoApprovalMaxReqReachedPayload: undefined,
		askBrowserActionLaunchPayload: undefined,
		askUseMcpServerPayload: undefined,
		askNewTaskPayload: undefined,
		sayTaskPayload: undefined,
		sayErrorPayload: undefined,
		sayApiReqInfoPayload: undefined,
		sayTextPayload: undefined,
		sayReasoningPayload: undefined,
		sayCompletionResultPayload: undefined,
		sayUserFeedbackPayload: undefined,
		sayUserFeedbackDiffPayload: undefined,
		sayCommandPayload: undefined,
		sayCommandOutputPayload: undefined,
		sayToolPayload: undefined,
		sayShellIntegrationWarningPayload: undefined,
		sayBrowserActionLaunchPayload: undefined,
		sayBrowserActionPayload: undefined,
		sayBrowserActionResultPayload: undefined,
		sayMcpServerRequestStartedPayload: undefined,
		sayMcpServerResponsePayload: undefined,
		sayUseMcpServerPayload: undefined,
		sayDiffErrorPayload: undefined,
		sayDeletedApiReqsPayload: undefined,
		sayClineignoreErrorPayload: undefined,
		sayCheckpointCreatedPayload: undefined,
		sayLoadMcpDocumentationPayload: undefined,
	}
}

export const ClineMessage: MessageFns<ClineMessage> = {
	encode(message: ClineMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.ts !== 0) {
			writer.uint32(8).int64(message.ts)
		}
		if (message.type !== 0) {
			writer.uint32(16).int32(message.type)
		}
		if (message.text !== undefined) {
			writer.uint32(26).string(message.text)
		}
		if (message.reasoning !== undefined) {
			writer.uint32(34).string(message.reasoning)
		}
		for (const v of message.images) {
			writer.uint32(42).string(v!)
		}
		if (message.partial !== undefined) {
			writer.uint32(48).bool(message.partial)
		}
		if (message.lastCheckpointHash !== undefined) {
			writer.uint32(58).string(message.lastCheckpointHash)
		}
		if (message.isCheckpointCheckedOut !== undefined) {
			writer.uint32(64).bool(message.isCheckpointCheckedOut)
		}
		if (message.isOperationOutsideWorkspace !== undefined) {
			writer.uint32(72).bool(message.isOperationOutsideWorkspace)
		}
		if (message.conversationHistoryIndex !== undefined) {
			writer.uint32(80).int64(message.conversationHistoryIndex)
		}
		if (message.conversationHistoryDeletedRange !== undefined) {
			HistoryItem_ConversationHistoryDeletedRange.encode(
				message.conversationHistoryDeletedRange,
				writer.uint32(90).fork(),
			).join()
		}
		if (message.actualAskType !== undefined) {
			writer.uint32(104).int32(message.actualAskType)
		}
		if (message.actualSayType !== undefined) {
			writer.uint32(96).int32(message.actualSayType)
		}
		if (message.askFollowupPayload !== undefined) {
			AskFollowupPayload.encode(message.askFollowupPayload, writer.uint32(170).fork()).join()
		}
		if (message.askPlanModeRespondPayload !== undefined) {
			AskPlanModeRespondPayload.encode(message.askPlanModeRespondPayload, writer.uint32(178).fork()).join()
		}
		if (message.askCommandPayload !== undefined) {
			AskCommandPayload.encode(message.askCommandPayload, writer.uint32(186).fork()).join()
		}
		if (message.askCommandOutputPayload !== undefined) {
			AskCommandOutputPayload.encode(message.askCommandOutputPayload, writer.uint32(194).fork()).join()
		}
		if (message.askCompletionResultPayload !== undefined) {
			AskCompletionResultPayload.encode(message.askCompletionResultPayload, writer.uint32(202).fork()).join()
		}
		if (message.askToolPayload !== undefined) {
			AskToolPayload.encode(message.askToolPayload, writer.uint32(210).fork()).join()
		}
		if (message.askApiReqFailedPayload !== undefined) {
			AskApiReqFailedPayload.encode(message.askApiReqFailedPayload, writer.uint32(218).fork()).join()
		}
		if (message.askResumeTaskPayload !== undefined) {
			AskResumeTaskPayload.encode(message.askResumeTaskPayload, writer.uint32(226).fork()).join()
		}
		if (message.askResumeCompletedTaskPayload !== undefined) {
			AskResumeCompletedTaskPayload.encode(message.askResumeCompletedTaskPayload, writer.uint32(234).fork()).join()
		}
		if (message.askMistakeLimitReachedPayload !== undefined) {
			AskMistakeLimitReachedPayload.encode(message.askMistakeLimitReachedPayload, writer.uint32(242).fork()).join()
		}
		if (message.askAutoApprovalMaxReqReachedPayload !== undefined) {
			AskAutoApprovalMaxReqReachedPayload.encode(
				message.askAutoApprovalMaxReqReachedPayload,
				writer.uint32(250).fork(),
			).join()
		}
		if (message.askBrowserActionLaunchPayload !== undefined) {
			AskBrowserActionLaunchPayload.encode(message.askBrowserActionLaunchPayload, writer.uint32(258).fork()).join()
		}
		if (message.askUseMcpServerPayload !== undefined) {
			AskUseMcpServerPayload.encode(message.askUseMcpServerPayload, writer.uint32(266).fork()).join()
		}
		if (message.askNewTaskPayload !== undefined) {
			AskNewTaskPayload.encode(message.askNewTaskPayload, writer.uint32(274).fork()).join()
		}
		if (message.sayTaskPayload !== undefined) {
			SayTaskPayload.encode(message.sayTaskPayload, writer.uint32(330).fork()).join()
		}
		if (message.sayErrorPayload !== undefined) {
			SayErrorPayload.encode(message.sayErrorPayload, writer.uint32(338).fork()).join()
		}
		if (message.sayApiReqInfoPayload !== undefined) {
			SayApiReqInfoPayload.encode(message.sayApiReqInfoPayload, writer.uint32(346).fork()).join()
		}
		if (message.sayTextPayload !== undefined) {
			SayTextPayload.encode(message.sayTextPayload, writer.uint32(354).fork()).join()
		}
		if (message.sayReasoningPayload !== undefined) {
			SayReasoningPayload.encode(message.sayReasoningPayload, writer.uint32(362).fork()).join()
		}
		if (message.sayCompletionResultPayload !== undefined) {
			SayCompletionResultPayload.encode(message.sayCompletionResultPayload, writer.uint32(370).fork()).join()
		}
		if (message.sayUserFeedbackPayload !== undefined) {
			SayUserFeedbackPayload.encode(message.sayUserFeedbackPayload, writer.uint32(378).fork()).join()
		}
		if (message.sayUserFeedbackDiffPayload !== undefined) {
			SayUserFeedbackDiffPayload.encode(message.sayUserFeedbackDiffPayload, writer.uint32(386).fork()).join()
		}
		if (message.sayCommandPayload !== undefined) {
			SayCommandPayload.encode(message.sayCommandPayload, writer.uint32(394).fork()).join()
		}
		if (message.sayCommandOutputPayload !== undefined) {
			SayCommandOutputPayload.encode(message.sayCommandOutputPayload, writer.uint32(402).fork()).join()
		}
		if (message.sayToolPayload !== undefined) {
			SayToolPayload.encode(message.sayToolPayload, writer.uint32(410).fork()).join()
		}
		if (message.sayShellIntegrationWarningPayload !== undefined) {
			SayShellIntegrationWarningPayload.encode(message.sayShellIntegrationWarningPayload, writer.uint32(418).fork()).join()
		}
		if (message.sayBrowserActionLaunchPayload !== undefined) {
			SayBrowserActionLaunchPayload.encode(message.sayBrowserActionLaunchPayload, writer.uint32(426).fork()).join()
		}
		if (message.sayBrowserActionPayload !== undefined) {
			SayBrowserActionPayload.encode(message.sayBrowserActionPayload, writer.uint32(434).fork()).join()
		}
		if (message.sayBrowserActionResultPayload !== undefined) {
			SayBrowserActionResultPayload.encode(message.sayBrowserActionResultPayload, writer.uint32(442).fork()).join()
		}
		if (message.sayMcpServerRequestStartedPayload !== undefined) {
			SayMcpServerRequestStartedPayload.encode(message.sayMcpServerRequestStartedPayload, writer.uint32(450).fork()).join()
		}
		if (message.sayMcpServerResponsePayload !== undefined) {
			SayMcpServerResponsePayload.encode(message.sayMcpServerResponsePayload, writer.uint32(458).fork()).join()
		}
		if (message.sayUseMcpServerPayload !== undefined) {
			SayUseMcpServerPayload.encode(message.sayUseMcpServerPayload, writer.uint32(466).fork()).join()
		}
		if (message.sayDiffErrorPayload !== undefined) {
			SayDiffErrorPayload.encode(message.sayDiffErrorPayload, writer.uint32(474).fork()).join()
		}
		if (message.sayDeletedApiReqsPayload !== undefined) {
			SayDeletedApiReqsPayload.encode(message.sayDeletedApiReqsPayload, writer.uint32(482).fork()).join()
		}
		if (message.sayClineignoreErrorPayload !== undefined) {
			SayClineignoreErrorPayload.encode(message.sayClineignoreErrorPayload, writer.uint32(490).fork()).join()
		}
		if (message.sayCheckpointCreatedPayload !== undefined) {
			SayCheckpointCreatedPayload.encode(message.sayCheckpointCreatedPayload, writer.uint32(498).fork()).join()
		}
		if (message.sayLoadMcpDocumentationPayload !== undefined) {
			SayLoadMcpDocumentationPayload.encode(message.sayLoadMcpDocumentationPayload, writer.uint32(506).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ClineMessage {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseClineMessage()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.ts = longToNumber(reader.int64())
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.type = reader.int32() as any
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.text = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.reasoning = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.images.push(reader.string())
					continue
				}
				case 6: {
					if (tag !== 48) {
						break
					}

					message.partial = reader.bool()
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.lastCheckpointHash = reader.string()
					continue
				}
				case 8: {
					if (tag !== 64) {
						break
					}

					message.isCheckpointCheckedOut = reader.bool()
					continue
				}
				case 9: {
					if (tag !== 72) {
						break
					}

					message.isOperationOutsideWorkspace = reader.bool()
					continue
				}
				case 10: {
					if (tag !== 80) {
						break
					}

					message.conversationHistoryIndex = longToNumber(reader.int64())
					continue
				}
				case 11: {
					if (tag !== 90) {
						break
					}

					message.conversationHistoryDeletedRange = HistoryItem_ConversationHistoryDeletedRange.decode(
						reader,
						reader.uint32(),
					)
					continue
				}
				case 13: {
					if (tag !== 104) {
						break
					}

					message.actualAskType = reader.int32() as any
					continue
				}
				case 12: {
					if (tag !== 96) {
						break
					}

					message.actualSayType = reader.int32() as any
					continue
				}
				case 21: {
					if (tag !== 170) {
						break
					}

					message.askFollowupPayload = AskFollowupPayload.decode(reader, reader.uint32())
					continue
				}
				case 22: {
					if (tag !== 178) {
						break
					}

					message.askPlanModeRespondPayload = AskPlanModeRespondPayload.decode(reader, reader.uint32())
					continue
				}
				case 23: {
					if (tag !== 186) {
						break
					}

					message.askCommandPayload = AskCommandPayload.decode(reader, reader.uint32())
					continue
				}
				case 24: {
					if (tag !== 194) {
						break
					}

					message.askCommandOutputPayload = AskCommandOutputPayload.decode(reader, reader.uint32())
					continue
				}
				case 25: {
					if (tag !== 202) {
						break
					}

					message.askCompletionResultPayload = AskCompletionResultPayload.decode(reader, reader.uint32())
					continue
				}
				case 26: {
					if (tag !== 210) {
						break
					}

					message.askToolPayload = AskToolPayload.decode(reader, reader.uint32())
					continue
				}
				case 27: {
					if (tag !== 218) {
						break
					}

					message.askApiReqFailedPayload = AskApiReqFailedPayload.decode(reader, reader.uint32())
					continue
				}
				case 28: {
					if (tag !== 226) {
						break
					}

					message.askResumeTaskPayload = AskResumeTaskPayload.decode(reader, reader.uint32())
					continue
				}
				case 29: {
					if (tag !== 234) {
						break
					}

					message.askResumeCompletedTaskPayload = AskResumeCompletedTaskPayload.decode(reader, reader.uint32())
					continue
				}
				case 30: {
					if (tag !== 242) {
						break
					}

					message.askMistakeLimitReachedPayload = AskMistakeLimitReachedPayload.decode(reader, reader.uint32())
					continue
				}
				case 31: {
					if (tag !== 250) {
						break
					}

					message.askAutoApprovalMaxReqReachedPayload = AskAutoApprovalMaxReqReachedPayload.decode(
						reader,
						reader.uint32(),
					)
					continue
				}
				case 32: {
					if (tag !== 258) {
						break
					}

					message.askBrowserActionLaunchPayload = AskBrowserActionLaunchPayload.decode(reader, reader.uint32())
					continue
				}
				case 33: {
					if (tag !== 266) {
						break
					}

					message.askUseMcpServerPayload = AskUseMcpServerPayload.decode(reader, reader.uint32())
					continue
				}
				case 34: {
					if (tag !== 274) {
						break
					}

					message.askNewTaskPayload = AskNewTaskPayload.decode(reader, reader.uint32())
					continue
				}
				case 41: {
					if (tag !== 330) {
						break
					}

					message.sayTaskPayload = SayTaskPayload.decode(reader, reader.uint32())
					continue
				}
				case 42: {
					if (tag !== 338) {
						break
					}

					message.sayErrorPayload = SayErrorPayload.decode(reader, reader.uint32())
					continue
				}
				case 43: {
					if (tag !== 346) {
						break
					}

					message.sayApiReqInfoPayload = SayApiReqInfoPayload.decode(reader, reader.uint32())
					continue
				}
				case 44: {
					if (tag !== 354) {
						break
					}

					message.sayTextPayload = SayTextPayload.decode(reader, reader.uint32())
					continue
				}
				case 45: {
					if (tag !== 362) {
						break
					}

					message.sayReasoningPayload = SayReasoningPayload.decode(reader, reader.uint32())
					continue
				}
				case 46: {
					if (tag !== 370) {
						break
					}

					message.sayCompletionResultPayload = SayCompletionResultPayload.decode(reader, reader.uint32())
					continue
				}
				case 47: {
					if (tag !== 378) {
						break
					}

					message.sayUserFeedbackPayload = SayUserFeedbackPayload.decode(reader, reader.uint32())
					continue
				}
				case 48: {
					if (tag !== 386) {
						break
					}

					message.sayUserFeedbackDiffPayload = SayUserFeedbackDiffPayload.decode(reader, reader.uint32())
					continue
				}
				case 49: {
					if (tag !== 394) {
						break
					}

					message.sayCommandPayload = SayCommandPayload.decode(reader, reader.uint32())
					continue
				}
				case 50: {
					if (tag !== 402) {
						break
					}

					message.sayCommandOutputPayload = SayCommandOutputPayload.decode(reader, reader.uint32())
					continue
				}
				case 51: {
					if (tag !== 410) {
						break
					}

					message.sayToolPayload = SayToolPayload.decode(reader, reader.uint32())
					continue
				}
				case 52: {
					if (tag !== 418) {
						break
					}

					message.sayShellIntegrationWarningPayload = SayShellIntegrationWarningPayload.decode(reader, reader.uint32())
					continue
				}
				case 53: {
					if (tag !== 426) {
						break
					}

					message.sayBrowserActionLaunchPayload = SayBrowserActionLaunchPayload.decode(reader, reader.uint32())
					continue
				}
				case 54: {
					if (tag !== 434) {
						break
					}

					message.sayBrowserActionPayload = SayBrowserActionPayload.decode(reader, reader.uint32())
					continue
				}
				case 55: {
					if (tag !== 442) {
						break
					}

					message.sayBrowserActionResultPayload = SayBrowserActionResultPayload.decode(reader, reader.uint32())
					continue
				}
				case 56: {
					if (tag !== 450) {
						break
					}

					message.sayMcpServerRequestStartedPayload = SayMcpServerRequestStartedPayload.decode(reader, reader.uint32())
					continue
				}
				case 57: {
					if (tag !== 458) {
						break
					}

					message.sayMcpServerResponsePayload = SayMcpServerResponsePayload.decode(reader, reader.uint32())
					continue
				}
				case 58: {
					if (tag !== 466) {
						break
					}

					message.sayUseMcpServerPayload = SayUseMcpServerPayload.decode(reader, reader.uint32())
					continue
				}
				case 59: {
					if (tag !== 474) {
						break
					}

					message.sayDiffErrorPayload = SayDiffErrorPayload.decode(reader, reader.uint32())
					continue
				}
				case 60: {
					if (tag !== 482) {
						break
					}

					message.sayDeletedApiReqsPayload = SayDeletedApiReqsPayload.decode(reader, reader.uint32())
					continue
				}
				case 61: {
					if (tag !== 490) {
						break
					}

					message.sayClineignoreErrorPayload = SayClineignoreErrorPayload.decode(reader, reader.uint32())
					continue
				}
				case 62: {
					if (tag !== 498) {
						break
					}

					message.sayCheckpointCreatedPayload = SayCheckpointCreatedPayload.decode(reader, reader.uint32())
					continue
				}
				case 63: {
					if (tag !== 506) {
						break
					}

					message.sayLoadMcpDocumentationPayload = SayLoadMcpDocumentationPayload.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ClineMessage {
		return {
			ts: isSet(object.ts) ? globalThis.Number(object.ts) : 0,
			type: isSet(object.type) ? clineMessage_TypeFromJSON(object.type) : 0,
			text: isSet(object.text) ? globalThis.String(object.text) : undefined,
			reasoning: isSet(object.reasoning) ? globalThis.String(object.reasoning) : undefined,
			images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => globalThis.String(e)) : [],
			partial: isSet(object.partial) ? globalThis.Boolean(object.partial) : undefined,
			lastCheckpointHash: isSet(object.lastCheckpointHash) ? globalThis.String(object.lastCheckpointHash) : undefined,
			isCheckpointCheckedOut: isSet(object.isCheckpointCheckedOut)
				? globalThis.Boolean(object.isCheckpointCheckedOut)
				: undefined,
			isOperationOutsideWorkspace: isSet(object.isOperationOutsideWorkspace)
				? globalThis.Boolean(object.isOperationOutsideWorkspace)
				: undefined,
			conversationHistoryIndex: isSet(object.conversationHistoryIndex)
				? globalThis.Number(object.conversationHistoryIndex)
				: undefined,
			conversationHistoryDeletedRange: isSet(object.conversationHistoryDeletedRange)
				? HistoryItem_ConversationHistoryDeletedRange.fromJSON(object.conversationHistoryDeletedRange)
				: undefined,
			actualAskType: isSet(object.actualAskType) ? clineAskTypeFromJSON(object.actualAskType) : undefined,
			actualSayType: isSet(object.actualSayType) ? clineSayTypeFromJSON(object.actualSayType) : undefined,
			askFollowupPayload: isSet(object.askFollowupPayload)
				? AskFollowupPayload.fromJSON(object.askFollowupPayload)
				: undefined,
			askPlanModeRespondPayload: isSet(object.askPlanModeRespondPayload)
				? AskPlanModeRespondPayload.fromJSON(object.askPlanModeRespondPayload)
				: undefined,
			askCommandPayload: isSet(object.askCommandPayload) ? AskCommandPayload.fromJSON(object.askCommandPayload) : undefined,
			askCommandOutputPayload: isSet(object.askCommandOutputPayload)
				? AskCommandOutputPayload.fromJSON(object.askCommandOutputPayload)
				: undefined,
			askCompletionResultPayload: isSet(object.askCompletionResultPayload)
				? AskCompletionResultPayload.fromJSON(object.askCompletionResultPayload)
				: undefined,
			askToolPayload: isSet(object.askToolPayload) ? AskToolPayload.fromJSON(object.askToolPayload) : undefined,
			askApiReqFailedPayload: isSet(object.askApiReqFailedPayload)
				? AskApiReqFailedPayload.fromJSON(object.askApiReqFailedPayload)
				: undefined,
			askResumeTaskPayload: isSet(object.askResumeTaskPayload)
				? AskResumeTaskPayload.fromJSON(object.askResumeTaskPayload)
				: undefined,
			askResumeCompletedTaskPayload: isSet(object.askResumeCompletedTaskPayload)
				? AskResumeCompletedTaskPayload.fromJSON(object.askResumeCompletedTaskPayload)
				: undefined,
			askMistakeLimitReachedPayload: isSet(object.askMistakeLimitReachedPayload)
				? AskMistakeLimitReachedPayload.fromJSON(object.askMistakeLimitReachedPayload)
				: undefined,
			askAutoApprovalMaxReqReachedPayload: isSet(object.askAutoApprovalMaxReqReachedPayload)
				? AskAutoApprovalMaxReqReachedPayload.fromJSON(object.askAutoApprovalMaxReqReachedPayload)
				: undefined,
			askBrowserActionLaunchPayload: isSet(object.askBrowserActionLaunchPayload)
				? AskBrowserActionLaunchPayload.fromJSON(object.askBrowserActionLaunchPayload)
				: undefined,
			askUseMcpServerPayload: isSet(object.askUseMcpServerPayload)
				? AskUseMcpServerPayload.fromJSON(object.askUseMcpServerPayload)
				: undefined,
			askNewTaskPayload: isSet(object.askNewTaskPayload) ? AskNewTaskPayload.fromJSON(object.askNewTaskPayload) : undefined,
			sayTaskPayload: isSet(object.sayTaskPayload) ? SayTaskPayload.fromJSON(object.sayTaskPayload) : undefined,
			sayErrorPayload: isSet(object.sayErrorPayload) ? SayErrorPayload.fromJSON(object.sayErrorPayload) : undefined,
			sayApiReqInfoPayload: isSet(object.sayApiReqInfoPayload)
				? SayApiReqInfoPayload.fromJSON(object.sayApiReqInfoPayload)
				: undefined,
			sayTextPayload: isSet(object.sayTextPayload) ? SayTextPayload.fromJSON(object.sayTextPayload) : undefined,
			sayReasoningPayload: isSet(object.sayReasoningPayload)
				? SayReasoningPayload.fromJSON(object.sayReasoningPayload)
				: undefined,
			sayCompletionResultPayload: isSet(object.sayCompletionResultPayload)
				? SayCompletionResultPayload.fromJSON(object.sayCompletionResultPayload)
				: undefined,
			sayUserFeedbackPayload: isSet(object.sayUserFeedbackPayload)
				? SayUserFeedbackPayload.fromJSON(object.sayUserFeedbackPayload)
				: undefined,
			sayUserFeedbackDiffPayload: isSet(object.sayUserFeedbackDiffPayload)
				? SayUserFeedbackDiffPayload.fromJSON(object.sayUserFeedbackDiffPayload)
				: undefined,
			sayCommandPayload: isSet(object.sayCommandPayload) ? SayCommandPayload.fromJSON(object.sayCommandPayload) : undefined,
			sayCommandOutputPayload: isSet(object.sayCommandOutputPayload)
				? SayCommandOutputPayload.fromJSON(object.sayCommandOutputPayload)
				: undefined,
			sayToolPayload: isSet(object.sayToolPayload) ? SayToolPayload.fromJSON(object.sayToolPayload) : undefined,
			sayShellIntegrationWarningPayload: isSet(object.sayShellIntegrationWarningPayload)
				? SayShellIntegrationWarningPayload.fromJSON(object.sayShellIntegrationWarningPayload)
				: undefined,
			sayBrowserActionLaunchPayload: isSet(object.sayBrowserActionLaunchPayload)
				? SayBrowserActionLaunchPayload.fromJSON(object.sayBrowserActionLaunchPayload)
				: undefined,
			sayBrowserActionPayload: isSet(object.sayBrowserActionPayload)
				? SayBrowserActionPayload.fromJSON(object.sayBrowserActionPayload)
				: undefined,
			sayBrowserActionResultPayload: isSet(object.sayBrowserActionResultPayload)
				? SayBrowserActionResultPayload.fromJSON(object.sayBrowserActionResultPayload)
				: undefined,
			sayMcpServerRequestStartedPayload: isSet(object.sayMcpServerRequestStartedPayload)
				? SayMcpServerRequestStartedPayload.fromJSON(object.sayMcpServerRequestStartedPayload)
				: undefined,
			sayMcpServerResponsePayload: isSet(object.sayMcpServerResponsePayload)
				? SayMcpServerResponsePayload.fromJSON(object.sayMcpServerResponsePayload)
				: undefined,
			sayUseMcpServerPayload: isSet(object.sayUseMcpServerPayload)
				? SayUseMcpServerPayload.fromJSON(object.sayUseMcpServerPayload)
				: undefined,
			sayDiffErrorPayload: isSet(object.sayDiffErrorPayload)
				? SayDiffErrorPayload.fromJSON(object.sayDiffErrorPayload)
				: undefined,
			sayDeletedApiReqsPayload: isSet(object.sayDeletedApiReqsPayload)
				? SayDeletedApiReqsPayload.fromJSON(object.sayDeletedApiReqsPayload)
				: undefined,
			sayClineignoreErrorPayload: isSet(object.sayClineignoreErrorPayload)
				? SayClineignoreErrorPayload.fromJSON(object.sayClineignoreErrorPayload)
				: undefined,
			sayCheckpointCreatedPayload: isSet(object.sayCheckpointCreatedPayload)
				? SayCheckpointCreatedPayload.fromJSON(object.sayCheckpointCreatedPayload)
				: undefined,
			sayLoadMcpDocumentationPayload: isSet(object.sayLoadMcpDocumentationPayload)
				? SayLoadMcpDocumentationPayload.fromJSON(object.sayLoadMcpDocumentationPayload)
				: undefined,
		}
	},

	toJSON(message: ClineMessage): unknown {
		const obj: any = {}
		if (message.ts !== 0) {
			obj.ts = Math.round(message.ts)
		}
		if (message.type !== 0) {
			obj.type = clineMessage_TypeToJSON(message.type)
		}
		if (message.text !== undefined) {
			obj.text = message.text
		}
		if (message.reasoning !== undefined) {
			obj.reasoning = message.reasoning
		}
		if (message.images?.length) {
			obj.images = message.images
		}
		if (message.partial !== undefined) {
			obj.partial = message.partial
		}
		if (message.lastCheckpointHash !== undefined) {
			obj.lastCheckpointHash = message.lastCheckpointHash
		}
		if (message.isCheckpointCheckedOut !== undefined) {
			obj.isCheckpointCheckedOut = message.isCheckpointCheckedOut
		}
		if (message.isOperationOutsideWorkspace !== undefined) {
			obj.isOperationOutsideWorkspace = message.isOperationOutsideWorkspace
		}
		if (message.conversationHistoryIndex !== undefined) {
			obj.conversationHistoryIndex = Math.round(message.conversationHistoryIndex)
		}
		if (message.conversationHistoryDeletedRange !== undefined) {
			obj.conversationHistoryDeletedRange = HistoryItem_ConversationHistoryDeletedRange.toJSON(
				message.conversationHistoryDeletedRange,
			)
		}
		if (message.actualAskType !== undefined) {
			obj.actualAskType = clineAskTypeToJSON(message.actualAskType)
		}
		if (message.actualSayType !== undefined) {
			obj.actualSayType = clineSayTypeToJSON(message.actualSayType)
		}
		if (message.askFollowupPayload !== undefined) {
			obj.askFollowupPayload = AskFollowupPayload.toJSON(message.askFollowupPayload)
		}
		if (message.askPlanModeRespondPayload !== undefined) {
			obj.askPlanModeRespondPayload = AskPlanModeRespondPayload.toJSON(message.askPlanModeRespondPayload)
		}
		if (message.askCommandPayload !== undefined) {
			obj.askCommandPayload = AskCommandPayload.toJSON(message.askCommandPayload)
		}
		if (message.askCommandOutputPayload !== undefined) {
			obj.askCommandOutputPayload = AskCommandOutputPayload.toJSON(message.askCommandOutputPayload)
		}
		if (message.askCompletionResultPayload !== undefined) {
			obj.askCompletionResultPayload = AskCompletionResultPayload.toJSON(message.askCompletionResultPayload)
		}
		if (message.askToolPayload !== undefined) {
			obj.askToolPayload = AskToolPayload.toJSON(message.askToolPayload)
		}
		if (message.askApiReqFailedPayload !== undefined) {
			obj.askApiReqFailedPayload = AskApiReqFailedPayload.toJSON(message.askApiReqFailedPayload)
		}
		if (message.askResumeTaskPayload !== undefined) {
			obj.askResumeTaskPayload = AskResumeTaskPayload.toJSON(message.askResumeTaskPayload)
		}
		if (message.askResumeCompletedTaskPayload !== undefined) {
			obj.askResumeCompletedTaskPayload = AskResumeCompletedTaskPayload.toJSON(message.askResumeCompletedTaskPayload)
		}
		if (message.askMistakeLimitReachedPayload !== undefined) {
			obj.askMistakeLimitReachedPayload = AskMistakeLimitReachedPayload.toJSON(message.askMistakeLimitReachedPayload)
		}
		if (message.askAutoApprovalMaxReqReachedPayload !== undefined) {
			obj.askAutoApprovalMaxReqReachedPayload = AskAutoApprovalMaxReqReachedPayload.toJSON(
				message.askAutoApprovalMaxReqReachedPayload,
			)
		}
		if (message.askBrowserActionLaunchPayload !== undefined) {
			obj.askBrowserActionLaunchPayload = AskBrowserActionLaunchPayload.toJSON(message.askBrowserActionLaunchPayload)
		}
		if (message.askUseMcpServerPayload !== undefined) {
			obj.askUseMcpServerPayload = AskUseMcpServerPayload.toJSON(message.askUseMcpServerPayload)
		}
		if (message.askNewTaskPayload !== undefined) {
			obj.askNewTaskPayload = AskNewTaskPayload.toJSON(message.askNewTaskPayload)
		}
		if (message.sayTaskPayload !== undefined) {
			obj.sayTaskPayload = SayTaskPayload.toJSON(message.sayTaskPayload)
		}
		if (message.sayErrorPayload !== undefined) {
			obj.sayErrorPayload = SayErrorPayload.toJSON(message.sayErrorPayload)
		}
		if (message.sayApiReqInfoPayload !== undefined) {
			obj.sayApiReqInfoPayload = SayApiReqInfoPayload.toJSON(message.sayApiReqInfoPayload)
		}
		if (message.sayTextPayload !== undefined) {
			obj.sayTextPayload = SayTextPayload.toJSON(message.sayTextPayload)
		}
		if (message.sayReasoningPayload !== undefined) {
			obj.sayReasoningPayload = SayReasoningPayload.toJSON(message.sayReasoningPayload)
		}
		if (message.sayCompletionResultPayload !== undefined) {
			obj.sayCompletionResultPayload = SayCompletionResultPayload.toJSON(message.sayCompletionResultPayload)
		}
		if (message.sayUserFeedbackPayload !== undefined) {
			obj.sayUserFeedbackPayload = SayUserFeedbackPayload.toJSON(message.sayUserFeedbackPayload)
		}
		if (message.sayUserFeedbackDiffPayload !== undefined) {
			obj.sayUserFeedbackDiffPayload = SayUserFeedbackDiffPayload.toJSON(message.sayUserFeedbackDiffPayload)
		}
		if (message.sayCommandPayload !== undefined) {
			obj.sayCommandPayload = SayCommandPayload.toJSON(message.sayCommandPayload)
		}
		if (message.sayCommandOutputPayload !== undefined) {
			obj.sayCommandOutputPayload = SayCommandOutputPayload.toJSON(message.sayCommandOutputPayload)
		}
		if (message.sayToolPayload !== undefined) {
			obj.sayToolPayload = SayToolPayload.toJSON(message.sayToolPayload)
		}
		if (message.sayShellIntegrationWarningPayload !== undefined) {
			obj.sayShellIntegrationWarningPayload = SayShellIntegrationWarningPayload.toJSON(
				message.sayShellIntegrationWarningPayload,
			)
		}
		if (message.sayBrowserActionLaunchPayload !== undefined) {
			obj.sayBrowserActionLaunchPayload = SayBrowserActionLaunchPayload.toJSON(message.sayBrowserActionLaunchPayload)
		}
		if (message.sayBrowserActionPayload !== undefined) {
			obj.sayBrowserActionPayload = SayBrowserActionPayload.toJSON(message.sayBrowserActionPayload)
		}
		if (message.sayBrowserActionResultPayload !== undefined) {
			obj.sayBrowserActionResultPayload = SayBrowserActionResultPayload.toJSON(message.sayBrowserActionResultPayload)
		}
		if (message.sayMcpServerRequestStartedPayload !== undefined) {
			obj.sayMcpServerRequestStartedPayload = SayMcpServerRequestStartedPayload.toJSON(
				message.sayMcpServerRequestStartedPayload,
			)
		}
		if (message.sayMcpServerResponsePayload !== undefined) {
			obj.sayMcpServerResponsePayload = SayMcpServerResponsePayload.toJSON(message.sayMcpServerResponsePayload)
		}
		if (message.sayUseMcpServerPayload !== undefined) {
			obj.sayUseMcpServerPayload = SayUseMcpServerPayload.toJSON(message.sayUseMcpServerPayload)
		}
		if (message.sayDiffErrorPayload !== undefined) {
			obj.sayDiffErrorPayload = SayDiffErrorPayload.toJSON(message.sayDiffErrorPayload)
		}
		if (message.sayDeletedApiReqsPayload !== undefined) {
			obj.sayDeletedApiReqsPayload = SayDeletedApiReqsPayload.toJSON(message.sayDeletedApiReqsPayload)
		}
		if (message.sayClineignoreErrorPayload !== undefined) {
			obj.sayClineignoreErrorPayload = SayClineignoreErrorPayload.toJSON(message.sayClineignoreErrorPayload)
		}
		if (message.sayCheckpointCreatedPayload !== undefined) {
			obj.sayCheckpointCreatedPayload = SayCheckpointCreatedPayload.toJSON(message.sayCheckpointCreatedPayload)
		}
		if (message.sayLoadMcpDocumentationPayload !== undefined) {
			obj.sayLoadMcpDocumentationPayload = SayLoadMcpDocumentationPayload.toJSON(message.sayLoadMcpDocumentationPayload)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ClineMessage>, I>>(base?: I): ClineMessage {
		return ClineMessage.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ClineMessage>, I>>(object: I): ClineMessage {
		const message = createBaseClineMessage()
		message.ts = object.ts ?? 0
		message.type = object.type ?? 0
		message.text = object.text ?? undefined
		message.reasoning = object.reasoning ?? undefined
		message.images = object.images?.map((e) => e) || []
		message.partial = object.partial ?? undefined
		message.lastCheckpointHash = object.lastCheckpointHash ?? undefined
		message.isCheckpointCheckedOut = object.isCheckpointCheckedOut ?? undefined
		message.isOperationOutsideWorkspace = object.isOperationOutsideWorkspace ?? undefined
		message.conversationHistoryIndex = object.conversationHistoryIndex ?? undefined
		message.conversationHistoryDeletedRange =
			object.conversationHistoryDeletedRange !== undefined && object.conversationHistoryDeletedRange !== null
				? HistoryItem_ConversationHistoryDeletedRange.fromPartial(object.conversationHistoryDeletedRange)
				: undefined
		message.actualAskType = object.actualAskType ?? undefined
		message.actualSayType = object.actualSayType ?? undefined
		message.askFollowupPayload =
			object.askFollowupPayload !== undefined && object.askFollowupPayload !== null
				? AskFollowupPayload.fromPartial(object.askFollowupPayload)
				: undefined
		message.askPlanModeRespondPayload =
			object.askPlanModeRespondPayload !== undefined && object.askPlanModeRespondPayload !== null
				? AskPlanModeRespondPayload.fromPartial(object.askPlanModeRespondPayload)
				: undefined
		message.askCommandPayload =
			object.askCommandPayload !== undefined && object.askCommandPayload !== null
				? AskCommandPayload.fromPartial(object.askCommandPayload)
				: undefined
		message.askCommandOutputPayload =
			object.askCommandOutputPayload !== undefined && object.askCommandOutputPayload !== null
				? AskCommandOutputPayload.fromPartial(object.askCommandOutputPayload)
				: undefined
		message.askCompletionResultPayload =
			object.askCompletionResultPayload !== undefined && object.askCompletionResultPayload !== null
				? AskCompletionResultPayload.fromPartial(object.askCompletionResultPayload)
				: undefined
		message.askToolPayload =
			object.askToolPayload !== undefined && object.askToolPayload !== null
				? AskToolPayload.fromPartial(object.askToolPayload)
				: undefined
		message.askApiReqFailedPayload =
			object.askApiReqFailedPayload !== undefined && object.askApiReqFailedPayload !== null
				? AskApiReqFailedPayload.fromPartial(object.askApiReqFailedPayload)
				: undefined
		message.askResumeTaskPayload =
			object.askResumeTaskPayload !== undefined && object.askResumeTaskPayload !== null
				? AskResumeTaskPayload.fromPartial(object.askResumeTaskPayload)
				: undefined
		message.askResumeCompletedTaskPayload =
			object.askResumeCompletedTaskPayload !== undefined && object.askResumeCompletedTaskPayload !== null
				? AskResumeCompletedTaskPayload.fromPartial(object.askResumeCompletedTaskPayload)
				: undefined
		message.askMistakeLimitReachedPayload =
			object.askMistakeLimitReachedPayload !== undefined && object.askMistakeLimitReachedPayload !== null
				? AskMistakeLimitReachedPayload.fromPartial(object.askMistakeLimitReachedPayload)
				: undefined
		message.askAutoApprovalMaxReqReachedPayload =
			object.askAutoApprovalMaxReqReachedPayload !== undefined && object.askAutoApprovalMaxReqReachedPayload !== null
				? AskAutoApprovalMaxReqReachedPayload.fromPartial(object.askAutoApprovalMaxReqReachedPayload)
				: undefined
		message.askBrowserActionLaunchPayload =
			object.askBrowserActionLaunchPayload !== undefined && object.askBrowserActionLaunchPayload !== null
				? AskBrowserActionLaunchPayload.fromPartial(object.askBrowserActionLaunchPayload)
				: undefined
		message.askUseMcpServerPayload =
			object.askUseMcpServerPayload !== undefined && object.askUseMcpServerPayload !== null
				? AskUseMcpServerPayload.fromPartial(object.askUseMcpServerPayload)
				: undefined
		message.askNewTaskPayload =
			object.askNewTaskPayload !== undefined && object.askNewTaskPayload !== null
				? AskNewTaskPayload.fromPartial(object.askNewTaskPayload)
				: undefined
		message.sayTaskPayload =
			object.sayTaskPayload !== undefined && object.sayTaskPayload !== null
				? SayTaskPayload.fromPartial(object.sayTaskPayload)
				: undefined
		message.sayErrorPayload =
			object.sayErrorPayload !== undefined && object.sayErrorPayload !== null
				? SayErrorPayload.fromPartial(object.sayErrorPayload)
				: undefined
		message.sayApiReqInfoPayload =
			object.sayApiReqInfoPayload !== undefined && object.sayApiReqInfoPayload !== null
				? SayApiReqInfoPayload.fromPartial(object.sayApiReqInfoPayload)
				: undefined
		message.sayTextPayload =
			object.sayTextPayload !== undefined && object.sayTextPayload !== null
				? SayTextPayload.fromPartial(object.sayTextPayload)
				: undefined
		message.sayReasoningPayload =
			object.sayReasoningPayload !== undefined && object.sayReasoningPayload !== null
				? SayReasoningPayload.fromPartial(object.sayReasoningPayload)
				: undefined
		message.sayCompletionResultPayload =
			object.sayCompletionResultPayload !== undefined && object.sayCompletionResultPayload !== null
				? SayCompletionResultPayload.fromPartial(object.sayCompletionResultPayload)
				: undefined
		message.sayUserFeedbackPayload =
			object.sayUserFeedbackPayload !== undefined && object.sayUserFeedbackPayload !== null
				? SayUserFeedbackPayload.fromPartial(object.sayUserFeedbackPayload)
				: undefined
		message.sayUserFeedbackDiffPayload =
			object.sayUserFeedbackDiffPayload !== undefined && object.sayUserFeedbackDiffPayload !== null
				? SayUserFeedbackDiffPayload.fromPartial(object.sayUserFeedbackDiffPayload)
				: undefined
		message.sayCommandPayload =
			object.sayCommandPayload !== undefined && object.sayCommandPayload !== null
				? SayCommandPayload.fromPartial(object.sayCommandPayload)
				: undefined
		message.sayCommandOutputPayload =
			object.sayCommandOutputPayload !== undefined && object.sayCommandOutputPayload !== null
				? SayCommandOutputPayload.fromPartial(object.sayCommandOutputPayload)
				: undefined
		message.sayToolPayload =
			object.sayToolPayload !== undefined && object.sayToolPayload !== null
				? SayToolPayload.fromPartial(object.sayToolPayload)
				: undefined
		message.sayShellIntegrationWarningPayload =
			object.sayShellIntegrationWarningPayload !== undefined && object.sayShellIntegrationWarningPayload !== null
				? SayShellIntegrationWarningPayload.fromPartial(object.sayShellIntegrationWarningPayload)
				: undefined
		message.sayBrowserActionLaunchPayload =
			object.sayBrowserActionLaunchPayload !== undefined && object.sayBrowserActionLaunchPayload !== null
				? SayBrowserActionLaunchPayload.fromPartial(object.sayBrowserActionLaunchPayload)
				: undefined
		message.sayBrowserActionPayload =
			object.sayBrowserActionPayload !== undefined && object.sayBrowserActionPayload !== null
				? SayBrowserActionPayload.fromPartial(object.sayBrowserActionPayload)
				: undefined
		message.sayBrowserActionResultPayload =
			object.sayBrowserActionResultPayload !== undefined && object.sayBrowserActionResultPayload !== null
				? SayBrowserActionResultPayload.fromPartial(object.sayBrowserActionResultPayload)
				: undefined
		message.sayMcpServerRequestStartedPayload =
			object.sayMcpServerRequestStartedPayload !== undefined && object.sayMcpServerRequestStartedPayload !== null
				? SayMcpServerRequestStartedPayload.fromPartial(object.sayMcpServerRequestStartedPayload)
				: undefined
		message.sayMcpServerResponsePayload =
			object.sayMcpServerResponsePayload !== undefined && object.sayMcpServerResponsePayload !== null
				? SayMcpServerResponsePayload.fromPartial(object.sayMcpServerResponsePayload)
				: undefined
		message.sayUseMcpServerPayload =
			object.sayUseMcpServerPayload !== undefined && object.sayUseMcpServerPayload !== null
				? SayUseMcpServerPayload.fromPartial(object.sayUseMcpServerPayload)
				: undefined
		message.sayDiffErrorPayload =
			object.sayDiffErrorPayload !== undefined && object.sayDiffErrorPayload !== null
				? SayDiffErrorPayload.fromPartial(object.sayDiffErrorPayload)
				: undefined
		message.sayDeletedApiReqsPayload =
			object.sayDeletedApiReqsPayload !== undefined && object.sayDeletedApiReqsPayload !== null
				? SayDeletedApiReqsPayload.fromPartial(object.sayDeletedApiReqsPayload)
				: undefined
		message.sayClineignoreErrorPayload =
			object.sayClineignoreErrorPayload !== undefined && object.sayClineignoreErrorPayload !== null
				? SayClineignoreErrorPayload.fromPartial(object.sayClineignoreErrorPayload)
				: undefined
		message.sayCheckpointCreatedPayload =
			object.sayCheckpointCreatedPayload !== undefined && object.sayCheckpointCreatedPayload !== null
				? SayCheckpointCreatedPayload.fromPartial(object.sayCheckpointCreatedPayload)
				: undefined
		message.sayLoadMcpDocumentationPayload =
			object.sayLoadMcpDocumentationPayload !== undefined && object.sayLoadMcpDocumentationPayload !== null
				? SayLoadMcpDocumentationPayload.fromPartial(object.sayLoadMcpDocumentationPayload)
				: undefined
		return message
	},
}

function createBaseExtensionState(): ExtensionState {
	return {
		apiConfiguration: undefined,
		autoApprovalSettings: undefined,
		browserSettings: undefined,
		remoteBrowserHost: undefined,
		chatSettings: undefined,
		checkpointTrackerErrorMessage: undefined,
		clineMessages: [],
		currentTaskItem: undefined,
		customInstructions: undefined,
		mcpMarketplaceEnabled: undefined,
		planActSeparateModelsSetting: false,
		platform: 0,
		shouldShowAnnouncement: false,
		taskHistory: [],
		telemetrySetting: 0,
		uriScheme: undefined,
		userInfo: undefined,
		version: "",
		vscMachineId: "",
		globalClineRulesToggles: undefined,
		localClineRulesToggles: undefined,
	}
}

export const ExtensionState: MessageFns<ExtensionState> = {
	encode(message: ExtensionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.apiConfiguration !== undefined) {
			ApiConfiguration.encode(message.apiConfiguration, writer.uint32(10).fork()).join()
		}
		if (message.autoApprovalSettings !== undefined) {
			AutoApprovalSettings.encode(message.autoApprovalSettings, writer.uint32(18).fork()).join()
		}
		if (message.browserSettings !== undefined) {
			BrowserSettings.encode(message.browserSettings, writer.uint32(26).fork()).join()
		}
		if (message.remoteBrowserHost !== undefined) {
			writer.uint32(34).string(message.remoteBrowserHost)
		}
		if (message.chatSettings !== undefined) {
			ChatSettings.encode(message.chatSettings, writer.uint32(42).fork()).join()
		}
		if (message.checkpointTrackerErrorMessage !== undefined) {
			writer.uint32(50).string(message.checkpointTrackerErrorMessage)
		}
		for (const v of message.clineMessages) {
			ClineMessage.encode(v!, writer.uint32(58).fork()).join()
		}
		if (message.currentTaskItem !== undefined) {
			HistoryItem.encode(message.currentTaskItem, writer.uint32(66).fork()).join()
		}
		if (message.customInstructions !== undefined) {
			writer.uint32(74).string(message.customInstructions)
		}
		if (message.mcpMarketplaceEnabled !== undefined) {
			writer.uint32(80).bool(message.mcpMarketplaceEnabled)
		}
		if (message.planActSeparateModelsSetting !== false) {
			writer.uint32(88).bool(message.planActSeparateModelsSetting)
		}
		if (message.platform !== 0) {
			writer.uint32(96).int32(message.platform)
		}
		if (message.shouldShowAnnouncement !== false) {
			writer.uint32(104).bool(message.shouldShowAnnouncement)
		}
		for (const v of message.taskHistory) {
			HistoryItem.encode(v!, writer.uint32(114).fork()).join()
		}
		if (message.telemetrySetting !== 0) {
			writer.uint32(120).int32(message.telemetrySetting)
		}
		if (message.uriScheme !== undefined) {
			writer.uint32(130).string(message.uriScheme)
		}
		if (message.userInfo !== undefined) {
			UserInfo.encode(message.userInfo, writer.uint32(138).fork()).join()
		}
		if (message.version !== "") {
			writer.uint32(146).string(message.version)
		}
		if (message.vscMachineId !== "") {
			writer.uint32(154).string(message.vscMachineId)
		}
		if (message.globalClineRulesToggles !== undefined) {
			ClineRulesToggles.encode(message.globalClineRulesToggles, writer.uint32(162).fork()).join()
		}
		if (message.localClineRulesToggles !== undefined) {
			ClineRulesToggles.encode(message.localClineRulesToggles, writer.uint32(170).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionState {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionState()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.apiConfiguration = ApiConfiguration.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.autoApprovalSettings = AutoApprovalSettings.decode(reader, reader.uint32())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.browserSettings = BrowserSettings.decode(reader, reader.uint32())
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.remoteBrowserHost = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.chatSettings = ChatSettings.decode(reader, reader.uint32())
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.checkpointTrackerErrorMessage = reader.string()
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.clineMessages.push(ClineMessage.decode(reader, reader.uint32()))
					continue
				}
				case 8: {
					if (tag !== 66) {
						break
					}

					message.currentTaskItem = HistoryItem.decode(reader, reader.uint32())
					continue
				}
				case 9: {
					if (tag !== 74) {
						break
					}

					message.customInstructions = reader.string()
					continue
				}
				case 10: {
					if (tag !== 80) {
						break
					}

					message.mcpMarketplaceEnabled = reader.bool()
					continue
				}
				case 11: {
					if (tag !== 88) {
						break
					}

					message.planActSeparateModelsSetting = reader.bool()
					continue
				}
				case 12: {
					if (tag !== 96) {
						break
					}

					message.platform = reader.int32() as any
					continue
				}
				case 13: {
					if (tag !== 104) {
						break
					}

					message.shouldShowAnnouncement = reader.bool()
					continue
				}
				case 14: {
					if (tag !== 114) {
						break
					}

					message.taskHistory.push(HistoryItem.decode(reader, reader.uint32()))
					continue
				}
				case 15: {
					if (tag !== 120) {
						break
					}

					message.telemetrySetting = reader.int32() as any
					continue
				}
				case 16: {
					if (tag !== 130) {
						break
					}

					message.uriScheme = reader.string()
					continue
				}
				case 17: {
					if (tag !== 138) {
						break
					}

					message.userInfo = UserInfo.decode(reader, reader.uint32())
					continue
				}
				case 18: {
					if (tag !== 146) {
						break
					}

					message.version = reader.string()
					continue
				}
				case 19: {
					if (tag !== 154) {
						break
					}

					message.vscMachineId = reader.string()
					continue
				}
				case 20: {
					if (tag !== 162) {
						break
					}

					message.globalClineRulesToggles = ClineRulesToggles.decode(reader, reader.uint32())
					continue
				}
				case 21: {
					if (tag !== 170) {
						break
					}

					message.localClineRulesToggles = ClineRulesToggles.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionState {
		return {
			apiConfiguration: isSet(object.apiConfiguration) ? ApiConfiguration.fromJSON(object.apiConfiguration) : undefined,
			autoApprovalSettings: isSet(object.autoApprovalSettings)
				? AutoApprovalSettings.fromJSON(object.autoApprovalSettings)
				: undefined,
			browserSettings: isSet(object.browserSettings) ? BrowserSettings.fromJSON(object.browserSettings) : undefined,
			remoteBrowserHost: isSet(object.remoteBrowserHost) ? globalThis.String(object.remoteBrowserHost) : undefined,
			chatSettings: isSet(object.chatSettings) ? ChatSettings.fromJSON(object.chatSettings) : undefined,
			checkpointTrackerErrorMessage: isSet(object.checkpointTrackerErrorMessage)
				? globalThis.String(object.checkpointTrackerErrorMessage)
				: undefined,
			clineMessages: globalThis.Array.isArray(object?.clineMessages)
				? object.clineMessages.map((e: any) => ClineMessage.fromJSON(e))
				: [],
			currentTaskItem: isSet(object.currentTaskItem) ? HistoryItem.fromJSON(object.currentTaskItem) : undefined,
			customInstructions: isSet(object.customInstructions) ? globalThis.String(object.customInstructions) : undefined,
			mcpMarketplaceEnabled: isSet(object.mcpMarketplaceEnabled)
				? globalThis.Boolean(object.mcpMarketplaceEnabled)
				: undefined,
			planActSeparateModelsSetting: isSet(object.planActSeparateModelsSetting)
				? globalThis.Boolean(object.planActSeparateModelsSetting)
				: false,
			platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
			shouldShowAnnouncement: isSet(object.shouldShowAnnouncement)
				? globalThis.Boolean(object.shouldShowAnnouncement)
				: false,
			taskHistory: globalThis.Array.isArray(object?.taskHistory)
				? object.taskHistory.map((e: any) => HistoryItem.fromJSON(e))
				: [],
			telemetrySetting: isSet(object.telemetrySetting) ? telemetrySettingValueFromJSON(object.telemetrySetting) : 0,
			uriScheme: isSet(object.uriScheme) ? globalThis.String(object.uriScheme) : undefined,
			userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
			version: isSet(object.version) ? globalThis.String(object.version) : "",
			vscMachineId: isSet(object.vscMachineId) ? globalThis.String(object.vscMachineId) : "",
			globalClineRulesToggles: isSet(object.globalClineRulesToggles)
				? ClineRulesToggles.fromJSON(object.globalClineRulesToggles)
				: undefined,
			localClineRulesToggles: isSet(object.localClineRulesToggles)
				? ClineRulesToggles.fromJSON(object.localClineRulesToggles)
				: undefined,
		}
	},

	toJSON(message: ExtensionState): unknown {
		const obj: any = {}
		if (message.apiConfiguration !== undefined) {
			obj.apiConfiguration = ApiConfiguration.toJSON(message.apiConfiguration)
		}
		if (message.autoApprovalSettings !== undefined) {
			obj.autoApprovalSettings = AutoApprovalSettings.toJSON(message.autoApprovalSettings)
		}
		if (message.browserSettings !== undefined) {
			obj.browserSettings = BrowserSettings.toJSON(message.browserSettings)
		}
		if (message.remoteBrowserHost !== undefined) {
			obj.remoteBrowserHost = message.remoteBrowserHost
		}
		if (message.chatSettings !== undefined) {
			obj.chatSettings = ChatSettings.toJSON(message.chatSettings)
		}
		if (message.checkpointTrackerErrorMessage !== undefined) {
			obj.checkpointTrackerErrorMessage = message.checkpointTrackerErrorMessage
		}
		if (message.clineMessages?.length) {
			obj.clineMessages = message.clineMessages.map((e) => ClineMessage.toJSON(e))
		}
		if (message.currentTaskItem !== undefined) {
			obj.currentTaskItem = HistoryItem.toJSON(message.currentTaskItem)
		}
		if (message.customInstructions !== undefined) {
			obj.customInstructions = message.customInstructions
		}
		if (message.mcpMarketplaceEnabled !== undefined) {
			obj.mcpMarketplaceEnabled = message.mcpMarketplaceEnabled
		}
		if (message.planActSeparateModelsSetting !== false) {
			obj.planActSeparateModelsSetting = message.planActSeparateModelsSetting
		}
		if (message.platform !== 0) {
			obj.platform = platformToJSON(message.platform)
		}
		if (message.shouldShowAnnouncement !== false) {
			obj.shouldShowAnnouncement = message.shouldShowAnnouncement
		}
		if (message.taskHistory?.length) {
			obj.taskHistory = message.taskHistory.map((e) => HistoryItem.toJSON(e))
		}
		if (message.telemetrySetting !== 0) {
			obj.telemetrySetting = telemetrySettingValueToJSON(message.telemetrySetting)
		}
		if (message.uriScheme !== undefined) {
			obj.uriScheme = message.uriScheme
		}
		if (message.userInfo !== undefined) {
			obj.userInfo = UserInfo.toJSON(message.userInfo)
		}
		if (message.version !== "") {
			obj.version = message.version
		}
		if (message.vscMachineId !== "") {
			obj.vscMachineId = message.vscMachineId
		}
		if (message.globalClineRulesToggles !== undefined) {
			obj.globalClineRulesToggles = ClineRulesToggles.toJSON(message.globalClineRulesToggles)
		}
		if (message.localClineRulesToggles !== undefined) {
			obj.localClineRulesToggles = ClineRulesToggles.toJSON(message.localClineRulesToggles)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionState>, I>>(base?: I): ExtensionState {
		return ExtensionState.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionState>, I>>(object: I): ExtensionState {
		const message = createBaseExtensionState()
		message.apiConfiguration =
			object.apiConfiguration !== undefined && object.apiConfiguration !== null
				? ApiConfiguration.fromPartial(object.apiConfiguration)
				: undefined
		message.autoApprovalSettings =
			object.autoApprovalSettings !== undefined && object.autoApprovalSettings !== null
				? AutoApprovalSettings.fromPartial(object.autoApprovalSettings)
				: undefined
		message.browserSettings =
			object.browserSettings !== undefined && object.browserSettings !== null
				? BrowserSettings.fromPartial(object.browserSettings)
				: undefined
		message.remoteBrowserHost = object.remoteBrowserHost ?? undefined
		message.chatSettings =
			object.chatSettings !== undefined && object.chatSettings !== null
				? ChatSettings.fromPartial(object.chatSettings)
				: undefined
		message.checkpointTrackerErrorMessage = object.checkpointTrackerErrorMessage ?? undefined
		message.clineMessages = object.clineMessages?.map((e) => ClineMessage.fromPartial(e)) || []
		message.currentTaskItem =
			object.currentTaskItem !== undefined && object.currentTaskItem !== null
				? HistoryItem.fromPartial(object.currentTaskItem)
				: undefined
		message.customInstructions = object.customInstructions ?? undefined
		message.mcpMarketplaceEnabled = object.mcpMarketplaceEnabled ?? undefined
		message.planActSeparateModelsSetting = object.planActSeparateModelsSetting ?? false
		message.platform = object.platform ?? 0
		message.shouldShowAnnouncement = object.shouldShowAnnouncement ?? false
		message.taskHistory = object.taskHistory?.map((e) => HistoryItem.fromPartial(e)) || []
		message.telemetrySetting = object.telemetrySetting ?? 0
		message.uriScheme = object.uriScheme ?? undefined
		message.userInfo =
			object.userInfo !== undefined && object.userInfo !== null ? UserInfo.fromPartial(object.userInfo) : undefined
		message.version = object.version ?? ""
		message.vscMachineId = object.vscMachineId ?? ""
		message.globalClineRulesToggles =
			object.globalClineRulesToggles !== undefined && object.globalClineRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.globalClineRulesToggles)
				: undefined
		message.localClineRulesToggles =
			object.localClineRulesToggles !== undefined && object.localClineRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.localClineRulesToggles)
				: undefined
		return message
	},
}

function createBaseTaskStartedInfo(): TaskStartedInfo {
	return { taskId: "", version: "" }
}

export const TaskStartedInfo: MessageFns<TaskStartedInfo> = {
	encode(message: TaskStartedInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.taskId !== "") {
			writer.uint32(10).string(message.taskId)
		}
		if (message.version !== "") {
			writer.uint32(18).string(message.version)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): TaskStartedInfo {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseTaskStartedInfo()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.taskId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.version = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): TaskStartedInfo {
		return {
			taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
			version: isSet(object.version) ? globalThis.String(object.version) : "",
		}
	},

	toJSON(message: TaskStartedInfo): unknown {
		const obj: any = {}
		if (message.taskId !== "") {
			obj.taskId = message.taskId
		}
		if (message.version !== "") {
			obj.version = message.version
		}
		return obj
	},

	create<I extends Exact<DeepPartial<TaskStartedInfo>, I>>(base?: I): TaskStartedInfo {
		return TaskStartedInfo.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<TaskStartedInfo>, I>>(object: I): TaskStartedInfo {
		const message = createBaseTaskStartedInfo()
		message.taskId = object.taskId ?? ""
		message.version = object.version ?? ""
		return message
	},
}

function createBaseExtensionMessage(): ExtensionMessage {
	return {
		type: 0,
		genericText: undefined,
		errorMessage: undefined,
		taskStarted: undefined,
		state: undefined,
		partialMessage: undefined,
		textMessage: undefined,
		toolUse: undefined,
		toolResult: undefined,
		selectedImages: undefined,
		ollamaModels: undefined,
		lmStudioModels: undefined,
		invoke: undefined,
		openRouterModels: undefined,
		openAiModels: undefined,
		requestyModels: undefined,
		mcpServers: undefined,
		vsCodeLmModels: undefined,
		authCallbackCustomToken: undefined,
		mcpMarketplaceCatalog: undefined,
		mcpDownloadDetails: undefined,
		commitSearchResults: undefined,
		openGraphData: undefined,
		isImageUrlResult: undefined,
		addRemoteServerResult: undefined,
		userCreditsBalance: undefined,
		userCreditsUsage: undefined,
		userCreditsPayments: undefined,
		totalTasksSize: undefined,
		browserConnectionResult: undefined,
		browserRelaunchResult: undefined,
		relativePathsResponse: undefined,
		fileSearchResults: undefined,
		grpcResponse: undefined,
		newChatMessage: undefined,
	}
}

export const ExtensionMessage: MessageFns<ExtensionMessage> = {
	encode(message: ExtensionMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.type !== 0) {
			writer.uint32(8).int32(message.type)
		}
		if (message.genericText !== undefined) {
			writer.uint32(18).string(message.genericText)
		}
		if (message.errorMessage !== undefined) {
			writer.uint32(26).string(message.errorMessage)
		}
		if (message.taskStarted !== undefined) {
			TaskStartedInfo.encode(message.taskStarted, writer.uint32(306).fork()).join()
		}
		if (message.state !== undefined) {
			ExtensionState.encode(message.state, writer.uint32(34).fork()).join()
		}
		if (message.partialMessage !== undefined) {
			ClineMessage.encode(message.partialMessage, writer.uint32(42).fork()).join()
		}
		if (message.textMessage !== undefined) {
			ClineMessage.encode(message.textMessage, writer.uint32(50).fork()).join()
		}
		if (message.toolUse !== undefined) {
			ToolUseBlock.encode(message.toolUse, writer.uint32(58).fork()).join()
		}
		if (message.toolResult !== undefined) {
			ToolResultBlock.encode(message.toolResult, writer.uint32(66).fork()).join()
		}
		if (message.selectedImages !== undefined) {
			ExtensionMessage_RepeatedStringWrapper.encode(message.selectedImages, writer.uint32(74).fork()).join()
		}
		if (message.ollamaModels !== undefined) {
			ExtensionMessage_RepeatedStringWrapper.encode(message.ollamaModels, writer.uint32(82).fork()).join()
		}
		if (message.lmStudioModels !== undefined) {
			ExtensionMessage_RepeatedStringWrapper.encode(message.lmStudioModels, writer.uint32(90).fork()).join()
		}
		if (message.invoke !== undefined) {
			writer.uint32(104).int32(message.invoke)
		}
		if (message.openRouterModels !== undefined) {
			ExtensionMessage_OpenRouterModelsWrapper.encode(message.openRouterModels, writer.uint32(114).fork()).join()
		}
		if (message.openAiModels !== undefined) {
			ExtensionMessage_RepeatedStringWrapper.encode(message.openAiModels, writer.uint32(122).fork()).join()
		}
		if (message.requestyModels !== undefined) {
			ExtensionMessage_RequestyModelsWrapper.encode(message.requestyModels, writer.uint32(130).fork()).join()
		}
		if (message.mcpServers !== undefined) {
			ExtensionMessage_McpServerListWrapper.encode(message.mcpServers, writer.uint32(138).fork()).join()
		}
		if (message.vsCodeLmModels !== undefined) {
			ExtensionMessage_VsCodeLmModelListWrapper.encode(message.vsCodeLmModels, writer.uint32(146).fork()).join()
		}
		if (message.authCallbackCustomToken !== undefined) {
			writer.uint32(154).string(message.authCallbackCustomToken)
		}
		if (message.mcpMarketplaceCatalog !== undefined) {
			McpMarketplaceCatalog.encode(message.mcpMarketplaceCatalog, writer.uint32(162).fork()).join()
		}
		if (message.mcpDownloadDetails !== undefined) {
			McpDownloadResponse.encode(message.mcpDownloadDetails, writer.uint32(170).fork()).join()
		}
		if (message.commitSearchResults !== undefined) {
			ExtensionMessage_GitCommitListWrapper.encode(message.commitSearchResults, writer.uint32(178).fork()).join()
		}
		if (message.openGraphData !== undefined) {
			OpenGraphData.encode(message.openGraphData, writer.uint32(186).fork()).join()
		}
		if (message.isImageUrlResult !== undefined) {
			writer.uint32(192).bool(message.isImageUrlResult)
		}
		if (message.addRemoteServerResult !== undefined) {
			AddRemoteServerResult.encode(message.addRemoteServerResult, writer.uint32(202).fork()).join()
		}
		if (message.userCreditsBalance !== undefined) {
			BalanceResponse.encode(message.userCreditsBalance, writer.uint32(210).fork()).join()
		}
		if (message.userCreditsUsage !== undefined) {
			ExtensionMessage_UsageTransactionListWrapper.encode(message.userCreditsUsage, writer.uint32(218).fork()).join()
		}
		if (message.userCreditsPayments !== undefined) {
			ExtensionMessage_PaymentTransactionListWrapper.encode(message.userCreditsPayments, writer.uint32(226).fork()).join()
		}
		if (message.totalTasksSize !== undefined) {
			writer.uint32(232).int64(message.totalTasksSize)
		}
		if (message.browserConnectionResult !== undefined) {
			BrowserConnectionResult.encode(message.browserConnectionResult, writer.uint32(250).fork()).join()
		}
		if (message.browserRelaunchResult !== undefined) {
			BrowserRelaunchResult.encode(message.browserRelaunchResult, writer.uint32(274).fork()).join()
		}
		if (message.relativePathsResponse !== undefined) {
			RelativePathsResponsePayload.encode(message.relativePathsResponse, writer.uint32(282).fork()).join()
		}
		if (message.fileSearchResults !== undefined) {
			ExtensionMessage_FileSearchResultListWrapper.encode(message.fileSearchResults, writer.uint32(290).fork()).join()
		}
		if (message.grpcResponse !== undefined) {
			GrpcResponse.encode(message.grpcResponse, writer.uint32(298).fork()).join()
		}
		if (message.newChatMessage !== undefined) {
			ClineMessage.encode(message.newChatMessage, writer.uint32(322).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.type = reader.int32() as any
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.genericText = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.errorMessage = reader.string()
					continue
				}
				case 38: {
					if (tag !== 306) {
						break
					}

					message.taskStarted = TaskStartedInfo.decode(reader, reader.uint32())
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.state = ExtensionState.decode(reader, reader.uint32())
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.partialMessage = ClineMessage.decode(reader, reader.uint32())
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.textMessage = ClineMessage.decode(reader, reader.uint32())
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.toolUse = ToolUseBlock.decode(reader, reader.uint32())
					continue
				}
				case 8: {
					if (tag !== 66) {
						break
					}

					message.toolResult = ToolResultBlock.decode(reader, reader.uint32())
					continue
				}
				case 9: {
					if (tag !== 74) {
						break
					}

					message.selectedImages = ExtensionMessage_RepeatedStringWrapper.decode(reader, reader.uint32())
					continue
				}
				case 10: {
					if (tag !== 82) {
						break
					}

					message.ollamaModels = ExtensionMessage_RepeatedStringWrapper.decode(reader, reader.uint32())
					continue
				}
				case 11: {
					if (tag !== 90) {
						break
					}

					message.lmStudioModels = ExtensionMessage_RepeatedStringWrapper.decode(reader, reader.uint32())
					continue
				}
				case 13: {
					if (tag !== 104) {
						break
					}

					message.invoke = reader.int32() as any
					continue
				}
				case 14: {
					if (tag !== 114) {
						break
					}

					message.openRouterModels = ExtensionMessage_OpenRouterModelsWrapper.decode(reader, reader.uint32())
					continue
				}
				case 15: {
					if (tag !== 122) {
						break
					}

					message.openAiModels = ExtensionMessage_RepeatedStringWrapper.decode(reader, reader.uint32())
					continue
				}
				case 16: {
					if (tag !== 130) {
						break
					}

					message.requestyModels = ExtensionMessage_RequestyModelsWrapper.decode(reader, reader.uint32())
					continue
				}
				case 17: {
					if (tag !== 138) {
						break
					}

					message.mcpServers = ExtensionMessage_McpServerListWrapper.decode(reader, reader.uint32())
					continue
				}
				case 18: {
					if (tag !== 146) {
						break
					}

					message.vsCodeLmModels = ExtensionMessage_VsCodeLmModelListWrapper.decode(reader, reader.uint32())
					continue
				}
				case 19: {
					if (tag !== 154) {
						break
					}

					message.authCallbackCustomToken = reader.string()
					continue
				}
				case 20: {
					if (tag !== 162) {
						break
					}

					message.mcpMarketplaceCatalog = McpMarketplaceCatalog.decode(reader, reader.uint32())
					continue
				}
				case 21: {
					if (tag !== 170) {
						break
					}

					message.mcpDownloadDetails = McpDownloadResponse.decode(reader, reader.uint32())
					continue
				}
				case 22: {
					if (tag !== 178) {
						break
					}

					message.commitSearchResults = ExtensionMessage_GitCommitListWrapper.decode(reader, reader.uint32())
					continue
				}
				case 23: {
					if (tag !== 186) {
						break
					}

					message.openGraphData = OpenGraphData.decode(reader, reader.uint32())
					continue
				}
				case 24: {
					if (tag !== 192) {
						break
					}

					message.isImageUrlResult = reader.bool()
					continue
				}
				case 25: {
					if (tag !== 202) {
						break
					}

					message.addRemoteServerResult = AddRemoteServerResult.decode(reader, reader.uint32())
					continue
				}
				case 26: {
					if (tag !== 210) {
						break
					}

					message.userCreditsBalance = BalanceResponse.decode(reader, reader.uint32())
					continue
				}
				case 27: {
					if (tag !== 218) {
						break
					}

					message.userCreditsUsage = ExtensionMessage_UsageTransactionListWrapper.decode(reader, reader.uint32())
					continue
				}
				case 28: {
					if (tag !== 226) {
						break
					}

					message.userCreditsPayments = ExtensionMessage_PaymentTransactionListWrapper.decode(reader, reader.uint32())
					continue
				}
				case 29: {
					if (tag !== 232) {
						break
					}

					message.totalTasksSize = longToNumber(reader.int64())
					continue
				}
				case 31: {
					if (tag !== 250) {
						break
					}

					message.browserConnectionResult = BrowserConnectionResult.decode(reader, reader.uint32())
					continue
				}
				case 34: {
					if (tag !== 274) {
						break
					}

					message.browserRelaunchResult = BrowserRelaunchResult.decode(reader, reader.uint32())
					continue
				}
				case 35: {
					if (tag !== 282) {
						break
					}

					message.relativePathsResponse = RelativePathsResponsePayload.decode(reader, reader.uint32())
					continue
				}
				case 36: {
					if (tag !== 290) {
						break
					}

					message.fileSearchResults = ExtensionMessage_FileSearchResultListWrapper.decode(reader, reader.uint32())
					continue
				}
				case 37: {
					if (tag !== 298) {
						break
					}

					message.grpcResponse = GrpcResponse.decode(reader, reader.uint32())
					continue
				}
				case 40: {
					if (tag !== 322) {
						break
					}

					message.newChatMessage = ClineMessage.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage {
		return {
			type: isSet(object.type) ? extensionMessageTypeFromJSON(object.type) : 0,
			genericText: isSet(object.genericText) ? globalThis.String(object.genericText) : undefined,
			errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
			taskStarted: isSet(object.taskStarted) ? TaskStartedInfo.fromJSON(object.taskStarted) : undefined,
			state: isSet(object.state) ? ExtensionState.fromJSON(object.state) : undefined,
			partialMessage: isSet(object.partialMessage) ? ClineMessage.fromJSON(object.partialMessage) : undefined,
			textMessage: isSet(object.textMessage) ? ClineMessage.fromJSON(object.textMessage) : undefined,
			toolUse: isSet(object.toolUse) ? ToolUseBlock.fromJSON(object.toolUse) : undefined,
			toolResult: isSet(object.toolResult) ? ToolResultBlock.fromJSON(object.toolResult) : undefined,
			selectedImages: isSet(object.selectedImages)
				? ExtensionMessage_RepeatedStringWrapper.fromJSON(object.selectedImages)
				: undefined,
			ollamaModels: isSet(object.ollamaModels)
				? ExtensionMessage_RepeatedStringWrapper.fromJSON(object.ollamaModels)
				: undefined,
			lmStudioModels: isSet(object.lmStudioModels)
				? ExtensionMessage_RepeatedStringWrapper.fromJSON(object.lmStudioModels)
				: undefined,
			invoke: isSet(object.invoke) ? invokeTypeFromJSON(object.invoke) : undefined,
			openRouterModels: isSet(object.openRouterModels)
				? ExtensionMessage_OpenRouterModelsWrapper.fromJSON(object.openRouterModels)
				: undefined,
			openAiModels: isSet(object.openAiModels)
				? ExtensionMessage_RepeatedStringWrapper.fromJSON(object.openAiModels)
				: undefined,
			requestyModels: isSet(object.requestyModels)
				? ExtensionMessage_RequestyModelsWrapper.fromJSON(object.requestyModels)
				: undefined,
			mcpServers: isSet(object.mcpServers) ? ExtensionMessage_McpServerListWrapper.fromJSON(object.mcpServers) : undefined,
			vsCodeLmModels: isSet(object.vsCodeLmModels)
				? ExtensionMessage_VsCodeLmModelListWrapper.fromJSON(object.vsCodeLmModels)
				: undefined,
			authCallbackCustomToken: isSet(object.authCallbackCustomToken)
				? globalThis.String(object.authCallbackCustomToken)
				: undefined,
			mcpMarketplaceCatalog: isSet(object.mcpMarketplaceCatalog)
				? McpMarketplaceCatalog.fromJSON(object.mcpMarketplaceCatalog)
				: undefined,
			mcpDownloadDetails: isSet(object.mcpDownloadDetails)
				? McpDownloadResponse.fromJSON(object.mcpDownloadDetails)
				: undefined,
			commitSearchResults: isSet(object.commitSearchResults)
				? ExtensionMessage_GitCommitListWrapper.fromJSON(object.commitSearchResults)
				: undefined,
			openGraphData: isSet(object.openGraphData) ? OpenGraphData.fromJSON(object.openGraphData) : undefined,
			isImageUrlResult: isSet(object.isImageUrlResult) ? globalThis.Boolean(object.isImageUrlResult) : undefined,
			addRemoteServerResult: isSet(object.addRemoteServerResult)
				? AddRemoteServerResult.fromJSON(object.addRemoteServerResult)
				: undefined,
			userCreditsBalance: isSet(object.userCreditsBalance)
				? BalanceResponse.fromJSON(object.userCreditsBalance)
				: undefined,
			userCreditsUsage: isSet(object.userCreditsUsage)
				? ExtensionMessage_UsageTransactionListWrapper.fromJSON(object.userCreditsUsage)
				: undefined,
			userCreditsPayments: isSet(object.userCreditsPayments)
				? ExtensionMessage_PaymentTransactionListWrapper.fromJSON(object.userCreditsPayments)
				: undefined,
			totalTasksSize: isSet(object.totalTasksSize) ? globalThis.Number(object.totalTasksSize) : undefined,
			browserConnectionResult: isSet(object.browserConnectionResult)
				? BrowserConnectionResult.fromJSON(object.browserConnectionResult)
				: undefined,
			browserRelaunchResult: isSet(object.browserRelaunchResult)
				? BrowserRelaunchResult.fromJSON(object.browserRelaunchResult)
				: undefined,
			relativePathsResponse: isSet(object.relativePathsResponse)
				? RelativePathsResponsePayload.fromJSON(object.relativePathsResponse)
				: undefined,
			fileSearchResults: isSet(object.fileSearchResults)
				? ExtensionMessage_FileSearchResultListWrapper.fromJSON(object.fileSearchResults)
				: undefined,
			grpcResponse: isSet(object.grpcResponse) ? GrpcResponse.fromJSON(object.grpcResponse) : undefined,
			newChatMessage: isSet(object.newChatMessage) ? ClineMessage.fromJSON(object.newChatMessage) : undefined,
		}
	},

	toJSON(message: ExtensionMessage): unknown {
		const obj: any = {}
		if (message.type !== 0) {
			obj.type = extensionMessageTypeToJSON(message.type)
		}
		if (message.genericText !== undefined) {
			obj.genericText = message.genericText
		}
		if (message.errorMessage !== undefined) {
			obj.errorMessage = message.errorMessage
		}
		if (message.taskStarted !== undefined) {
			obj.taskStarted = TaskStartedInfo.toJSON(message.taskStarted)
		}
		if (message.state !== undefined) {
			obj.state = ExtensionState.toJSON(message.state)
		}
		if (message.partialMessage !== undefined) {
			obj.partialMessage = ClineMessage.toJSON(message.partialMessage)
		}
		if (message.textMessage !== undefined) {
			obj.textMessage = ClineMessage.toJSON(message.textMessage)
		}
		if (message.toolUse !== undefined) {
			obj.toolUse = ToolUseBlock.toJSON(message.toolUse)
		}
		if (message.toolResult !== undefined) {
			obj.toolResult = ToolResultBlock.toJSON(message.toolResult)
		}
		if (message.selectedImages !== undefined) {
			obj.selectedImages = ExtensionMessage_RepeatedStringWrapper.toJSON(message.selectedImages)
		}
		if (message.ollamaModels !== undefined) {
			obj.ollamaModels = ExtensionMessage_RepeatedStringWrapper.toJSON(message.ollamaModels)
		}
		if (message.lmStudioModels !== undefined) {
			obj.lmStudioModels = ExtensionMessage_RepeatedStringWrapper.toJSON(message.lmStudioModels)
		}
		if (message.invoke !== undefined) {
			obj.invoke = invokeTypeToJSON(message.invoke)
		}
		if (message.openRouterModels !== undefined) {
			obj.openRouterModels = ExtensionMessage_OpenRouterModelsWrapper.toJSON(message.openRouterModels)
		}
		if (message.openAiModels !== undefined) {
			obj.openAiModels = ExtensionMessage_RepeatedStringWrapper.toJSON(message.openAiModels)
		}
		if (message.requestyModels !== undefined) {
			obj.requestyModels = ExtensionMessage_RequestyModelsWrapper.toJSON(message.requestyModels)
		}
		if (message.mcpServers !== undefined) {
			obj.mcpServers = ExtensionMessage_McpServerListWrapper.toJSON(message.mcpServers)
		}
		if (message.vsCodeLmModels !== undefined) {
			obj.vsCodeLmModels = ExtensionMessage_VsCodeLmModelListWrapper.toJSON(message.vsCodeLmModels)
		}
		if (message.authCallbackCustomToken !== undefined) {
			obj.authCallbackCustomToken = message.authCallbackCustomToken
		}
		if (message.mcpMarketplaceCatalog !== undefined) {
			obj.mcpMarketplaceCatalog = McpMarketplaceCatalog.toJSON(message.mcpMarketplaceCatalog)
		}
		if (message.mcpDownloadDetails !== undefined) {
			obj.mcpDownloadDetails = McpDownloadResponse.toJSON(message.mcpDownloadDetails)
		}
		if (message.commitSearchResults !== undefined) {
			obj.commitSearchResults = ExtensionMessage_GitCommitListWrapper.toJSON(message.commitSearchResults)
		}
		if (message.openGraphData !== undefined) {
			obj.openGraphData = OpenGraphData.toJSON(message.openGraphData)
		}
		if (message.isImageUrlResult !== undefined) {
			obj.isImageUrlResult = message.isImageUrlResult
		}
		if (message.addRemoteServerResult !== undefined) {
			obj.addRemoteServerResult = AddRemoteServerResult.toJSON(message.addRemoteServerResult)
		}
		if (message.userCreditsBalance !== undefined) {
			obj.userCreditsBalance = BalanceResponse.toJSON(message.userCreditsBalance)
		}
		if (message.userCreditsUsage !== undefined) {
			obj.userCreditsUsage = ExtensionMessage_UsageTransactionListWrapper.toJSON(message.userCreditsUsage)
		}
		if (message.userCreditsPayments !== undefined) {
			obj.userCreditsPayments = ExtensionMessage_PaymentTransactionListWrapper.toJSON(message.userCreditsPayments)
		}
		if (message.totalTasksSize !== undefined) {
			obj.totalTasksSize = Math.round(message.totalTasksSize)
		}
		if (message.browserConnectionResult !== undefined) {
			obj.browserConnectionResult = BrowserConnectionResult.toJSON(message.browserConnectionResult)
		}
		if (message.browserRelaunchResult !== undefined) {
			obj.browserRelaunchResult = BrowserRelaunchResult.toJSON(message.browserRelaunchResult)
		}
		if (message.relativePathsResponse !== undefined) {
			obj.relativePathsResponse = RelativePathsResponsePayload.toJSON(message.relativePathsResponse)
		}
		if (message.fileSearchResults !== undefined) {
			obj.fileSearchResults = ExtensionMessage_FileSearchResultListWrapper.toJSON(message.fileSearchResults)
		}
		if (message.grpcResponse !== undefined) {
			obj.grpcResponse = GrpcResponse.toJSON(message.grpcResponse)
		}
		if (message.newChatMessage !== undefined) {
			obj.newChatMessage = ClineMessage.toJSON(message.newChatMessage)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage>, I>>(base?: I): ExtensionMessage {
		return ExtensionMessage.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage>, I>>(object: I): ExtensionMessage {
		const message = createBaseExtensionMessage()
		message.type = object.type ?? 0
		message.genericText = object.genericText ?? undefined
		message.errorMessage = object.errorMessage ?? undefined
		message.taskStarted =
			object.taskStarted !== undefined && object.taskStarted !== null
				? TaskStartedInfo.fromPartial(object.taskStarted)
				: undefined
		message.state = object.state !== undefined && object.state !== null ? ExtensionState.fromPartial(object.state) : undefined
		message.partialMessage =
			object.partialMessage !== undefined && object.partialMessage !== null
				? ClineMessage.fromPartial(object.partialMessage)
				: undefined
		message.textMessage =
			object.textMessage !== undefined && object.textMessage !== null
				? ClineMessage.fromPartial(object.textMessage)
				: undefined
		message.toolUse =
			object.toolUse !== undefined && object.toolUse !== null ? ToolUseBlock.fromPartial(object.toolUse) : undefined
		message.toolResult =
			object.toolResult !== undefined && object.toolResult !== null
				? ToolResultBlock.fromPartial(object.toolResult)
				: undefined
		message.selectedImages =
			object.selectedImages !== undefined && object.selectedImages !== null
				? ExtensionMessage_RepeatedStringWrapper.fromPartial(object.selectedImages)
				: undefined
		message.ollamaModels =
			object.ollamaModels !== undefined && object.ollamaModels !== null
				? ExtensionMessage_RepeatedStringWrapper.fromPartial(object.ollamaModels)
				: undefined
		message.lmStudioModels =
			object.lmStudioModels !== undefined && object.lmStudioModels !== null
				? ExtensionMessage_RepeatedStringWrapper.fromPartial(object.lmStudioModels)
				: undefined
		message.invoke = object.invoke ?? undefined
		message.openRouterModels =
			object.openRouterModels !== undefined && object.openRouterModels !== null
				? ExtensionMessage_OpenRouterModelsWrapper.fromPartial(object.openRouterModels)
				: undefined
		message.openAiModels =
			object.openAiModels !== undefined && object.openAiModels !== null
				? ExtensionMessage_RepeatedStringWrapper.fromPartial(object.openAiModels)
				: undefined
		message.requestyModels =
			object.requestyModels !== undefined && object.requestyModels !== null
				? ExtensionMessage_RequestyModelsWrapper.fromPartial(object.requestyModels)
				: undefined
		message.mcpServers =
			object.mcpServers !== undefined && object.mcpServers !== null
				? ExtensionMessage_McpServerListWrapper.fromPartial(object.mcpServers)
				: undefined
		message.vsCodeLmModels =
			object.vsCodeLmModels !== undefined && object.vsCodeLmModels !== null
				? ExtensionMessage_VsCodeLmModelListWrapper.fromPartial(object.vsCodeLmModels)
				: undefined
		message.authCallbackCustomToken = object.authCallbackCustomToken ?? undefined
		message.mcpMarketplaceCatalog =
			object.mcpMarketplaceCatalog !== undefined && object.mcpMarketplaceCatalog !== null
				? McpMarketplaceCatalog.fromPartial(object.mcpMarketplaceCatalog)
				: undefined
		message.mcpDownloadDetails =
			object.mcpDownloadDetails !== undefined && object.mcpDownloadDetails !== null
				? McpDownloadResponse.fromPartial(object.mcpDownloadDetails)
				: undefined
		message.commitSearchResults =
			object.commitSearchResults !== undefined && object.commitSearchResults !== null
				? ExtensionMessage_GitCommitListWrapper.fromPartial(object.commitSearchResults)
				: undefined
		message.openGraphData =
			object.openGraphData !== undefined && object.openGraphData !== null
				? OpenGraphData.fromPartial(object.openGraphData)
				: undefined
		message.isImageUrlResult = object.isImageUrlResult ?? undefined
		message.addRemoteServerResult =
			object.addRemoteServerResult !== undefined && object.addRemoteServerResult !== null
				? AddRemoteServerResult.fromPartial(object.addRemoteServerResult)
				: undefined
		message.userCreditsBalance =
			object.userCreditsBalance !== undefined && object.userCreditsBalance !== null
				? BalanceResponse.fromPartial(object.userCreditsBalance)
				: undefined
		message.userCreditsUsage =
			object.userCreditsUsage !== undefined && object.userCreditsUsage !== null
				? ExtensionMessage_UsageTransactionListWrapper.fromPartial(object.userCreditsUsage)
				: undefined
		message.userCreditsPayments =
			object.userCreditsPayments !== undefined && object.userCreditsPayments !== null
				? ExtensionMessage_PaymentTransactionListWrapper.fromPartial(object.userCreditsPayments)
				: undefined
		message.totalTasksSize = object.totalTasksSize ?? undefined
		message.browserConnectionResult =
			object.browserConnectionResult !== undefined && object.browserConnectionResult !== null
				? BrowserConnectionResult.fromPartial(object.browserConnectionResult)
				: undefined
		message.browserRelaunchResult =
			object.browserRelaunchResult !== undefined && object.browserRelaunchResult !== null
				? BrowserRelaunchResult.fromPartial(object.browserRelaunchResult)
				: undefined
		message.relativePathsResponse =
			object.relativePathsResponse !== undefined && object.relativePathsResponse !== null
				? RelativePathsResponsePayload.fromPartial(object.relativePathsResponse)
				: undefined
		message.fileSearchResults =
			object.fileSearchResults !== undefined && object.fileSearchResults !== null
				? ExtensionMessage_FileSearchResultListWrapper.fromPartial(object.fileSearchResults)
				: undefined
		message.grpcResponse =
			object.grpcResponse !== undefined && object.grpcResponse !== null
				? GrpcResponse.fromPartial(object.grpcResponse)
				: undefined
		message.newChatMessage =
			object.newChatMessage !== undefined && object.newChatMessage !== null
				? ClineMessage.fromPartial(object.newChatMessage)
				: undefined
		return message
	},
}

function createBaseExtensionMessage_OpenRouterModelsWrapper(): ExtensionMessage_OpenRouterModelsWrapper {
	return { models: {} }
}

export const ExtensionMessage_OpenRouterModelsWrapper: MessageFns<ExtensionMessage_OpenRouterModelsWrapper> = {
	encode(message: ExtensionMessage_OpenRouterModelsWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		Object.entries(message.models).forEach(([key, value]) => {
			ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry.encode(
				{ key: key as any, value },
				writer.uint32(10).fork(),
			).join()
		})
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_OpenRouterModelsWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_OpenRouterModelsWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					const entry1 = ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry.decode(reader, reader.uint32())
					if (entry1.value !== undefined) {
						message.models[entry1.key] = entry1.value
					}
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_OpenRouterModelsWrapper {
		return {
			models: isObject(object.models)
				? Object.entries(object.models).reduce<{ [key: string]: ModelInfo }>((acc, [key, value]) => {
						acc[key] = ModelInfo.fromJSON(value)
						return acc
					}, {})
				: {},
		}
	},

	toJSON(message: ExtensionMessage_OpenRouterModelsWrapper): unknown {
		const obj: any = {}
		if (message.models) {
			const entries = Object.entries(message.models)
			if (entries.length > 0) {
				obj.models = {}
				entries.forEach(([k, v]) => {
					obj.models[k] = ModelInfo.toJSON(v)
				})
			}
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_OpenRouterModelsWrapper>, I>>(
		base?: I,
	): ExtensionMessage_OpenRouterModelsWrapper {
		return ExtensionMessage_OpenRouterModelsWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_OpenRouterModelsWrapper>, I>>(
		object: I,
	): ExtensionMessage_OpenRouterModelsWrapper {
		const message = createBaseExtensionMessage_OpenRouterModelsWrapper()
		message.models = Object.entries(object.models ?? {}).reduce<{ [key: string]: ModelInfo }>((acc, [key, value]) => {
			if (value !== undefined) {
				acc[key] = ModelInfo.fromPartial(value)
			}
			return acc
		}, {})
		return message
	},
}

function createBaseExtensionMessage_OpenRouterModelsWrapper_ModelsEntry(): ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry {
	return { key: "", value: undefined }
}

export const ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry: MessageFns<ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry> =
	{
		encode(
			message: ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key)
			}
			if (message.value !== undefined) {
				ModelInfo.encode(message.value, writer.uint32(18).fork()).join()
			}
			return writer
		},

		decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry {
			const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
			let end = length === undefined ? reader.len : reader.pos + length
			const message = createBaseExtensionMessage_OpenRouterModelsWrapper_ModelsEntry()
			while (reader.pos < end) {
				const tag = reader.uint32()
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break
						}

						message.key = reader.string()
						continue
					}
					case 2: {
						if (tag !== 18) {
							break
						}

						message.value = ModelInfo.decode(reader, reader.uint32())
						continue
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break
				}
				reader.skip(tag & 7)
			}
			return message
		},

		fromJSON(object: any): ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? ModelInfo.fromJSON(object.value) : undefined,
			}
		},

		toJSON(message: ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry): unknown {
			const obj: any = {}
			if (message.key !== "") {
				obj.key = message.key
			}
			if (message.value !== undefined) {
				obj.value = ModelInfo.toJSON(message.value)
			}
			return obj
		},

		create<I extends Exact<DeepPartial<ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry>, I>>(
			base?: I,
		): ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry {
			return ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry.fromPartial(base ?? ({} as any))
		},
		fromPartial<I extends Exact<DeepPartial<ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry>, I>>(
			object: I,
		): ExtensionMessage_OpenRouterModelsWrapper_ModelsEntry {
			const message = createBaseExtensionMessage_OpenRouterModelsWrapper_ModelsEntry()
			message.key = object.key ?? ""
			message.value = object.value !== undefined && object.value !== null ? ModelInfo.fromPartial(object.value) : undefined
			return message
		},
	}

function createBaseExtensionMessage_RequestyModelsWrapper(): ExtensionMessage_RequestyModelsWrapper {
	return { models: {} }
}

export const ExtensionMessage_RequestyModelsWrapper: MessageFns<ExtensionMessage_RequestyModelsWrapper> = {
	encode(message: ExtensionMessage_RequestyModelsWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		Object.entries(message.models).forEach(([key, value]) => {
			ExtensionMessage_RequestyModelsWrapper_ModelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join()
		})
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_RequestyModelsWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_RequestyModelsWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					const entry1 = ExtensionMessage_RequestyModelsWrapper_ModelsEntry.decode(reader, reader.uint32())
					if (entry1.value !== undefined) {
						message.models[entry1.key] = entry1.value
					}
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_RequestyModelsWrapper {
		return {
			models: isObject(object.models)
				? Object.entries(object.models).reduce<{ [key: string]: ModelInfo }>((acc, [key, value]) => {
						acc[key] = ModelInfo.fromJSON(value)
						return acc
					}, {})
				: {},
		}
	},

	toJSON(message: ExtensionMessage_RequestyModelsWrapper): unknown {
		const obj: any = {}
		if (message.models) {
			const entries = Object.entries(message.models)
			if (entries.length > 0) {
				obj.models = {}
				entries.forEach(([k, v]) => {
					obj.models[k] = ModelInfo.toJSON(v)
				})
			}
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_RequestyModelsWrapper>, I>>(
		base?: I,
	): ExtensionMessage_RequestyModelsWrapper {
		return ExtensionMessage_RequestyModelsWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_RequestyModelsWrapper>, I>>(
		object: I,
	): ExtensionMessage_RequestyModelsWrapper {
		const message = createBaseExtensionMessage_RequestyModelsWrapper()
		message.models = Object.entries(object.models ?? {}).reduce<{ [key: string]: ModelInfo }>((acc, [key, value]) => {
			if (value !== undefined) {
				acc[key] = ModelInfo.fromPartial(value)
			}
			return acc
		}, {})
		return message
	},
}

function createBaseExtensionMessage_RequestyModelsWrapper_ModelsEntry(): ExtensionMessage_RequestyModelsWrapper_ModelsEntry {
	return { key: "", value: undefined }
}

export const ExtensionMessage_RequestyModelsWrapper_ModelsEntry: MessageFns<ExtensionMessage_RequestyModelsWrapper_ModelsEntry> =
	{
		encode(
			message: ExtensionMessage_RequestyModelsWrapper_ModelsEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key)
			}
			if (message.value !== undefined) {
				ModelInfo.encode(message.value, writer.uint32(18).fork()).join()
			}
			return writer
		},

		decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_RequestyModelsWrapper_ModelsEntry {
			const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
			let end = length === undefined ? reader.len : reader.pos + length
			const message = createBaseExtensionMessage_RequestyModelsWrapper_ModelsEntry()
			while (reader.pos < end) {
				const tag = reader.uint32()
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break
						}

						message.key = reader.string()
						continue
					}
					case 2: {
						if (tag !== 18) {
							break
						}

						message.value = ModelInfo.decode(reader, reader.uint32())
						continue
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break
				}
				reader.skip(tag & 7)
			}
			return message
		},

		fromJSON(object: any): ExtensionMessage_RequestyModelsWrapper_ModelsEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? ModelInfo.fromJSON(object.value) : undefined,
			}
		},

		toJSON(message: ExtensionMessage_RequestyModelsWrapper_ModelsEntry): unknown {
			const obj: any = {}
			if (message.key !== "") {
				obj.key = message.key
			}
			if (message.value !== undefined) {
				obj.value = ModelInfo.toJSON(message.value)
			}
			return obj
		},

		create<I extends Exact<DeepPartial<ExtensionMessage_RequestyModelsWrapper_ModelsEntry>, I>>(
			base?: I,
		): ExtensionMessage_RequestyModelsWrapper_ModelsEntry {
			return ExtensionMessage_RequestyModelsWrapper_ModelsEntry.fromPartial(base ?? ({} as any))
		},
		fromPartial<I extends Exact<DeepPartial<ExtensionMessage_RequestyModelsWrapper_ModelsEntry>, I>>(
			object: I,
		): ExtensionMessage_RequestyModelsWrapper_ModelsEntry {
			const message = createBaseExtensionMessage_RequestyModelsWrapper_ModelsEntry()
			message.key = object.key ?? ""
			message.value = object.value !== undefined && object.value !== null ? ModelInfo.fromPartial(object.value) : undefined
			return message
		},
	}

function createBaseExtensionMessage_RepeatedStringWrapper(): ExtensionMessage_RepeatedStringWrapper {
	return { values: [] }
}

export const ExtensionMessage_RepeatedStringWrapper: MessageFns<ExtensionMessage_RepeatedStringWrapper> = {
	encode(message: ExtensionMessage_RepeatedStringWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.values) {
			writer.uint32(10).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_RepeatedStringWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_RepeatedStringWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.values.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_RepeatedStringWrapper {
		return {
			values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
		}
	},

	toJSON(message: ExtensionMessage_RepeatedStringWrapper): unknown {
		const obj: any = {}
		if (message.values?.length) {
			obj.values = message.values
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_RepeatedStringWrapper>, I>>(
		base?: I,
	): ExtensionMessage_RepeatedStringWrapper {
		return ExtensionMessage_RepeatedStringWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_RepeatedStringWrapper>, I>>(
		object: I,
	): ExtensionMessage_RepeatedStringWrapper {
		const message = createBaseExtensionMessage_RepeatedStringWrapper()
		message.values = object.values?.map((e) => e) || []
		return message
	},
}

function createBaseExtensionMessage_McpServerListWrapper(): ExtensionMessage_McpServerListWrapper {
	return { servers: [] }
}

export const ExtensionMessage_McpServerListWrapper: MessageFns<ExtensionMessage_McpServerListWrapper> = {
	encode(message: ExtensionMessage_McpServerListWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.servers) {
			McpServer.encode(v!, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_McpServerListWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_McpServerListWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.servers.push(McpServer.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_McpServerListWrapper {
		return {
			servers: globalThis.Array.isArray(object?.servers) ? object.servers.map((e: any) => McpServer.fromJSON(e)) : [],
		}
	},

	toJSON(message: ExtensionMessage_McpServerListWrapper): unknown {
		const obj: any = {}
		if (message.servers?.length) {
			obj.servers = message.servers.map((e) => McpServer.toJSON(e))
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_McpServerListWrapper>, I>>(
		base?: I,
	): ExtensionMessage_McpServerListWrapper {
		return ExtensionMessage_McpServerListWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_McpServerListWrapper>, I>>(
		object: I,
	): ExtensionMessage_McpServerListWrapper {
		const message = createBaseExtensionMessage_McpServerListWrapper()
		message.servers = object.servers?.map((e) => McpServer.fromPartial(e)) || []
		return message
	},
}

function createBaseExtensionMessage_VsCodeLmModelListWrapper(): ExtensionMessage_VsCodeLmModelListWrapper {
	return { models: [] }
}

export const ExtensionMessage_VsCodeLmModelListWrapper: MessageFns<ExtensionMessage_VsCodeLmModelListWrapper> = {
	encode(message: ExtensionMessage_VsCodeLmModelListWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.models) {
			VsCodeLmModel.encode(v!, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_VsCodeLmModelListWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_VsCodeLmModelListWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.models.push(VsCodeLmModel.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_VsCodeLmModelListWrapper {
		return {
			models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => VsCodeLmModel.fromJSON(e)) : [],
		}
	},

	toJSON(message: ExtensionMessage_VsCodeLmModelListWrapper): unknown {
		const obj: any = {}
		if (message.models?.length) {
			obj.models = message.models.map((e) => VsCodeLmModel.toJSON(e))
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_VsCodeLmModelListWrapper>, I>>(
		base?: I,
	): ExtensionMessage_VsCodeLmModelListWrapper {
		return ExtensionMessage_VsCodeLmModelListWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_VsCodeLmModelListWrapper>, I>>(
		object: I,
	): ExtensionMessage_VsCodeLmModelListWrapper {
		const message = createBaseExtensionMessage_VsCodeLmModelListWrapper()
		message.models = object.models?.map((e) => VsCodeLmModel.fromPartial(e)) || []
		return message
	},
}

function createBaseExtensionMessage_GitCommitListWrapper(): ExtensionMessage_GitCommitListWrapper {
	return { commits: [] }
}

export const ExtensionMessage_GitCommitListWrapper: MessageFns<ExtensionMessage_GitCommitListWrapper> = {
	encode(message: ExtensionMessage_GitCommitListWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.commits) {
			GitCommit.encode(v!, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_GitCommitListWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_GitCommitListWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.commits.push(GitCommit.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_GitCommitListWrapper {
		return {
			commits: globalThis.Array.isArray(object?.commits) ? object.commits.map((e: any) => GitCommit.fromJSON(e)) : [],
		}
	},

	toJSON(message: ExtensionMessage_GitCommitListWrapper): unknown {
		const obj: any = {}
		if (message.commits?.length) {
			obj.commits = message.commits.map((e) => GitCommit.toJSON(e))
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_GitCommitListWrapper>, I>>(
		base?: I,
	): ExtensionMessage_GitCommitListWrapper {
		return ExtensionMessage_GitCommitListWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_GitCommitListWrapper>, I>>(
		object: I,
	): ExtensionMessage_GitCommitListWrapper {
		const message = createBaseExtensionMessage_GitCommitListWrapper()
		message.commits = object.commits?.map((e) => GitCommit.fromPartial(e)) || []
		return message
	},
}

function createBaseExtensionMessage_UsageTransactionListWrapper(): ExtensionMessage_UsageTransactionListWrapper {
	return { transactions: [] }
}

export const ExtensionMessage_UsageTransactionListWrapper: MessageFns<ExtensionMessage_UsageTransactionListWrapper> = {
	encode(message: ExtensionMessage_UsageTransactionListWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.transactions) {
			UsageTransaction.encode(v!, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_UsageTransactionListWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_UsageTransactionListWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.transactions.push(UsageTransaction.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_UsageTransactionListWrapper {
		return {
			transactions: globalThis.Array.isArray(object?.transactions)
				? object.transactions.map((e: any) => UsageTransaction.fromJSON(e))
				: [],
		}
	},

	toJSON(message: ExtensionMessage_UsageTransactionListWrapper): unknown {
		const obj: any = {}
		if (message.transactions?.length) {
			obj.transactions = message.transactions.map((e) => UsageTransaction.toJSON(e))
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_UsageTransactionListWrapper>, I>>(
		base?: I,
	): ExtensionMessage_UsageTransactionListWrapper {
		return ExtensionMessage_UsageTransactionListWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_UsageTransactionListWrapper>, I>>(
		object: I,
	): ExtensionMessage_UsageTransactionListWrapper {
		const message = createBaseExtensionMessage_UsageTransactionListWrapper()
		message.transactions = object.transactions?.map((e) => UsageTransaction.fromPartial(e)) || []
		return message
	},
}

function createBaseExtensionMessage_PaymentTransactionListWrapper(): ExtensionMessage_PaymentTransactionListWrapper {
	return { transactions: [] }
}

export const ExtensionMessage_PaymentTransactionListWrapper: MessageFns<ExtensionMessage_PaymentTransactionListWrapper> = {
	encode(message: ExtensionMessage_PaymentTransactionListWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.transactions) {
			PaymentTransaction.encode(v!, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_PaymentTransactionListWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_PaymentTransactionListWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.transactions.push(PaymentTransaction.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_PaymentTransactionListWrapper {
		return {
			transactions: globalThis.Array.isArray(object?.transactions)
				? object.transactions.map((e: any) => PaymentTransaction.fromJSON(e))
				: [],
		}
	},

	toJSON(message: ExtensionMessage_PaymentTransactionListWrapper): unknown {
		const obj: any = {}
		if (message.transactions?.length) {
			obj.transactions = message.transactions.map((e) => PaymentTransaction.toJSON(e))
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_PaymentTransactionListWrapper>, I>>(
		base?: I,
	): ExtensionMessage_PaymentTransactionListWrapper {
		return ExtensionMessage_PaymentTransactionListWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_PaymentTransactionListWrapper>, I>>(
		object: I,
	): ExtensionMessage_PaymentTransactionListWrapper {
		const message = createBaseExtensionMessage_PaymentTransactionListWrapper()
		message.transactions = object.transactions?.map((e) => PaymentTransaction.fromPartial(e)) || []
		return message
	},
}

function createBaseExtensionMessage_FileSearchResultListWrapper(): ExtensionMessage_FileSearchResultListWrapper {
	return { results: [] }
}

export const ExtensionMessage_FileSearchResultListWrapper: MessageFns<ExtensionMessage_FileSearchResultListWrapper> = {
	encode(message: ExtensionMessage_FileSearchResultListWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.results) {
			FileSearchResult.encode(v!, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMessage_FileSearchResultListWrapper {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExtensionMessage_FileSearchResultListWrapper()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.results.push(FileSearchResult.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExtensionMessage_FileSearchResultListWrapper {
		return {
			results: globalThis.Array.isArray(object?.results)
				? object.results.map((e: any) => FileSearchResult.fromJSON(e))
				: [],
		}
	},

	toJSON(message: ExtensionMessage_FileSearchResultListWrapper): unknown {
		const obj: any = {}
		if (message.results?.length) {
			obj.results = message.results.map((e) => FileSearchResult.toJSON(e))
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExtensionMessage_FileSearchResultListWrapper>, I>>(
		base?: I,
	): ExtensionMessage_FileSearchResultListWrapper {
		return ExtensionMessage_FileSearchResultListWrapper.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExtensionMessage_FileSearchResultListWrapper>, I>>(
		object: I,
	): ExtensionMessage_FileSearchResultListWrapper {
		const message = createBaseExtensionMessage_FileSearchResultListWrapper()
		message.results = object.results?.map((e) => FileSearchResult.fromPartial(e)) || []
		return message
	},
}

function createBaseToolUseBlock(): ToolUseBlock {
	return { toolUseId: "", name: "", input: undefined }
}

export const ToolUseBlock: MessageFns<ToolUseBlock> = {
	encode(message: ToolUseBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.toolUseId !== "") {
			writer.uint32(10).string(message.toolUseId)
		}
		if (message.name !== "") {
			writer.uint32(18).string(message.name)
		}
		if (message.input !== undefined) {
			Value.encode(Value.wrap(message.input), writer.uint32(26).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ToolUseBlock {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseToolUseBlock()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.toolUseId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.name = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.input = Value.unwrap(Value.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ToolUseBlock {
		return {
			toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			input: isSet(object?.input) ? object.input : undefined,
		}
	},

	toJSON(message: ToolUseBlock): unknown {
		const obj: any = {}
		if (message.toolUseId !== "") {
			obj.toolUseId = message.toolUseId
		}
		if (message.name !== "") {
			obj.name = message.name
		}
		if (message.input !== undefined) {
			obj.input = message.input
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ToolUseBlock>, I>>(base?: I): ToolUseBlock {
		return ToolUseBlock.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ToolUseBlock>, I>>(object: I): ToolUseBlock {
		const message = createBaseToolUseBlock()
		message.toolUseId = object.toolUseId ?? ""
		message.name = object.name ?? ""
		message.input = object.input ?? undefined
		return message
	},
}

function createBaseToolResultBlock(): ToolResultBlock {
	return { toolUseId: "", textContent: undefined, jsonContent: undefined, isError: undefined }
}

export const ToolResultBlock: MessageFns<ToolResultBlock> = {
	encode(message: ToolResultBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.toolUseId !== "") {
			writer.uint32(10).string(message.toolUseId)
		}
		if (message.textContent !== undefined) {
			writer.uint32(18).string(message.textContent)
		}
		if (message.jsonContent !== undefined) {
			Value.encode(Value.wrap(message.jsonContent), writer.uint32(26).fork()).join()
		}
		if (message.isError !== undefined) {
			writer.uint32(32).bool(message.isError)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ToolResultBlock {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseToolResultBlock()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.toolUseId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.textContent = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.jsonContent = Value.unwrap(Value.decode(reader, reader.uint32()))
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.isError = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ToolResultBlock {
		return {
			toolUseId: isSet(object.toolUseId) ? globalThis.String(object.toolUseId) : "",
			textContent: isSet(object.textContent) ? globalThis.String(object.textContent) : undefined,
			jsonContent: isSet(object?.jsonContent) ? object.jsonContent : undefined,
			isError: isSet(object.isError) ? globalThis.Boolean(object.isError) : undefined,
		}
	},

	toJSON(message: ToolResultBlock): unknown {
		const obj: any = {}
		if (message.toolUseId !== "") {
			obj.toolUseId = message.toolUseId
		}
		if (message.textContent !== undefined) {
			obj.textContent = message.textContent
		}
		if (message.jsonContent !== undefined) {
			obj.jsonContent = message.jsonContent
		}
		if (message.isError !== undefined) {
			obj.isError = message.isError
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ToolResultBlock>, I>>(base?: I): ToolResultBlock {
		return ToolResultBlock.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ToolResultBlock>, I>>(object: I): ToolResultBlock {
		const message = createBaseToolResultBlock()
		message.toolUseId = object.toolUseId ?? ""
		message.textContent = object.textContent ?? undefined
		message.jsonContent = object.jsonContent ?? undefined
		message.isError = object.isError ?? undefined
		return message
	},
}

function createBaseVsCodeLmModel(): VsCodeLmModel {
	return { vendor: undefined, family: undefined, version: undefined, id: undefined }
}

export const VsCodeLmModel: MessageFns<VsCodeLmModel> = {
	encode(message: VsCodeLmModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.vendor !== undefined) {
			writer.uint32(10).string(message.vendor)
		}
		if (message.family !== undefined) {
			writer.uint32(18).string(message.family)
		}
		if (message.version !== undefined) {
			writer.uint32(26).string(message.version)
		}
		if (message.id !== undefined) {
			writer.uint32(34).string(message.id)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): VsCodeLmModel {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseVsCodeLmModel()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.vendor = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.family = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.version = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.id = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): VsCodeLmModel {
		return {
			vendor: isSet(object.vendor) ? globalThis.String(object.vendor) : undefined,
			family: isSet(object.family) ? globalThis.String(object.family) : undefined,
			version: isSet(object.version) ? globalThis.String(object.version) : undefined,
			id: isSet(object.id) ? globalThis.String(object.id) : undefined,
		}
	},

	toJSON(message: VsCodeLmModel): unknown {
		const obj: any = {}
		if (message.vendor !== undefined) {
			obj.vendor = message.vendor
		}
		if (message.family !== undefined) {
			obj.family = message.family
		}
		if (message.version !== undefined) {
			obj.version = message.version
		}
		if (message.id !== undefined) {
			obj.id = message.id
		}
		return obj
	},

	create<I extends Exact<DeepPartial<VsCodeLmModel>, I>>(base?: I): VsCodeLmModel {
		return VsCodeLmModel.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<VsCodeLmModel>, I>>(object: I): VsCodeLmModel {
		const message = createBaseVsCodeLmModel()
		message.vendor = object.vendor ?? undefined
		message.family = object.family ?? undefined
		message.version = object.version ?? undefined
		message.id = object.id ?? undefined
		return message
	},
}

function createBaseOpenGraphData(): OpenGraphData {
	return {
		title: undefined,
		description: undefined,
		image: undefined,
		url: undefined,
		siteName: undefined,
		type: undefined,
	}
}

export const OpenGraphData: MessageFns<OpenGraphData> = {
	encode(message: OpenGraphData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.title !== undefined) {
			writer.uint32(10).string(message.title)
		}
		if (message.description !== undefined) {
			writer.uint32(18).string(message.description)
		}
		if (message.image !== undefined) {
			writer.uint32(26).string(message.image)
		}
		if (message.url !== undefined) {
			writer.uint32(34).string(message.url)
		}
		if (message.siteName !== undefined) {
			writer.uint32(42).string(message.siteName)
		}
		if (message.type !== undefined) {
			writer.uint32(50).string(message.type)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): OpenGraphData {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseOpenGraphData()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.title = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.description = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.image = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.url = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.siteName = reader.string()
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.type = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): OpenGraphData {
		return {
			title: isSet(object.title) ? globalThis.String(object.title) : undefined,
			description: isSet(object.description) ? globalThis.String(object.description) : undefined,
			image: isSet(object.image) ? globalThis.String(object.image) : undefined,
			url: isSet(object.url) ? globalThis.String(object.url) : undefined,
			siteName: isSet(object.siteName) ? globalThis.String(object.siteName) : undefined,
			type: isSet(object.type) ? globalThis.String(object.type) : undefined,
		}
	},

	toJSON(message: OpenGraphData): unknown {
		const obj: any = {}
		if (message.title !== undefined) {
			obj.title = message.title
		}
		if (message.description !== undefined) {
			obj.description = message.description
		}
		if (message.image !== undefined) {
			obj.image = message.image
		}
		if (message.url !== undefined) {
			obj.url = message.url
		}
		if (message.siteName !== undefined) {
			obj.siteName = message.siteName
		}
		if (message.type !== undefined) {
			obj.type = message.type
		}
		return obj
	},

	create<I extends Exact<DeepPartial<OpenGraphData>, I>>(base?: I): OpenGraphData {
		return OpenGraphData.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<OpenGraphData>, I>>(object: I): OpenGraphData {
		const message = createBaseOpenGraphData()
		message.title = object.title ?? undefined
		message.description = object.description ?? undefined
		message.image = object.image ?? undefined
		message.url = object.url ?? undefined
		message.siteName = object.siteName ?? undefined
		message.type = object.type ?? undefined
		return message
	},
}

function createBaseAddRemoteServerResult(): AddRemoteServerResult {
	return { success: false, serverName: "", error: undefined }
}

export const AddRemoteServerResult: MessageFns<AddRemoteServerResult> = {
	encode(message: AddRemoteServerResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success)
		}
		if (message.serverName !== "") {
			writer.uint32(18).string(message.serverName)
		}
		if (message.error !== undefined) {
			writer.uint32(26).string(message.error)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AddRemoteServerResult {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAddRemoteServerResult()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.success = reader.bool()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.serverName = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.error = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AddRemoteServerResult {
		return {
			success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
			serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "",
			error: isSet(object.error) ? globalThis.String(object.error) : undefined,
		}
	},

	toJSON(message: AddRemoteServerResult): unknown {
		const obj: any = {}
		if (message.success !== false) {
			obj.success = message.success
		}
		if (message.serverName !== "") {
			obj.serverName = message.serverName
		}
		if (message.error !== undefined) {
			obj.error = message.error
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AddRemoteServerResult>, I>>(base?: I): AddRemoteServerResult {
		return AddRemoteServerResult.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AddRemoteServerResult>, I>>(object: I): AddRemoteServerResult {
		const message = createBaseAddRemoteServerResult()
		message.success = object.success ?? false
		message.serverName = object.serverName ?? ""
		message.error = object.error ?? undefined
		return message
	},
}

function createBaseBrowserConnectionResult(): BrowserConnectionResult {
	return {
		success: false,
		endpoint: undefined,
		isBundled: undefined,
		isConnected: undefined,
		isRemote: undefined,
		host: undefined,
		error: undefined,
	}
}

export const BrowserConnectionResult: MessageFns<BrowserConnectionResult> = {
	encode(message: BrowserConnectionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success)
		}
		if (message.endpoint !== undefined) {
			writer.uint32(18).string(message.endpoint)
		}
		if (message.isBundled !== undefined) {
			writer.uint32(24).bool(message.isBundled)
		}
		if (message.isConnected !== undefined) {
			writer.uint32(32).bool(message.isConnected)
		}
		if (message.isRemote !== undefined) {
			writer.uint32(40).bool(message.isRemote)
		}
		if (message.host !== undefined) {
			writer.uint32(50).string(message.host)
		}
		if (message.error !== undefined) {
			writer.uint32(58).string(message.error)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BrowserConnectionResult {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseBrowserConnectionResult()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.success = reader.bool()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.endpoint = reader.string()
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.isBundled = reader.bool()
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.isConnected = reader.bool()
					continue
				}
				case 5: {
					if (tag !== 40) {
						break
					}

					message.isRemote = reader.bool()
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.host = reader.string()
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.error = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): BrowserConnectionResult {
		return {
			success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
			endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : undefined,
			isBundled: isSet(object.isBundled) ? globalThis.Boolean(object.isBundled) : undefined,
			isConnected: isSet(object.isConnected) ? globalThis.Boolean(object.isConnected) : undefined,
			isRemote: isSet(object.isRemote) ? globalThis.Boolean(object.isRemote) : undefined,
			host: isSet(object.host) ? globalThis.String(object.host) : undefined,
			error: isSet(object.error) ? globalThis.String(object.error) : undefined,
		}
	},

	toJSON(message: BrowserConnectionResult): unknown {
		const obj: any = {}
		if (message.success !== false) {
			obj.success = message.success
		}
		if (message.endpoint !== undefined) {
			obj.endpoint = message.endpoint
		}
		if (message.isBundled !== undefined) {
			obj.isBundled = message.isBundled
		}
		if (message.isConnected !== undefined) {
			obj.isConnected = message.isConnected
		}
		if (message.isRemote !== undefined) {
			obj.isRemote = message.isRemote
		}
		if (message.host !== undefined) {
			obj.host = message.host
		}
		if (message.error !== undefined) {
			obj.error = message.error
		}
		return obj
	},

	create<I extends Exact<DeepPartial<BrowserConnectionResult>, I>>(base?: I): BrowserConnectionResult {
		return BrowserConnectionResult.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<BrowserConnectionResult>, I>>(object: I): BrowserConnectionResult {
		const message = createBaseBrowserConnectionResult()
		message.success = object.success ?? false
		message.endpoint = object.endpoint ?? undefined
		message.isBundled = object.isBundled ?? undefined
		message.isConnected = object.isConnected ?? undefined
		message.isRemote = object.isRemote ?? undefined
		message.host = object.host ?? undefined
		message.error = object.error ?? undefined
		return message
	},
}

function createBaseBrowserRelaunchResult(): BrowserRelaunchResult {
	return { success: false, error: undefined }
}

export const BrowserRelaunchResult: MessageFns<BrowserRelaunchResult> = {
	encode(message: BrowserRelaunchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success)
		}
		if (message.error !== undefined) {
			writer.uint32(18).string(message.error)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BrowserRelaunchResult {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseBrowserRelaunchResult()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.success = reader.bool()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.error = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): BrowserRelaunchResult {
		return {
			success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
			error: isSet(object.error) ? globalThis.String(object.error) : undefined,
		}
	},

	toJSON(message: BrowserRelaunchResult): unknown {
		const obj: any = {}
		if (message.success !== false) {
			obj.success = message.success
		}
		if (message.error !== undefined) {
			obj.error = message.error
		}
		return obj
	},

	create<I extends Exact<DeepPartial<BrowserRelaunchResult>, I>>(base?: I): BrowserRelaunchResult {
		return BrowserRelaunchResult.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<BrowserRelaunchResult>, I>>(object: I): BrowserRelaunchResult {
		const message = createBaseBrowserRelaunchResult()
		message.success = object.success ?? false
		message.error = object.error ?? undefined
		return message
	},
}

function createBaseFileSearchResult(): FileSearchResult {
	return { path: "", type: 0, label: undefined }
}

export const FileSearchResult: MessageFns<FileSearchResult> = {
	encode(message: FileSearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.path !== "") {
			writer.uint32(10).string(message.path)
		}
		if (message.type !== 0) {
			writer.uint32(16).int32(message.type)
		}
		if (message.label !== undefined) {
			writer.uint32(26).string(message.label)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): FileSearchResult {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseFileSearchResult()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.path = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.type = reader.int32() as any
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.label = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): FileSearchResult {
		return {
			path: isSet(object.path) ? globalThis.String(object.path) : "",
			type: isSet(object.type) ? fileSearchResult_TypeFromJSON(object.type) : 0,
			label: isSet(object.label) ? globalThis.String(object.label) : undefined,
		}
	},

	toJSON(message: FileSearchResult): unknown {
		const obj: any = {}
		if (message.path !== "") {
			obj.path = message.path
		}
		if (message.type !== 0) {
			obj.type = fileSearchResult_TypeToJSON(message.type)
		}
		if (message.label !== undefined) {
			obj.label = message.label
		}
		return obj
	},

	create<I extends Exact<DeepPartial<FileSearchResult>, I>>(base?: I): FileSearchResult {
		return FileSearchResult.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<FileSearchResult>, I>>(object: I): FileSearchResult {
		const message = createBaseFileSearchResult()
		message.path = object.path ?? ""
		message.type = object.type ?? 0
		message.label = object.label ?? undefined
		return message
	},
}

function createBaseGrpcResponse(): GrpcResponse {
	return { requestId: "", message: undefined }
}

export const GrpcResponse: MessageFns<GrpcResponse> = {
	encode(message: GrpcResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.requestId !== "") {
			writer.uint32(10).string(message.requestId)
		}
		if (message.message !== undefined) {
			Value.encode(Value.wrap(message.message), writer.uint32(18).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GrpcResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseGrpcResponse()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.requestId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.message = Value.unwrap(Value.decode(reader, reader.uint32()))
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): GrpcResponse {
		return {
			requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
			message: isSet(object?.message) ? object.message : undefined,
		}
	},

	toJSON(message: GrpcResponse): unknown {
		const obj: any = {}
		if (message.requestId !== "") {
			obj.requestId = message.requestId
		}
		if (message.message !== undefined) {
			obj.message = message.message
		}
		return obj
	},

	create<I extends Exact<DeepPartial<GrpcResponse>, I>>(base?: I): GrpcResponse {
		return GrpcResponse.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<GrpcResponse>, I>>(object: I): GrpcResponse {
		const message = createBaseGrpcResponse()
		message.requestId = object.requestId ?? ""
		message.message = object.message ?? undefined
		return message
	},
}

function createBaseClientMessage(): ClientMessage {
	return {
		newTask: undefined,
		askResponse: undefined,
		clearTask: undefined,
		didShowAnnouncement: undefined,
		exportCurrentTask: undefined,
		showTaskWithId: undefined,
		deleteTaskWithId: undefined,
		exportTaskWithId: undefined,
		resetState: undefined,
		requestOllamaModels: undefined,
		requestLmStudioModels: undefined,
		openImage: undefined,
		openInBrowser: undefined,
		openFile: undefined,
		createRuleFile: undefined,
		openMention: undefined,
		cancelTask: undefined,
		showChatView: undefined,
		refreshOpenRouterModels: undefined,
		refreshRequestyModels: undefined,
		refreshOpenAiModels: undefined,
		refreshClineRules: undefined,
		openMcpSettings: undefined,
		restartMcpServer: undefined,
		deleteMcpServer: undefined,
		autoApprovalSettings: undefined,
		browserSettings: undefined,
		togglePlanActMode: undefined,
		checkpointRestore: undefined,
		taskCompletionViewChanges: undefined,
		openExtensionSettings: undefined,
		requestVsCodeLmModels: undefined,
		toggleToolAutoApprove: undefined,
		toggleMcpServer: undefined,
		getLatestState: undefined,
		accountLoginClicked: undefined,
		accountLogoutClicked: undefined,
		showAccountViewClicked: undefined,
		authStateChanged: undefined,
		authCallback: undefined,
		fetchMcpMarketplace: undefined,
		downloadMcp: undefined,
		silentlyRefreshMcpMarketplace: undefined,
		searchCommits: undefined,
		showMcpView: undefined,
		fetchLatestMcpServersFromHub: undefined,
		telemetrySetting: undefined,
		openSettings: undefined,
		updateMcpTimeout: undefined,
		fetchOpenGraphData: undefined,
		checkIsImageUrl: undefined,
		invoke: undefined,
		updateSettings: undefined,
		clearAllTaskHistory: undefined,
		fetchUserCreditsData: undefined,
		optionsResponse: undefined,
		requestTotalTasksSize: undefined,
		relaunchChromeDebugMode: undefined,
		taskFeedback: undefined,
		getDetectedChromePath: undefined,
		getRelativePaths: undefined,
		searchFiles: undefined,
		toggleFavoriteModel: undefined,
		grpcRequest: undefined,
		toggleClineRule: undefined,
		deleteClineRule: undefined,
		condense: undefined,
		copyToClipboard: undefined,
		updateTerminalConnectionTimeout: undefined,
	}
}

export const ClientMessage: MessageFns<ClientMessage> = {
	encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.newTask !== undefined) {
			NewTaskRequest.encode(message.newTask, writer.uint32(10).fork()).join()
		}
		if (message.askResponse !== undefined) {
			AskResponseRequest.encode(message.askResponse, writer.uint32(18).fork()).join()
		}
		if (message.clearTask !== undefined) {
			Empty.encode(message.clearTask, writer.uint32(26).fork()).join()
		}
		if (message.didShowAnnouncement !== undefined) {
			Empty.encode(message.didShowAnnouncement, writer.uint32(34).fork()).join()
		}
		if (message.exportCurrentTask !== undefined) {
			Empty.encode(message.exportCurrentTask, writer.uint32(42).fork()).join()
		}
		if (message.showTaskWithId !== undefined) {
			ShowTaskWithIdRequest.encode(message.showTaskWithId, writer.uint32(50).fork()).join()
		}
		if (message.deleteTaskWithId !== undefined) {
			DeleteTaskWithIdRequest.encode(message.deleteTaskWithId, writer.uint32(58).fork()).join()
		}
		if (message.exportTaskWithId !== undefined) {
			ExportTaskWithIdRequest.encode(message.exportTaskWithId, writer.uint32(66).fork()).join()
		}
		if (message.resetState !== undefined) {
			Empty.encode(message.resetState, writer.uint32(74).fork()).join()
		}
		if (message.requestOllamaModels !== undefined) {
			Empty.encode(message.requestOllamaModels, writer.uint32(82).fork()).join()
		}
		if (message.requestLmStudioModels !== undefined) {
			Empty.encode(message.requestLmStudioModels, writer.uint32(90).fork()).join()
		}
		if (message.openImage !== undefined) {
			OpenImageRequest.encode(message.openImage, writer.uint32(98).fork()).join()
		}
		if (message.openInBrowser !== undefined) {
			OpenInBrowserRequest.encode(message.openInBrowser, writer.uint32(106).fork()).join()
		}
		if (message.openFile !== undefined) {
			OpenFileRequest.encode(message.openFile, writer.uint32(114).fork()).join()
		}
		if (message.createRuleFile !== undefined) {
			CreateRuleFileRequest.encode(message.createRuleFile, writer.uint32(122).fork()).join()
		}
		if (message.openMention !== undefined) {
			OpenMentionRequest.encode(message.openMention, writer.uint32(130).fork()).join()
		}
		if (message.cancelTask !== undefined) {
			Empty.encode(message.cancelTask, writer.uint32(138).fork()).join()
		}
		if (message.showChatView !== undefined) {
			Empty.encode(message.showChatView, writer.uint32(146).fork()).join()
		}
		if (message.refreshOpenRouterModels !== undefined) {
			Empty.encode(message.refreshOpenRouterModels, writer.uint32(154).fork()).join()
		}
		if (message.refreshRequestyModels !== undefined) {
			Empty.encode(message.refreshRequestyModels, writer.uint32(162).fork()).join()
		}
		if (message.refreshOpenAiModels !== undefined) {
			Empty.encode(message.refreshOpenAiModels, writer.uint32(170).fork()).join()
		}
		if (message.refreshClineRules !== undefined) {
			Empty.encode(message.refreshClineRules, writer.uint32(178).fork()).join()
		}
		if (message.openMcpSettings !== undefined) {
			Empty.encode(message.openMcpSettings, writer.uint32(186).fork()).join()
		}
		if (message.restartMcpServer !== undefined) {
			RestartMcpServerRequest.encode(message.restartMcpServer, writer.uint32(194).fork()).join()
		}
		if (message.deleteMcpServer !== undefined) {
			DeleteMcpServerRequest.encode(message.deleteMcpServer, writer.uint32(202).fork()).join()
		}
		if (message.autoApprovalSettings !== undefined) {
			ApplyAutoApprovalSettingsRequest.encode(message.autoApprovalSettings, writer.uint32(210).fork()).join()
		}
		if (message.browserSettings !== undefined) {
			ApplyBrowserSettingsRequest.encode(message.browserSettings, writer.uint32(218).fork()).join()
		}
		if (message.togglePlanActMode !== undefined) {
			Empty.encode(message.togglePlanActMode, writer.uint32(226).fork()).join()
		}
		if (message.checkpointRestore !== undefined) {
			CheckpointRestoreRequest.encode(message.checkpointRestore, writer.uint32(234).fork()).join()
		}
		if (message.taskCompletionViewChanges !== undefined) {
			Empty.encode(message.taskCompletionViewChanges, writer.uint32(242).fork()).join()
		}
		if (message.openExtensionSettings !== undefined) {
			Empty.encode(message.openExtensionSettings, writer.uint32(250).fork()).join()
		}
		if (message.requestVsCodeLmModels !== undefined) {
			Empty.encode(message.requestVsCodeLmModels, writer.uint32(258).fork()).join()
		}
		if (message.toggleToolAutoApprove !== undefined) {
			ToggleToolAutoApproveRequest.encode(message.toggleToolAutoApprove, writer.uint32(266).fork()).join()
		}
		if (message.toggleMcpServer !== undefined) {
			ToggleMcpServerRequest.encode(message.toggleMcpServer, writer.uint32(274).fork()).join()
		}
		if (message.getLatestState !== undefined) {
			Empty.encode(message.getLatestState, writer.uint32(282).fork()).join()
		}
		if (message.accountLoginClicked !== undefined) {
			Empty.encode(message.accountLoginClicked, writer.uint32(290).fork()).join()
		}
		if (message.accountLogoutClicked !== undefined) {
			Empty.encode(message.accountLogoutClicked, writer.uint32(298).fork()).join()
		}
		if (message.showAccountViewClicked !== undefined) {
			Empty.encode(message.showAccountViewClicked, writer.uint32(306).fork()).join()
		}
		if (message.authStateChanged !== undefined) {
			AuthStateChangedRequest.encode(message.authStateChanged, writer.uint32(314).fork()).join()
		}
		if (message.authCallback !== undefined) {
			AuthCallbackRequest.encode(message.authCallback, writer.uint32(322).fork()).join()
		}
		if (message.fetchMcpMarketplace !== undefined) {
			Empty.encode(message.fetchMcpMarketplace, writer.uint32(330).fork()).join()
		}
		if (message.downloadMcp !== undefined) {
			DownloadMcpRequest.encode(message.downloadMcp, writer.uint32(338).fork()).join()
		}
		if (message.silentlyRefreshMcpMarketplace !== undefined) {
			Empty.encode(message.silentlyRefreshMcpMarketplace, writer.uint32(346).fork()).join()
		}
		if (message.searchCommits !== undefined) {
			SearchCommitsRequest.encode(message.searchCommits, writer.uint32(354).fork()).join()
		}
		if (message.showMcpView !== undefined) {
			ShowMcpViewRequest.encode(message.showMcpView, writer.uint32(362).fork()).join()
		}
		if (message.fetchLatestMcpServersFromHub !== undefined) {
			Empty.encode(message.fetchLatestMcpServersFromHub, writer.uint32(370).fork()).join()
		}
		if (message.telemetrySetting !== undefined) {
			ApplyTelemetrySettingRequest.encode(message.telemetrySetting, writer.uint32(378).fork()).join()
		}
		if (message.openSettings !== undefined) {
			Empty.encode(message.openSettings, writer.uint32(386).fork()).join()
		}
		if (message.updateMcpTimeout !== undefined) {
			UpdateMcpTimeoutRequest.encode(message.updateMcpTimeout, writer.uint32(394).fork()).join()
		}
		if (message.fetchOpenGraphData !== undefined) {
			FetchOpenGraphDataRequest.encode(message.fetchOpenGraphData, writer.uint32(402).fork()).join()
		}
		if (message.checkIsImageUrl !== undefined) {
			CheckIsImageUrlRequest.encode(message.checkIsImageUrl, writer.uint32(410).fork()).join()
		}
		if (message.invoke !== undefined) {
			InvokeRequest.encode(message.invoke, writer.uint32(418).fork()).join()
		}
		if (message.updateSettings !== undefined) {
			UpdateSettingsRequest.encode(message.updateSettings, writer.uint32(426).fork()).join()
		}
		if (message.clearAllTaskHistory !== undefined) {
			Empty.encode(message.clearAllTaskHistory, writer.uint32(434).fork()).join()
		}
		if (message.fetchUserCreditsData !== undefined) {
			Empty.encode(message.fetchUserCreditsData, writer.uint32(442).fork()).join()
		}
		if (message.optionsResponse !== undefined) {
			OptionsResponseRequest.encode(message.optionsResponse, writer.uint32(450).fork()).join()
		}
		if (message.requestTotalTasksSize !== undefined) {
			Empty.encode(message.requestTotalTasksSize, writer.uint32(458).fork()).join()
		}
		if (message.relaunchChromeDebugMode !== undefined) {
			Empty.encode(message.relaunchChromeDebugMode, writer.uint32(466).fork()).join()
		}
		if (message.taskFeedback !== undefined) {
			TaskFeedbackRequest.encode(message.taskFeedback, writer.uint32(474).fork()).join()
		}
		if (message.getDetectedChromePath !== undefined) {
			Empty.encode(message.getDetectedChromePath, writer.uint32(482).fork()).join()
		}
		if (message.getRelativePaths !== undefined) {
			GetRelativePathsRequest.encode(message.getRelativePaths, writer.uint32(490).fork()).join()
		}
		if (message.searchFiles !== undefined) {
			SearchFilesRequest.encode(message.searchFiles, writer.uint32(498).fork()).join()
		}
		if (message.toggleFavoriteModel !== undefined) {
			ToggleFavoriteModelRequest.encode(message.toggleFavoriteModel, writer.uint32(506).fork()).join()
		}
		if (message.grpcRequest !== undefined) {
			GrpcRequest.encode(message.grpcRequest, writer.uint32(514).fork()).join()
		}
		if (message.toggleClineRule !== undefined) {
			ToggleClineRuleRequest.encode(message.toggleClineRule, writer.uint32(522).fork()).join()
		}
		if (message.deleteClineRule !== undefined) {
			DeleteClineRuleRequest.encode(message.deleteClineRule, writer.uint32(530).fork()).join()
		}
		if (message.condense !== undefined) {
			Empty.encode(message.condense, writer.uint32(538).fork()).join()
		}
		if (message.copyToClipboard !== undefined) {
			writer.uint32(546).string(message.copyToClipboard)
		}
		if (message.updateTerminalConnectionTimeout !== undefined) {
			writer.uint32(552).int32(message.updateTerminalConnectionTimeout)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseClientMessage()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.newTask = NewTaskRequest.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.askResponse = AskResponseRequest.decode(reader, reader.uint32())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.clearTask = Empty.decode(reader, reader.uint32())
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.didShowAnnouncement = Empty.decode(reader, reader.uint32())
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.exportCurrentTask = Empty.decode(reader, reader.uint32())
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.showTaskWithId = ShowTaskWithIdRequest.decode(reader, reader.uint32())
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.deleteTaskWithId = DeleteTaskWithIdRequest.decode(reader, reader.uint32())
					continue
				}
				case 8: {
					if (tag !== 66) {
						break
					}

					message.exportTaskWithId = ExportTaskWithIdRequest.decode(reader, reader.uint32())
					continue
				}
				case 9: {
					if (tag !== 74) {
						break
					}

					message.resetState = Empty.decode(reader, reader.uint32())
					continue
				}
				case 10: {
					if (tag !== 82) {
						break
					}

					message.requestOllamaModels = Empty.decode(reader, reader.uint32())
					continue
				}
				case 11: {
					if (tag !== 90) {
						break
					}

					message.requestLmStudioModels = Empty.decode(reader, reader.uint32())
					continue
				}
				case 12: {
					if (tag !== 98) {
						break
					}

					message.openImage = OpenImageRequest.decode(reader, reader.uint32())
					continue
				}
				case 13: {
					if (tag !== 106) {
						break
					}

					message.openInBrowser = OpenInBrowserRequest.decode(reader, reader.uint32())
					continue
				}
				case 14: {
					if (tag !== 114) {
						break
					}

					message.openFile = OpenFileRequest.decode(reader, reader.uint32())
					continue
				}
				case 15: {
					if (tag !== 122) {
						break
					}

					message.createRuleFile = CreateRuleFileRequest.decode(reader, reader.uint32())
					continue
				}
				case 16: {
					if (tag !== 130) {
						break
					}

					message.openMention = OpenMentionRequest.decode(reader, reader.uint32())
					continue
				}
				case 17: {
					if (tag !== 138) {
						break
					}

					message.cancelTask = Empty.decode(reader, reader.uint32())
					continue
				}
				case 18: {
					if (tag !== 146) {
						break
					}

					message.showChatView = Empty.decode(reader, reader.uint32())
					continue
				}
				case 19: {
					if (tag !== 154) {
						break
					}

					message.refreshOpenRouterModels = Empty.decode(reader, reader.uint32())
					continue
				}
				case 20: {
					if (tag !== 162) {
						break
					}

					message.refreshRequestyModels = Empty.decode(reader, reader.uint32())
					continue
				}
				case 21: {
					if (tag !== 170) {
						break
					}

					message.refreshOpenAiModels = Empty.decode(reader, reader.uint32())
					continue
				}
				case 22: {
					if (tag !== 178) {
						break
					}

					message.refreshClineRules = Empty.decode(reader, reader.uint32())
					continue
				}
				case 23: {
					if (tag !== 186) {
						break
					}

					message.openMcpSettings = Empty.decode(reader, reader.uint32())
					continue
				}
				case 24: {
					if (tag !== 194) {
						break
					}

					message.restartMcpServer = RestartMcpServerRequest.decode(reader, reader.uint32())
					continue
				}
				case 25: {
					if (tag !== 202) {
						break
					}

					message.deleteMcpServer = DeleteMcpServerRequest.decode(reader, reader.uint32())
					continue
				}
				case 26: {
					if (tag !== 210) {
						break
					}

					message.autoApprovalSettings = ApplyAutoApprovalSettingsRequest.decode(reader, reader.uint32())
					continue
				}
				case 27: {
					if (tag !== 218) {
						break
					}

					message.browserSettings = ApplyBrowserSettingsRequest.decode(reader, reader.uint32())
					continue
				}
				case 28: {
					if (tag !== 226) {
						break
					}

					message.togglePlanActMode = Empty.decode(reader, reader.uint32())
					continue
				}
				case 29: {
					if (tag !== 234) {
						break
					}

					message.checkpointRestore = CheckpointRestoreRequest.decode(reader, reader.uint32())
					continue
				}
				case 30: {
					if (tag !== 242) {
						break
					}

					message.taskCompletionViewChanges = Empty.decode(reader, reader.uint32())
					continue
				}
				case 31: {
					if (tag !== 250) {
						break
					}

					message.openExtensionSettings = Empty.decode(reader, reader.uint32())
					continue
				}
				case 32: {
					if (tag !== 258) {
						break
					}

					message.requestVsCodeLmModels = Empty.decode(reader, reader.uint32())
					continue
				}
				case 33: {
					if (tag !== 266) {
						break
					}

					message.toggleToolAutoApprove = ToggleToolAutoApproveRequest.decode(reader, reader.uint32())
					continue
				}
				case 34: {
					if (tag !== 274) {
						break
					}

					message.toggleMcpServer = ToggleMcpServerRequest.decode(reader, reader.uint32())
					continue
				}
				case 35: {
					if (tag !== 282) {
						break
					}

					message.getLatestState = Empty.decode(reader, reader.uint32())
					continue
				}
				case 36: {
					if (tag !== 290) {
						break
					}

					message.accountLoginClicked = Empty.decode(reader, reader.uint32())
					continue
				}
				case 37: {
					if (tag !== 298) {
						break
					}

					message.accountLogoutClicked = Empty.decode(reader, reader.uint32())
					continue
				}
				case 38: {
					if (tag !== 306) {
						break
					}

					message.showAccountViewClicked = Empty.decode(reader, reader.uint32())
					continue
				}
				case 39: {
					if (tag !== 314) {
						break
					}

					message.authStateChanged = AuthStateChangedRequest.decode(reader, reader.uint32())
					continue
				}
				case 40: {
					if (tag !== 322) {
						break
					}

					message.authCallback = AuthCallbackRequest.decode(reader, reader.uint32())
					continue
				}
				case 41: {
					if (tag !== 330) {
						break
					}

					message.fetchMcpMarketplace = Empty.decode(reader, reader.uint32())
					continue
				}
				case 42: {
					if (tag !== 338) {
						break
					}

					message.downloadMcp = DownloadMcpRequest.decode(reader, reader.uint32())
					continue
				}
				case 43: {
					if (tag !== 346) {
						break
					}

					message.silentlyRefreshMcpMarketplace = Empty.decode(reader, reader.uint32())
					continue
				}
				case 44: {
					if (tag !== 354) {
						break
					}

					message.searchCommits = SearchCommitsRequest.decode(reader, reader.uint32())
					continue
				}
				case 45: {
					if (tag !== 362) {
						break
					}

					message.showMcpView = ShowMcpViewRequest.decode(reader, reader.uint32())
					continue
				}
				case 46: {
					if (tag !== 370) {
						break
					}

					message.fetchLatestMcpServersFromHub = Empty.decode(reader, reader.uint32())
					continue
				}
				case 47: {
					if (tag !== 378) {
						break
					}

					message.telemetrySetting = ApplyTelemetrySettingRequest.decode(reader, reader.uint32())
					continue
				}
				case 48: {
					if (tag !== 386) {
						break
					}

					message.openSettings = Empty.decode(reader, reader.uint32())
					continue
				}
				case 49: {
					if (tag !== 394) {
						break
					}

					message.updateMcpTimeout = UpdateMcpTimeoutRequest.decode(reader, reader.uint32())
					continue
				}
				case 50: {
					if (tag !== 402) {
						break
					}

					message.fetchOpenGraphData = FetchOpenGraphDataRequest.decode(reader, reader.uint32())
					continue
				}
				case 51: {
					if (tag !== 410) {
						break
					}

					message.checkIsImageUrl = CheckIsImageUrlRequest.decode(reader, reader.uint32())
					continue
				}
				case 52: {
					if (tag !== 418) {
						break
					}

					message.invoke = InvokeRequest.decode(reader, reader.uint32())
					continue
				}
				case 53: {
					if (tag !== 426) {
						break
					}

					message.updateSettings = UpdateSettingsRequest.decode(reader, reader.uint32())
					continue
				}
				case 54: {
					if (tag !== 434) {
						break
					}

					message.clearAllTaskHistory = Empty.decode(reader, reader.uint32())
					continue
				}
				case 55: {
					if (tag !== 442) {
						break
					}

					message.fetchUserCreditsData = Empty.decode(reader, reader.uint32())
					continue
				}
				case 56: {
					if (tag !== 450) {
						break
					}

					message.optionsResponse = OptionsResponseRequest.decode(reader, reader.uint32())
					continue
				}
				case 57: {
					if (tag !== 458) {
						break
					}

					message.requestTotalTasksSize = Empty.decode(reader, reader.uint32())
					continue
				}
				case 58: {
					if (tag !== 466) {
						break
					}

					message.relaunchChromeDebugMode = Empty.decode(reader, reader.uint32())
					continue
				}
				case 59: {
					if (tag !== 474) {
						break
					}

					message.taskFeedback = TaskFeedbackRequest.decode(reader, reader.uint32())
					continue
				}
				case 60: {
					if (tag !== 482) {
						break
					}

					message.getDetectedChromePath = Empty.decode(reader, reader.uint32())
					continue
				}
				case 61: {
					if (tag !== 490) {
						break
					}

					message.getRelativePaths = GetRelativePathsRequest.decode(reader, reader.uint32())
					continue
				}
				case 62: {
					if (tag !== 498) {
						break
					}

					message.searchFiles = SearchFilesRequest.decode(reader, reader.uint32())
					continue
				}
				case 63: {
					if (tag !== 506) {
						break
					}

					message.toggleFavoriteModel = ToggleFavoriteModelRequest.decode(reader, reader.uint32())
					continue
				}
				case 64: {
					if (tag !== 514) {
						break
					}

					message.grpcRequest = GrpcRequest.decode(reader, reader.uint32())
					continue
				}
				case 65: {
					if (tag !== 522) {
						break
					}

					message.toggleClineRule = ToggleClineRuleRequest.decode(reader, reader.uint32())
					continue
				}
				case 66: {
					if (tag !== 530) {
						break
					}

					message.deleteClineRule = DeleteClineRuleRequest.decode(reader, reader.uint32())
					continue
				}
				case 67: {
					if (tag !== 538) {
						break
					}

					message.condense = Empty.decode(reader, reader.uint32())
					continue
				}
				case 68: {
					if (tag !== 546) {
						break
					}

					message.copyToClipboard = reader.string()
					continue
				}
				case 69: {
					if (tag !== 552) {
						break
					}

					message.updateTerminalConnectionTimeout = reader.int32()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ClientMessage {
		return {
			newTask: isSet(object.newTask) ? NewTaskRequest.fromJSON(object.newTask) : undefined,
			askResponse: isSet(object.askResponse) ? AskResponseRequest.fromJSON(object.askResponse) : undefined,
			clearTask: isSet(object.clearTask) ? Empty.fromJSON(object.clearTask) : undefined,
			didShowAnnouncement: isSet(object.didShowAnnouncement) ? Empty.fromJSON(object.didShowAnnouncement) : undefined,
			exportCurrentTask: isSet(object.exportCurrentTask) ? Empty.fromJSON(object.exportCurrentTask) : undefined,
			showTaskWithId: isSet(object.showTaskWithId) ? ShowTaskWithIdRequest.fromJSON(object.showTaskWithId) : undefined,
			deleteTaskWithId: isSet(object.deleteTaskWithId)
				? DeleteTaskWithIdRequest.fromJSON(object.deleteTaskWithId)
				: undefined,
			exportTaskWithId: isSet(object.exportTaskWithId)
				? ExportTaskWithIdRequest.fromJSON(object.exportTaskWithId)
				: undefined,
			resetState: isSet(object.resetState) ? Empty.fromJSON(object.resetState) : undefined,
			requestOllamaModels: isSet(object.requestOllamaModels) ? Empty.fromJSON(object.requestOllamaModels) : undefined,
			requestLmStudioModels: isSet(object.requestLmStudioModels) ? Empty.fromJSON(object.requestLmStudioModels) : undefined,
			openImage: isSet(object.openImage) ? OpenImageRequest.fromJSON(object.openImage) : undefined,
			openInBrowser: isSet(object.openInBrowser) ? OpenInBrowserRequest.fromJSON(object.openInBrowser) : undefined,
			openFile: isSet(object.openFile) ? OpenFileRequest.fromJSON(object.openFile) : undefined,
			createRuleFile: isSet(object.createRuleFile) ? CreateRuleFileRequest.fromJSON(object.createRuleFile) : undefined,
			openMention: isSet(object.openMention) ? OpenMentionRequest.fromJSON(object.openMention) : undefined,
			cancelTask: isSet(object.cancelTask) ? Empty.fromJSON(object.cancelTask) : undefined,
			showChatView: isSet(object.showChatView) ? Empty.fromJSON(object.showChatView) : undefined,
			refreshOpenRouterModels: isSet(object.refreshOpenRouterModels)
				? Empty.fromJSON(object.refreshOpenRouterModels)
				: undefined,
			refreshRequestyModels: isSet(object.refreshRequestyModels) ? Empty.fromJSON(object.refreshRequestyModels) : undefined,
			refreshOpenAiModels: isSet(object.refreshOpenAiModels) ? Empty.fromJSON(object.refreshOpenAiModels) : undefined,
			refreshClineRules: isSet(object.refreshClineRules) ? Empty.fromJSON(object.refreshClineRules) : undefined,
			openMcpSettings: isSet(object.openMcpSettings) ? Empty.fromJSON(object.openMcpSettings) : undefined,
			restartMcpServer: isSet(object.restartMcpServer)
				? RestartMcpServerRequest.fromJSON(object.restartMcpServer)
				: undefined,
			deleteMcpServer: isSet(object.deleteMcpServer) ? DeleteMcpServerRequest.fromJSON(object.deleteMcpServer) : undefined,
			autoApprovalSettings: isSet(object.autoApprovalSettings)
				? ApplyAutoApprovalSettingsRequest.fromJSON(object.autoApprovalSettings)
				: undefined,
			browserSettings: isSet(object.browserSettings)
				? ApplyBrowserSettingsRequest.fromJSON(object.browserSettings)
				: undefined,
			togglePlanActMode: isSet(object.togglePlanActMode) ? Empty.fromJSON(object.togglePlanActMode) : undefined,
			checkpointRestore: isSet(object.checkpointRestore)
				? CheckpointRestoreRequest.fromJSON(object.checkpointRestore)
				: undefined,
			taskCompletionViewChanges: isSet(object.taskCompletionViewChanges)
				? Empty.fromJSON(object.taskCompletionViewChanges)
				: undefined,
			openExtensionSettings: isSet(object.openExtensionSettings) ? Empty.fromJSON(object.openExtensionSettings) : undefined,
			requestVsCodeLmModels: isSet(object.requestVsCodeLmModels) ? Empty.fromJSON(object.requestVsCodeLmModels) : undefined,
			toggleToolAutoApprove: isSet(object.toggleToolAutoApprove)
				? ToggleToolAutoApproveRequest.fromJSON(object.toggleToolAutoApprove)
				: undefined,
			toggleMcpServer: isSet(object.toggleMcpServer) ? ToggleMcpServerRequest.fromJSON(object.toggleMcpServer) : undefined,
			getLatestState: isSet(object.getLatestState) ? Empty.fromJSON(object.getLatestState) : undefined,
			accountLoginClicked: isSet(object.accountLoginClicked) ? Empty.fromJSON(object.accountLoginClicked) : undefined,
			accountLogoutClicked: isSet(object.accountLogoutClicked) ? Empty.fromJSON(object.accountLogoutClicked) : undefined,
			showAccountViewClicked: isSet(object.showAccountViewClicked)
				? Empty.fromJSON(object.showAccountViewClicked)
				: undefined,
			authStateChanged: isSet(object.authStateChanged)
				? AuthStateChangedRequest.fromJSON(object.authStateChanged)
				: undefined,
			authCallback: isSet(object.authCallback) ? AuthCallbackRequest.fromJSON(object.authCallback) : undefined,
			fetchMcpMarketplace: isSet(object.fetchMcpMarketplace) ? Empty.fromJSON(object.fetchMcpMarketplace) : undefined,
			downloadMcp: isSet(object.downloadMcp) ? DownloadMcpRequest.fromJSON(object.downloadMcp) : undefined,
			silentlyRefreshMcpMarketplace: isSet(object.silentlyRefreshMcpMarketplace)
				? Empty.fromJSON(object.silentlyRefreshMcpMarketplace)
				: undefined,
			searchCommits: isSet(object.searchCommits) ? SearchCommitsRequest.fromJSON(object.searchCommits) : undefined,
			showMcpView: isSet(object.showMcpView) ? ShowMcpViewRequest.fromJSON(object.showMcpView) : undefined,
			fetchLatestMcpServersFromHub: isSet(object.fetchLatestMcpServersFromHub)
				? Empty.fromJSON(object.fetchLatestMcpServersFromHub)
				: undefined,
			telemetrySetting: isSet(object.telemetrySetting)
				? ApplyTelemetrySettingRequest.fromJSON(object.telemetrySetting)
				: undefined,
			openSettings: isSet(object.openSettings) ? Empty.fromJSON(object.openSettings) : undefined,
			updateMcpTimeout: isSet(object.updateMcpTimeout)
				? UpdateMcpTimeoutRequest.fromJSON(object.updateMcpTimeout)
				: undefined,
			fetchOpenGraphData: isSet(object.fetchOpenGraphData)
				? FetchOpenGraphDataRequest.fromJSON(object.fetchOpenGraphData)
				: undefined,
			checkIsImageUrl: isSet(object.checkIsImageUrl) ? CheckIsImageUrlRequest.fromJSON(object.checkIsImageUrl) : undefined,
			invoke: isSet(object.invoke) ? InvokeRequest.fromJSON(object.invoke) : undefined,
			updateSettings: isSet(object.updateSettings) ? UpdateSettingsRequest.fromJSON(object.updateSettings) : undefined,
			clearAllTaskHistory: isSet(object.clearAllTaskHistory) ? Empty.fromJSON(object.clearAllTaskHistory) : undefined,
			fetchUserCreditsData: isSet(object.fetchUserCreditsData) ? Empty.fromJSON(object.fetchUserCreditsData) : undefined,
			optionsResponse: isSet(object.optionsResponse) ? OptionsResponseRequest.fromJSON(object.optionsResponse) : undefined,
			requestTotalTasksSize: isSet(object.requestTotalTasksSize) ? Empty.fromJSON(object.requestTotalTasksSize) : undefined,
			relaunchChromeDebugMode: isSet(object.relaunchChromeDebugMode)
				? Empty.fromJSON(object.relaunchChromeDebugMode)
				: undefined,
			taskFeedback: isSet(object.taskFeedback) ? TaskFeedbackRequest.fromJSON(object.taskFeedback) : undefined,
			getDetectedChromePath: isSet(object.getDetectedChromePath) ? Empty.fromJSON(object.getDetectedChromePath) : undefined,
			getRelativePaths: isSet(object.getRelativePaths)
				? GetRelativePathsRequest.fromJSON(object.getRelativePaths)
				: undefined,
			searchFiles: isSet(object.searchFiles) ? SearchFilesRequest.fromJSON(object.searchFiles) : undefined,
			toggleFavoriteModel: isSet(object.toggleFavoriteModel)
				? ToggleFavoriteModelRequest.fromJSON(object.toggleFavoriteModel)
				: undefined,
			grpcRequest: isSet(object.grpcRequest) ? GrpcRequest.fromJSON(object.grpcRequest) : undefined,
			toggleClineRule: isSet(object.toggleClineRule) ? ToggleClineRuleRequest.fromJSON(object.toggleClineRule) : undefined,
			deleteClineRule: isSet(object.deleteClineRule) ? DeleteClineRuleRequest.fromJSON(object.deleteClineRule) : undefined,
			condense: isSet(object.condense) ? Empty.fromJSON(object.condense) : undefined,
			copyToClipboard: isSet(object.copyToClipboard) ? globalThis.String(object.copyToClipboard) : undefined,
			updateTerminalConnectionTimeout: isSet(object.updateTerminalConnectionTimeout)
				? globalThis.Number(object.updateTerminalConnectionTimeout)
				: undefined,
		}
	},

	toJSON(message: ClientMessage): unknown {
		const obj: any = {}
		if (message.newTask !== undefined) {
			obj.newTask = NewTaskRequest.toJSON(message.newTask)
		}
		if (message.askResponse !== undefined) {
			obj.askResponse = AskResponseRequest.toJSON(message.askResponse)
		}
		if (message.clearTask !== undefined) {
			obj.clearTask = Empty.toJSON(message.clearTask)
		}
		if (message.didShowAnnouncement !== undefined) {
			obj.didShowAnnouncement = Empty.toJSON(message.didShowAnnouncement)
		}
		if (message.exportCurrentTask !== undefined) {
			obj.exportCurrentTask = Empty.toJSON(message.exportCurrentTask)
		}
		if (message.showTaskWithId !== undefined) {
			obj.showTaskWithId = ShowTaskWithIdRequest.toJSON(message.showTaskWithId)
		}
		if (message.deleteTaskWithId !== undefined) {
			obj.deleteTaskWithId = DeleteTaskWithIdRequest.toJSON(message.deleteTaskWithId)
		}
		if (message.exportTaskWithId !== undefined) {
			obj.exportTaskWithId = ExportTaskWithIdRequest.toJSON(message.exportTaskWithId)
		}
		if (message.resetState !== undefined) {
			obj.resetState = Empty.toJSON(message.resetState)
		}
		if (message.requestOllamaModels !== undefined) {
			obj.requestOllamaModels = Empty.toJSON(message.requestOllamaModels)
		}
		if (message.requestLmStudioModels !== undefined) {
			obj.requestLmStudioModels = Empty.toJSON(message.requestLmStudioModels)
		}
		if (message.openImage !== undefined) {
			obj.openImage = OpenImageRequest.toJSON(message.openImage)
		}
		if (message.openInBrowser !== undefined) {
			obj.openInBrowser = OpenInBrowserRequest.toJSON(message.openInBrowser)
		}
		if (message.openFile !== undefined) {
			obj.openFile = OpenFileRequest.toJSON(message.openFile)
		}
		if (message.createRuleFile !== undefined) {
			obj.createRuleFile = CreateRuleFileRequest.toJSON(message.createRuleFile)
		}
		if (message.openMention !== undefined) {
			obj.openMention = OpenMentionRequest.toJSON(message.openMention)
		}
		if (message.cancelTask !== undefined) {
			obj.cancelTask = Empty.toJSON(message.cancelTask)
		}
		if (message.showChatView !== undefined) {
			obj.showChatView = Empty.toJSON(message.showChatView)
		}
		if (message.refreshOpenRouterModels !== undefined) {
			obj.refreshOpenRouterModels = Empty.toJSON(message.refreshOpenRouterModels)
		}
		if (message.refreshRequestyModels !== undefined) {
			obj.refreshRequestyModels = Empty.toJSON(message.refreshRequestyModels)
		}
		if (message.refreshOpenAiModels !== undefined) {
			obj.refreshOpenAiModels = Empty.toJSON(message.refreshOpenAiModels)
		}
		if (message.refreshClineRules !== undefined) {
			obj.refreshClineRules = Empty.toJSON(message.refreshClineRules)
		}
		if (message.openMcpSettings !== undefined) {
			obj.openMcpSettings = Empty.toJSON(message.openMcpSettings)
		}
		if (message.restartMcpServer !== undefined) {
			obj.restartMcpServer = RestartMcpServerRequest.toJSON(message.restartMcpServer)
		}
		if (message.deleteMcpServer !== undefined) {
			obj.deleteMcpServer = DeleteMcpServerRequest.toJSON(message.deleteMcpServer)
		}
		if (message.autoApprovalSettings !== undefined) {
			obj.autoApprovalSettings = ApplyAutoApprovalSettingsRequest.toJSON(message.autoApprovalSettings)
		}
		if (message.browserSettings !== undefined) {
			obj.browserSettings = ApplyBrowserSettingsRequest.toJSON(message.browserSettings)
		}
		if (message.togglePlanActMode !== undefined) {
			obj.togglePlanActMode = Empty.toJSON(message.togglePlanActMode)
		}
		if (message.checkpointRestore !== undefined) {
			obj.checkpointRestore = CheckpointRestoreRequest.toJSON(message.checkpointRestore)
		}
		if (message.taskCompletionViewChanges !== undefined) {
			obj.taskCompletionViewChanges = Empty.toJSON(message.taskCompletionViewChanges)
		}
		if (message.openExtensionSettings !== undefined) {
			obj.openExtensionSettings = Empty.toJSON(message.openExtensionSettings)
		}
		if (message.requestVsCodeLmModels !== undefined) {
			obj.requestVsCodeLmModels = Empty.toJSON(message.requestVsCodeLmModels)
		}
		if (message.toggleToolAutoApprove !== undefined) {
			obj.toggleToolAutoApprove = ToggleToolAutoApproveRequest.toJSON(message.toggleToolAutoApprove)
		}
		if (message.toggleMcpServer !== undefined) {
			obj.toggleMcpServer = ToggleMcpServerRequest.toJSON(message.toggleMcpServer)
		}
		if (message.getLatestState !== undefined) {
			obj.getLatestState = Empty.toJSON(message.getLatestState)
		}
		if (message.accountLoginClicked !== undefined) {
			obj.accountLoginClicked = Empty.toJSON(message.accountLoginClicked)
		}
		if (message.accountLogoutClicked !== undefined) {
			obj.accountLogoutClicked = Empty.toJSON(message.accountLogoutClicked)
		}
		if (message.showAccountViewClicked !== undefined) {
			obj.showAccountViewClicked = Empty.toJSON(message.showAccountViewClicked)
		}
		if (message.authStateChanged !== undefined) {
			obj.authStateChanged = AuthStateChangedRequest.toJSON(message.authStateChanged)
		}
		if (message.authCallback !== undefined) {
			obj.authCallback = AuthCallbackRequest.toJSON(message.authCallback)
		}
		if (message.fetchMcpMarketplace !== undefined) {
			obj.fetchMcpMarketplace = Empty.toJSON(message.fetchMcpMarketplace)
		}
		if (message.downloadMcp !== undefined) {
			obj.downloadMcp = DownloadMcpRequest.toJSON(message.downloadMcp)
		}
		if (message.silentlyRefreshMcpMarketplace !== undefined) {
			obj.silentlyRefreshMcpMarketplace = Empty.toJSON(message.silentlyRefreshMcpMarketplace)
		}
		if (message.searchCommits !== undefined) {
			obj.searchCommits = SearchCommitsRequest.toJSON(message.searchCommits)
		}
		if (message.showMcpView !== undefined) {
			obj.showMcpView = ShowMcpViewRequest.toJSON(message.showMcpView)
		}
		if (message.fetchLatestMcpServersFromHub !== undefined) {
			obj.fetchLatestMcpServersFromHub = Empty.toJSON(message.fetchLatestMcpServersFromHub)
		}
		if (message.telemetrySetting !== undefined) {
			obj.telemetrySetting = ApplyTelemetrySettingRequest.toJSON(message.telemetrySetting)
		}
		if (message.openSettings !== undefined) {
			obj.openSettings = Empty.toJSON(message.openSettings)
		}
		if (message.updateMcpTimeout !== undefined) {
			obj.updateMcpTimeout = UpdateMcpTimeoutRequest.toJSON(message.updateMcpTimeout)
		}
		if (message.fetchOpenGraphData !== undefined) {
			obj.fetchOpenGraphData = FetchOpenGraphDataRequest.toJSON(message.fetchOpenGraphData)
		}
		if (message.checkIsImageUrl !== undefined) {
			obj.checkIsImageUrl = CheckIsImageUrlRequest.toJSON(message.checkIsImageUrl)
		}
		if (message.invoke !== undefined) {
			obj.invoke = InvokeRequest.toJSON(message.invoke)
		}
		if (message.updateSettings !== undefined) {
			obj.updateSettings = UpdateSettingsRequest.toJSON(message.updateSettings)
		}
		if (message.clearAllTaskHistory !== undefined) {
			obj.clearAllTaskHistory = Empty.toJSON(message.clearAllTaskHistory)
		}
		if (message.fetchUserCreditsData !== undefined) {
			obj.fetchUserCreditsData = Empty.toJSON(message.fetchUserCreditsData)
		}
		if (message.optionsResponse !== undefined) {
			obj.optionsResponse = OptionsResponseRequest.toJSON(message.optionsResponse)
		}
		if (message.requestTotalTasksSize !== undefined) {
			obj.requestTotalTasksSize = Empty.toJSON(message.requestTotalTasksSize)
		}
		if (message.relaunchChromeDebugMode !== undefined) {
			obj.relaunchChromeDebugMode = Empty.toJSON(message.relaunchChromeDebugMode)
		}
		if (message.taskFeedback !== undefined) {
			obj.taskFeedback = TaskFeedbackRequest.toJSON(message.taskFeedback)
		}
		if (message.getDetectedChromePath !== undefined) {
			obj.getDetectedChromePath = Empty.toJSON(message.getDetectedChromePath)
		}
		if (message.getRelativePaths !== undefined) {
			obj.getRelativePaths = GetRelativePathsRequest.toJSON(message.getRelativePaths)
		}
		if (message.searchFiles !== undefined) {
			obj.searchFiles = SearchFilesRequest.toJSON(message.searchFiles)
		}
		if (message.toggleFavoriteModel !== undefined) {
			obj.toggleFavoriteModel = ToggleFavoriteModelRequest.toJSON(message.toggleFavoriteModel)
		}
		if (message.grpcRequest !== undefined) {
			obj.grpcRequest = GrpcRequest.toJSON(message.grpcRequest)
		}
		if (message.toggleClineRule !== undefined) {
			obj.toggleClineRule = ToggleClineRuleRequest.toJSON(message.toggleClineRule)
		}
		if (message.deleteClineRule !== undefined) {
			obj.deleteClineRule = DeleteClineRuleRequest.toJSON(message.deleteClineRule)
		}
		if (message.condense !== undefined) {
			obj.condense = Empty.toJSON(message.condense)
		}
		if (message.copyToClipboard !== undefined) {
			obj.copyToClipboard = message.copyToClipboard
		}
		if (message.updateTerminalConnectionTimeout !== undefined) {
			obj.updateTerminalConnectionTimeout = Math.round(message.updateTerminalConnectionTimeout)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
		return ClientMessage.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
		const message = createBaseClientMessage()
		message.newTask =
			object.newTask !== undefined && object.newTask !== null ? NewTaskRequest.fromPartial(object.newTask) : undefined
		message.askResponse =
			object.askResponse !== undefined && object.askResponse !== null
				? AskResponseRequest.fromPartial(object.askResponse)
				: undefined
		message.clearTask =
			object.clearTask !== undefined && object.clearTask !== null ? Empty.fromPartial(object.clearTask) : undefined
		message.didShowAnnouncement =
			object.didShowAnnouncement !== undefined && object.didShowAnnouncement !== null
				? Empty.fromPartial(object.didShowAnnouncement)
				: undefined
		message.exportCurrentTask =
			object.exportCurrentTask !== undefined && object.exportCurrentTask !== null
				? Empty.fromPartial(object.exportCurrentTask)
				: undefined
		message.showTaskWithId =
			object.showTaskWithId !== undefined && object.showTaskWithId !== null
				? ShowTaskWithIdRequest.fromPartial(object.showTaskWithId)
				: undefined
		message.deleteTaskWithId =
			object.deleteTaskWithId !== undefined && object.deleteTaskWithId !== null
				? DeleteTaskWithIdRequest.fromPartial(object.deleteTaskWithId)
				: undefined
		message.exportTaskWithId =
			object.exportTaskWithId !== undefined && object.exportTaskWithId !== null
				? ExportTaskWithIdRequest.fromPartial(object.exportTaskWithId)
				: undefined
		message.resetState =
			object.resetState !== undefined && object.resetState !== null ? Empty.fromPartial(object.resetState) : undefined
		message.requestOllamaModels =
			object.requestOllamaModels !== undefined && object.requestOllamaModels !== null
				? Empty.fromPartial(object.requestOllamaModels)
				: undefined
		message.requestLmStudioModels =
			object.requestLmStudioModels !== undefined && object.requestLmStudioModels !== null
				? Empty.fromPartial(object.requestLmStudioModels)
				: undefined
		message.openImage =
			object.openImage !== undefined && object.openImage !== null
				? OpenImageRequest.fromPartial(object.openImage)
				: undefined
		message.openInBrowser =
			object.openInBrowser !== undefined && object.openInBrowser !== null
				? OpenInBrowserRequest.fromPartial(object.openInBrowser)
				: undefined
		message.openFile =
			object.openFile !== undefined && object.openFile !== null ? OpenFileRequest.fromPartial(object.openFile) : undefined
		message.createRuleFile =
			object.createRuleFile !== undefined && object.createRuleFile !== null
				? CreateRuleFileRequest.fromPartial(object.createRuleFile)
				: undefined
		message.openMention =
			object.openMention !== undefined && object.openMention !== null
				? OpenMentionRequest.fromPartial(object.openMention)
				: undefined
		message.cancelTask =
			object.cancelTask !== undefined && object.cancelTask !== null ? Empty.fromPartial(object.cancelTask) : undefined
		message.showChatView =
			object.showChatView !== undefined && object.showChatView !== null ? Empty.fromPartial(object.showChatView) : undefined
		message.refreshOpenRouterModels =
			object.refreshOpenRouterModels !== undefined && object.refreshOpenRouterModels !== null
				? Empty.fromPartial(object.refreshOpenRouterModels)
				: undefined
		message.refreshRequestyModels =
			object.refreshRequestyModels !== undefined && object.refreshRequestyModels !== null
				? Empty.fromPartial(object.refreshRequestyModels)
				: undefined
		message.refreshOpenAiModels =
			object.refreshOpenAiModels !== undefined && object.refreshOpenAiModels !== null
				? Empty.fromPartial(object.refreshOpenAiModels)
				: undefined
		message.refreshClineRules =
			object.refreshClineRules !== undefined && object.refreshClineRules !== null
				? Empty.fromPartial(object.refreshClineRules)
				: undefined
		message.openMcpSettings =
			object.openMcpSettings !== undefined && object.openMcpSettings !== null
				? Empty.fromPartial(object.openMcpSettings)
				: undefined
		message.restartMcpServer =
			object.restartMcpServer !== undefined && object.restartMcpServer !== null
				? RestartMcpServerRequest.fromPartial(object.restartMcpServer)
				: undefined
		message.deleteMcpServer =
			object.deleteMcpServer !== undefined && object.deleteMcpServer !== null
				? DeleteMcpServerRequest.fromPartial(object.deleteMcpServer)
				: undefined
		message.autoApprovalSettings =
			object.autoApprovalSettings !== undefined && object.autoApprovalSettings !== null
				? ApplyAutoApprovalSettingsRequest.fromPartial(object.autoApprovalSettings)
				: undefined
		message.browserSettings =
			object.browserSettings !== undefined && object.browserSettings !== null
				? ApplyBrowserSettingsRequest.fromPartial(object.browserSettings)
				: undefined
		message.togglePlanActMode =
			object.togglePlanActMode !== undefined && object.togglePlanActMode !== null
				? Empty.fromPartial(object.togglePlanActMode)
				: undefined
		message.checkpointRestore =
			object.checkpointRestore !== undefined && object.checkpointRestore !== null
				? CheckpointRestoreRequest.fromPartial(object.checkpointRestore)
				: undefined
		message.taskCompletionViewChanges =
			object.taskCompletionViewChanges !== undefined && object.taskCompletionViewChanges !== null
				? Empty.fromPartial(object.taskCompletionViewChanges)
				: undefined
		message.openExtensionSettings =
			object.openExtensionSettings !== undefined && object.openExtensionSettings !== null
				? Empty.fromPartial(object.openExtensionSettings)
				: undefined
		message.requestVsCodeLmModels =
			object.requestVsCodeLmModels !== undefined && object.requestVsCodeLmModels !== null
				? Empty.fromPartial(object.requestVsCodeLmModels)
				: undefined
		message.toggleToolAutoApprove =
			object.toggleToolAutoApprove !== undefined && object.toggleToolAutoApprove !== null
				? ToggleToolAutoApproveRequest.fromPartial(object.toggleToolAutoApprove)
				: undefined
		message.toggleMcpServer =
			object.toggleMcpServer !== undefined && object.toggleMcpServer !== null
				? ToggleMcpServerRequest.fromPartial(object.toggleMcpServer)
				: undefined
		message.getLatestState =
			object.getLatestState !== undefined && object.getLatestState !== null
				? Empty.fromPartial(object.getLatestState)
				: undefined
		message.accountLoginClicked =
			object.accountLoginClicked !== undefined && object.accountLoginClicked !== null
				? Empty.fromPartial(object.accountLoginClicked)
				: undefined
		message.accountLogoutClicked =
			object.accountLogoutClicked !== undefined && object.accountLogoutClicked !== null
				? Empty.fromPartial(object.accountLogoutClicked)
				: undefined
		message.showAccountViewClicked =
			object.showAccountViewClicked !== undefined && object.showAccountViewClicked !== null
				? Empty.fromPartial(object.showAccountViewClicked)
				: undefined
		message.authStateChanged =
			object.authStateChanged !== undefined && object.authStateChanged !== null
				? AuthStateChangedRequest.fromPartial(object.authStateChanged)
				: undefined
		message.authCallback =
			object.authCallback !== undefined && object.authCallback !== null
				? AuthCallbackRequest.fromPartial(object.authCallback)
				: undefined
		message.fetchMcpMarketplace =
			object.fetchMcpMarketplace !== undefined && object.fetchMcpMarketplace !== null
				? Empty.fromPartial(object.fetchMcpMarketplace)
				: undefined
		message.downloadMcp =
			object.downloadMcp !== undefined && object.downloadMcp !== null
				? DownloadMcpRequest.fromPartial(object.downloadMcp)
				: undefined
		message.silentlyRefreshMcpMarketplace =
			object.silentlyRefreshMcpMarketplace !== undefined && object.silentlyRefreshMcpMarketplace !== null
				? Empty.fromPartial(object.silentlyRefreshMcpMarketplace)
				: undefined
		message.searchCommits =
			object.searchCommits !== undefined && object.searchCommits !== null
				? SearchCommitsRequest.fromPartial(object.searchCommits)
				: undefined
		message.showMcpView =
			object.showMcpView !== undefined && object.showMcpView !== null
				? ShowMcpViewRequest.fromPartial(object.showMcpView)
				: undefined
		message.fetchLatestMcpServersFromHub =
			object.fetchLatestMcpServersFromHub !== undefined && object.fetchLatestMcpServersFromHub !== null
				? Empty.fromPartial(object.fetchLatestMcpServersFromHub)
				: undefined
		message.telemetrySetting =
			object.telemetrySetting !== undefined && object.telemetrySetting !== null
				? ApplyTelemetrySettingRequest.fromPartial(object.telemetrySetting)
				: undefined
		message.openSettings =
			object.openSettings !== undefined && object.openSettings !== null ? Empty.fromPartial(object.openSettings) : undefined
		message.updateMcpTimeout =
			object.updateMcpTimeout !== undefined && object.updateMcpTimeout !== null
				? UpdateMcpTimeoutRequest.fromPartial(object.updateMcpTimeout)
				: undefined
		message.fetchOpenGraphData =
			object.fetchOpenGraphData !== undefined && object.fetchOpenGraphData !== null
				? FetchOpenGraphDataRequest.fromPartial(object.fetchOpenGraphData)
				: undefined
		message.checkIsImageUrl =
			object.checkIsImageUrl !== undefined && object.checkIsImageUrl !== null
				? CheckIsImageUrlRequest.fromPartial(object.checkIsImageUrl)
				: undefined
		message.invoke =
			object.invoke !== undefined && object.invoke !== null ? InvokeRequest.fromPartial(object.invoke) : undefined
		message.updateSettings =
			object.updateSettings !== undefined && object.updateSettings !== null
				? UpdateSettingsRequest.fromPartial(object.updateSettings)
				: undefined
		message.clearAllTaskHistory =
			object.clearAllTaskHistory !== undefined && object.clearAllTaskHistory !== null
				? Empty.fromPartial(object.clearAllTaskHistory)
				: undefined
		message.fetchUserCreditsData =
			object.fetchUserCreditsData !== undefined && object.fetchUserCreditsData !== null
				? Empty.fromPartial(object.fetchUserCreditsData)
				: undefined
		message.optionsResponse =
			object.optionsResponse !== undefined && object.optionsResponse !== null
				? OptionsResponseRequest.fromPartial(object.optionsResponse)
				: undefined
		message.requestTotalTasksSize =
			object.requestTotalTasksSize !== undefined && object.requestTotalTasksSize !== null
				? Empty.fromPartial(object.requestTotalTasksSize)
				: undefined
		message.relaunchChromeDebugMode =
			object.relaunchChromeDebugMode !== undefined && object.relaunchChromeDebugMode !== null
				? Empty.fromPartial(object.relaunchChromeDebugMode)
				: undefined
		message.taskFeedback =
			object.taskFeedback !== undefined && object.taskFeedback !== null
				? TaskFeedbackRequest.fromPartial(object.taskFeedback)
				: undefined
		message.getDetectedChromePath =
			object.getDetectedChromePath !== undefined && object.getDetectedChromePath !== null
				? Empty.fromPartial(object.getDetectedChromePath)
				: undefined
		message.getRelativePaths =
			object.getRelativePaths !== undefined && object.getRelativePaths !== null
				? GetRelativePathsRequest.fromPartial(object.getRelativePaths)
				: undefined
		message.searchFiles =
			object.searchFiles !== undefined && object.searchFiles !== null
				? SearchFilesRequest.fromPartial(object.searchFiles)
				: undefined
		message.toggleFavoriteModel =
			object.toggleFavoriteModel !== undefined && object.toggleFavoriteModel !== null
				? ToggleFavoriteModelRequest.fromPartial(object.toggleFavoriteModel)
				: undefined
		message.grpcRequest =
			object.grpcRequest !== undefined && object.grpcRequest !== null
				? GrpcRequest.fromPartial(object.grpcRequest)
				: undefined
		message.toggleClineRule =
			object.toggleClineRule !== undefined && object.toggleClineRule !== null
				? ToggleClineRuleRequest.fromPartial(object.toggleClineRule)
				: undefined
		message.deleteClineRule =
			object.deleteClineRule !== undefined && object.deleteClineRule !== null
				? DeleteClineRuleRequest.fromPartial(object.deleteClineRule)
				: undefined
		message.condense =
			object.condense !== undefined && object.condense !== null ? Empty.fromPartial(object.condense) : undefined
		message.copyToClipboard = object.copyToClipboard ?? undefined
		message.updateTerminalConnectionTimeout = object.updateTerminalConnectionTimeout ?? undefined
		return message
	},
}

function createBaseNewTaskRequest(): NewTaskRequest {
	return { text: undefined, chatContent: undefined }
}

export const NewTaskRequest: MessageFns<NewTaskRequest> = {
	encode(message: NewTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.text !== undefined) {
			writer.uint32(10).string(message.text)
		}
		if (message.chatContent !== undefined) {
			ChatContent.encode(message.chatContent, writer.uint32(18).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): NewTaskRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseNewTaskRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.text = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.chatContent = ChatContent.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): NewTaskRequest {
		return {
			text: isSet(object.text) ? globalThis.String(object.text) : undefined,
			chatContent: isSet(object.chatContent) ? ChatContent.fromJSON(object.chatContent) : undefined,
		}
	},

	toJSON(message: NewTaskRequest): unknown {
		const obj: any = {}
		if (message.text !== undefined) {
			obj.text = message.text
		}
		if (message.chatContent !== undefined) {
			obj.chatContent = ChatContent.toJSON(message.chatContent)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<NewTaskRequest>, I>>(base?: I): NewTaskRequest {
		return NewTaskRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<NewTaskRequest>, I>>(object: I): NewTaskRequest {
		const message = createBaseNewTaskRequest()
		message.text = object.text ?? undefined
		message.chatContent =
			object.chatContent !== undefined && object.chatContent !== null
				? ChatContent.fromPartial(object.chatContent)
				: undefined
		return message
	},
}

function createBaseAskResponseRequest(): AskResponseRequest {
	return { askResponseType: 0, text: undefined }
}

export const AskResponseRequest: MessageFns<AskResponseRequest> = {
	encode(message: AskResponseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.askResponseType !== 0) {
			writer.uint32(8).int32(message.askResponseType)
		}
		if (message.text !== undefined) {
			writer.uint32(18).string(message.text)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AskResponseRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAskResponseRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.askResponseType = reader.int32() as any
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.text = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AskResponseRequest {
		return {
			askResponseType: isSet(object.askResponseType) ? askResponseTypeFromJSON(object.askResponseType) : 0,
			text: isSet(object.text) ? globalThis.String(object.text) : undefined,
		}
	},

	toJSON(message: AskResponseRequest): unknown {
		const obj: any = {}
		if (message.askResponseType !== 0) {
			obj.askResponseType = askResponseTypeToJSON(message.askResponseType)
		}
		if (message.text !== undefined) {
			obj.text = message.text
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AskResponseRequest>, I>>(base?: I): AskResponseRequest {
		return AskResponseRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AskResponseRequest>, I>>(object: I): AskResponseRequest {
		const message = createBaseAskResponseRequest()
		message.askResponseType = object.askResponseType ?? 0
		message.text = object.text ?? undefined
		return message
	},
}

function createBaseShowTaskWithIdRequest(): ShowTaskWithIdRequest {
	return { taskId: "" }
}

export const ShowTaskWithIdRequest: MessageFns<ShowTaskWithIdRequest> = {
	encode(message: ShowTaskWithIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.taskId !== "") {
			writer.uint32(10).string(message.taskId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ShowTaskWithIdRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseShowTaskWithIdRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.taskId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ShowTaskWithIdRequest {
		return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" }
	},

	toJSON(message: ShowTaskWithIdRequest): unknown {
		const obj: any = {}
		if (message.taskId !== "") {
			obj.taskId = message.taskId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ShowTaskWithIdRequest>, I>>(base?: I): ShowTaskWithIdRequest {
		return ShowTaskWithIdRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ShowTaskWithIdRequest>, I>>(object: I): ShowTaskWithIdRequest {
		const message = createBaseShowTaskWithIdRequest()
		message.taskId = object.taskId ?? ""
		return message
	},
}

function createBaseDeleteTaskWithIdRequest(): DeleteTaskWithIdRequest {
	return { taskId: "" }
}

export const DeleteTaskWithIdRequest: MessageFns<DeleteTaskWithIdRequest> = {
	encode(message: DeleteTaskWithIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.taskId !== "") {
			writer.uint32(10).string(message.taskId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): DeleteTaskWithIdRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseDeleteTaskWithIdRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.taskId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): DeleteTaskWithIdRequest {
		return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" }
	},

	toJSON(message: DeleteTaskWithIdRequest): unknown {
		const obj: any = {}
		if (message.taskId !== "") {
			obj.taskId = message.taskId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<DeleteTaskWithIdRequest>, I>>(base?: I): DeleteTaskWithIdRequest {
		return DeleteTaskWithIdRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<DeleteTaskWithIdRequest>, I>>(object: I): DeleteTaskWithIdRequest {
		const message = createBaseDeleteTaskWithIdRequest()
		message.taskId = object.taskId ?? ""
		return message
	},
}

function createBaseExportTaskWithIdRequest(): ExportTaskWithIdRequest {
	return { taskId: "" }
}

export const ExportTaskWithIdRequest: MessageFns<ExportTaskWithIdRequest> = {
	encode(message: ExportTaskWithIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.taskId !== "") {
			writer.uint32(10).string(message.taskId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExportTaskWithIdRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExportTaskWithIdRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.taskId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExportTaskWithIdRequest {
		return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" }
	},

	toJSON(message: ExportTaskWithIdRequest): unknown {
		const obj: any = {}
		if (message.taskId !== "") {
			obj.taskId = message.taskId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExportTaskWithIdRequest>, I>>(base?: I): ExportTaskWithIdRequest {
		return ExportTaskWithIdRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExportTaskWithIdRequest>, I>>(object: I): ExportTaskWithIdRequest {
		const message = createBaseExportTaskWithIdRequest()
		message.taskId = object.taskId ?? ""
		return message
	},
}

function createBaseOpenImageRequest(): OpenImageRequest {
	return { imageUri: "" }
}

export const OpenImageRequest: MessageFns<OpenImageRequest> = {
	encode(message: OpenImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.imageUri !== "") {
			writer.uint32(10).string(message.imageUri)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): OpenImageRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseOpenImageRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.imageUri = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): OpenImageRequest {
		return { imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "" }
	},

	toJSON(message: OpenImageRequest): unknown {
		const obj: any = {}
		if (message.imageUri !== "") {
			obj.imageUri = message.imageUri
		}
		return obj
	},

	create<I extends Exact<DeepPartial<OpenImageRequest>, I>>(base?: I): OpenImageRequest {
		return OpenImageRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<OpenImageRequest>, I>>(object: I): OpenImageRequest {
		const message = createBaseOpenImageRequest()
		message.imageUri = object.imageUri ?? ""
		return message
	},
}

function createBaseOpenInBrowserRequest(): OpenInBrowserRequest {
	return { url: "" }
}

export const OpenInBrowserRequest: MessageFns<OpenInBrowserRequest> = {
	encode(message: OpenInBrowserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.url !== "") {
			writer.uint32(10).string(message.url)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): OpenInBrowserRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseOpenInBrowserRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.url = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): OpenInBrowserRequest {
		return { url: isSet(object.url) ? globalThis.String(object.url) : "" }
	},

	toJSON(message: OpenInBrowserRequest): unknown {
		const obj: any = {}
		if (message.url !== "") {
			obj.url = message.url
		}
		return obj
	},

	create<I extends Exact<DeepPartial<OpenInBrowserRequest>, I>>(base?: I): OpenInBrowserRequest {
		return OpenInBrowserRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<OpenInBrowserRequest>, I>>(object: I): OpenInBrowserRequest {
		const message = createBaseOpenInBrowserRequest()
		message.url = object.url ?? ""
		return message
	},
}

function createBaseOpenFileRequest(): OpenFileRequest {
	return { filePath: "" }
}

export const OpenFileRequest: MessageFns<OpenFileRequest> = {
	encode(message: OpenFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.filePath !== "") {
			writer.uint32(10).string(message.filePath)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): OpenFileRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseOpenFileRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.filePath = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): OpenFileRequest {
		return { filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "" }
	},

	toJSON(message: OpenFileRequest): unknown {
		const obj: any = {}
		if (message.filePath !== "") {
			obj.filePath = message.filePath
		}
		return obj
	},

	create<I extends Exact<DeepPartial<OpenFileRequest>, I>>(base?: I): OpenFileRequest {
		return OpenFileRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<OpenFileRequest>, I>>(object: I): OpenFileRequest {
		const message = createBaseOpenFileRequest()
		message.filePath = object.filePath ?? ""
		return message
	},
}

function createBaseCreateRuleFileRequest(): CreateRuleFileRequest {
	return { filename: undefined }
}

export const CreateRuleFileRequest: MessageFns<CreateRuleFileRequest> = {
	encode(message: CreateRuleFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.filename !== undefined) {
			writer.uint32(10).string(message.filename)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): CreateRuleFileRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseCreateRuleFileRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.filename = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): CreateRuleFileRequest {
		return { filename: isSet(object.filename) ? globalThis.String(object.filename) : undefined }
	},

	toJSON(message: CreateRuleFileRequest): unknown {
		const obj: any = {}
		if (message.filename !== undefined) {
			obj.filename = message.filename
		}
		return obj
	},

	create<I extends Exact<DeepPartial<CreateRuleFileRequest>, I>>(base?: I): CreateRuleFileRequest {
		return CreateRuleFileRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<CreateRuleFileRequest>, I>>(object: I): CreateRuleFileRequest {
		const message = createBaseCreateRuleFileRequest()
		message.filename = object.filename ?? undefined
		return message
	},
}

function createBaseOpenMentionRequest(): OpenMentionRequest {
	return { mentionIdentifier: "" }
}

export const OpenMentionRequest: MessageFns<OpenMentionRequest> = {
	encode(message: OpenMentionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mentionIdentifier !== "") {
			writer.uint32(10).string(message.mentionIdentifier)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): OpenMentionRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseOpenMentionRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.mentionIdentifier = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): OpenMentionRequest {
		return { mentionIdentifier: isSet(object.mentionIdentifier) ? globalThis.String(object.mentionIdentifier) : "" }
	},

	toJSON(message: OpenMentionRequest): unknown {
		const obj: any = {}
		if (message.mentionIdentifier !== "") {
			obj.mentionIdentifier = message.mentionIdentifier
		}
		return obj
	},

	create<I extends Exact<DeepPartial<OpenMentionRequest>, I>>(base?: I): OpenMentionRequest {
		return OpenMentionRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<OpenMentionRequest>, I>>(object: I): OpenMentionRequest {
		const message = createBaseOpenMentionRequest()
		message.mentionIdentifier = object.mentionIdentifier ?? ""
		return message
	},
}

function createBaseRestartMcpServerRequest(): RestartMcpServerRequest {
	return { mcpId: "" }
}

export const RestartMcpServerRequest: MessageFns<RestartMcpServerRequest> = {
	encode(message: RestartMcpServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mcpId !== "") {
			writer.uint32(10).string(message.mcpId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RestartMcpServerRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseRestartMcpServerRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.mcpId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): RestartMcpServerRequest {
		return { mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "" }
	},

	toJSON(message: RestartMcpServerRequest): unknown {
		const obj: any = {}
		if (message.mcpId !== "") {
			obj.mcpId = message.mcpId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<RestartMcpServerRequest>, I>>(base?: I): RestartMcpServerRequest {
		return RestartMcpServerRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<RestartMcpServerRequest>, I>>(object: I): RestartMcpServerRequest {
		const message = createBaseRestartMcpServerRequest()
		message.mcpId = object.mcpId ?? ""
		return message
	},
}

function createBaseDeleteMcpServerRequest(): DeleteMcpServerRequest {
	return { mcpId: "" }
}

export const DeleteMcpServerRequest: MessageFns<DeleteMcpServerRequest> = {
	encode(message: DeleteMcpServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mcpId !== "") {
			writer.uint32(10).string(message.mcpId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): DeleteMcpServerRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseDeleteMcpServerRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.mcpId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): DeleteMcpServerRequest {
		return { mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "" }
	},

	toJSON(message: DeleteMcpServerRequest): unknown {
		const obj: any = {}
		if (message.mcpId !== "") {
			obj.mcpId = message.mcpId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<DeleteMcpServerRequest>, I>>(base?: I): DeleteMcpServerRequest {
		return DeleteMcpServerRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<DeleteMcpServerRequest>, I>>(object: I): DeleteMcpServerRequest {
		const message = createBaseDeleteMcpServerRequest()
		message.mcpId = object.mcpId ?? ""
		return message
	},
}

function createBaseApplyAutoApprovalSettingsRequest(): ApplyAutoApprovalSettingsRequest {
	return { settings: undefined }
}

export const ApplyAutoApprovalSettingsRequest: MessageFns<ApplyAutoApprovalSettingsRequest> = {
	encode(message: ApplyAutoApprovalSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.settings !== undefined) {
			AutoApprovalSettings.encode(message.settings, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ApplyAutoApprovalSettingsRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseApplyAutoApprovalSettingsRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.settings = AutoApprovalSettings.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ApplyAutoApprovalSettingsRequest {
		return { settings: isSet(object.settings) ? AutoApprovalSettings.fromJSON(object.settings) : undefined }
	},

	toJSON(message: ApplyAutoApprovalSettingsRequest): unknown {
		const obj: any = {}
		if (message.settings !== undefined) {
			obj.settings = AutoApprovalSettings.toJSON(message.settings)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ApplyAutoApprovalSettingsRequest>, I>>(base?: I): ApplyAutoApprovalSettingsRequest {
		return ApplyAutoApprovalSettingsRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ApplyAutoApprovalSettingsRequest>, I>>(object: I): ApplyAutoApprovalSettingsRequest {
		const message = createBaseApplyAutoApprovalSettingsRequest()
		message.settings =
			object.settings !== undefined && object.settings !== null
				? AutoApprovalSettings.fromPartial(object.settings)
				: undefined
		return message
	},
}

function createBaseApplyBrowserSettingsRequest(): ApplyBrowserSettingsRequest {
	return { settings: undefined }
}

export const ApplyBrowserSettingsRequest: MessageFns<ApplyBrowserSettingsRequest> = {
	encode(message: ApplyBrowserSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.settings !== undefined) {
			BrowserSettings.encode(message.settings, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ApplyBrowserSettingsRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseApplyBrowserSettingsRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.settings = BrowserSettings.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ApplyBrowserSettingsRequest {
		return { settings: isSet(object.settings) ? BrowserSettings.fromJSON(object.settings) : undefined }
	},

	toJSON(message: ApplyBrowserSettingsRequest): unknown {
		const obj: any = {}
		if (message.settings !== undefined) {
			obj.settings = BrowserSettings.toJSON(message.settings)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ApplyBrowserSettingsRequest>, I>>(base?: I): ApplyBrowserSettingsRequest {
		return ApplyBrowserSettingsRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ApplyBrowserSettingsRequest>, I>>(object: I): ApplyBrowserSettingsRequest {
		const message = createBaseApplyBrowserSettingsRequest()
		message.settings =
			object.settings !== undefined && object.settings !== null ? BrowserSettings.fromPartial(object.settings) : undefined
		return message
	},
}

function createBaseCheckpointRestoreRequest(): CheckpointRestoreRequest {
	return { restoreType: 0 }
}

export const CheckpointRestoreRequest: MessageFns<CheckpointRestoreRequest> = {
	encode(message: CheckpointRestoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.restoreType !== 0) {
			writer.uint32(8).int32(message.restoreType)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): CheckpointRestoreRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseCheckpointRestoreRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.restoreType = reader.int32() as any
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): CheckpointRestoreRequest {
		return { restoreType: isSet(object.restoreType) ? clineCheckpointRestoreTypeFromJSON(object.restoreType) : 0 }
	},

	toJSON(message: CheckpointRestoreRequest): unknown {
		const obj: any = {}
		if (message.restoreType !== 0) {
			obj.restoreType = clineCheckpointRestoreTypeToJSON(message.restoreType)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<CheckpointRestoreRequest>, I>>(base?: I): CheckpointRestoreRequest {
		return CheckpointRestoreRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<CheckpointRestoreRequest>, I>>(object: I): CheckpointRestoreRequest {
		const message = createBaseCheckpointRestoreRequest()
		message.restoreType = object.restoreType ?? 0
		return message
	},
}

function createBaseToggleToolAutoApproveRequest(): ToggleToolAutoApproveRequest {
	return { serverName: "", toolNames: [], autoApprove: false }
}

export const ToggleToolAutoApproveRequest: MessageFns<ToggleToolAutoApproveRequest> = {
	encode(message: ToggleToolAutoApproveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.serverName !== "") {
			writer.uint32(10).string(message.serverName)
		}
		for (const v of message.toolNames) {
			writer.uint32(18).string(v!)
		}
		if (message.autoApprove !== false) {
			writer.uint32(24).bool(message.autoApprove)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ToggleToolAutoApproveRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseToggleToolAutoApproveRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.serverName = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.toolNames.push(reader.string())
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.autoApprove = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ToggleToolAutoApproveRequest {
		return {
			serverName: isSet(object.serverName) ? globalThis.String(object.serverName) : "",
			toolNames: globalThis.Array.isArray(object?.toolNames) ? object.toolNames.map((e: any) => globalThis.String(e)) : [],
			autoApprove: isSet(object.autoApprove) ? globalThis.Boolean(object.autoApprove) : false,
		}
	},

	toJSON(message: ToggleToolAutoApproveRequest): unknown {
		const obj: any = {}
		if (message.serverName !== "") {
			obj.serverName = message.serverName
		}
		if (message.toolNames?.length) {
			obj.toolNames = message.toolNames
		}
		if (message.autoApprove !== false) {
			obj.autoApprove = message.autoApprove
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ToggleToolAutoApproveRequest>, I>>(base?: I): ToggleToolAutoApproveRequest {
		return ToggleToolAutoApproveRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ToggleToolAutoApproveRequest>, I>>(object: I): ToggleToolAutoApproveRequest {
		const message = createBaseToggleToolAutoApproveRequest()
		message.serverName = object.serverName ?? ""
		message.toolNames = object.toolNames?.map((e) => e) || []
		message.autoApprove = object.autoApprove ?? false
		return message
	},
}

function createBaseToggleMcpServerRequest(): ToggleMcpServerRequest {
	return { mcpId: "", enabled: false }
}

export const ToggleMcpServerRequest: MessageFns<ToggleMcpServerRequest> = {
	encode(message: ToggleMcpServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mcpId !== "") {
			writer.uint32(10).string(message.mcpId)
		}
		if (message.enabled !== false) {
			writer.uint32(16).bool(message.enabled)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ToggleMcpServerRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseToggleMcpServerRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.mcpId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.enabled = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ToggleMcpServerRequest {
		return {
			mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "",
			enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
		}
	},

	toJSON(message: ToggleMcpServerRequest): unknown {
		const obj: any = {}
		if (message.mcpId !== "") {
			obj.mcpId = message.mcpId
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ToggleMcpServerRequest>, I>>(base?: I): ToggleMcpServerRequest {
		return ToggleMcpServerRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ToggleMcpServerRequest>, I>>(object: I): ToggleMcpServerRequest {
		const message = createBaseToggleMcpServerRequest()
		message.mcpId = object.mcpId ?? ""
		message.enabled = object.enabled ?? false
		return message
	},
}

function createBaseAuthStateChangedRequest(): AuthStateChangedRequest {
	return { user: undefined }
}

export const AuthStateChangedRequest: MessageFns<AuthStateChangedRequest> = {
	encode(message: AuthStateChangedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.user !== undefined) {
			UserInfo.encode(message.user, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AuthStateChangedRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAuthStateChangedRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.user = UserInfo.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AuthStateChangedRequest {
		return { user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined }
	},

	toJSON(message: AuthStateChangedRequest): unknown {
		const obj: any = {}
		if (message.user !== undefined) {
			obj.user = UserInfo.toJSON(message.user)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AuthStateChangedRequest>, I>>(base?: I): AuthStateChangedRequest {
		return AuthStateChangedRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AuthStateChangedRequest>, I>>(object: I): AuthStateChangedRequest {
		const message = createBaseAuthStateChangedRequest()
		message.user = object.user !== undefined && object.user !== null ? UserInfo.fromPartial(object.user) : undefined
		return message
	},
}

function createBaseAuthCallbackRequest(): AuthCallbackRequest {
	return { customToken: "" }
}

export const AuthCallbackRequest: MessageFns<AuthCallbackRequest> = {
	encode(message: AuthCallbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.customToken !== "") {
			writer.uint32(10).string(message.customToken)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AuthCallbackRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAuthCallbackRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.customToken = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AuthCallbackRequest {
		return { customToken: isSet(object.customToken) ? globalThis.String(object.customToken) : "" }
	},

	toJSON(message: AuthCallbackRequest): unknown {
		const obj: any = {}
		if (message.customToken !== "") {
			obj.customToken = message.customToken
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AuthCallbackRequest>, I>>(base?: I): AuthCallbackRequest {
		return AuthCallbackRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AuthCallbackRequest>, I>>(object: I): AuthCallbackRequest {
		const message = createBaseAuthCallbackRequest()
		message.customToken = object.customToken ?? ""
		return message
	},
}

function createBaseDownloadMcpRequest(): DownloadMcpRequest {
	return { mcpId: "" }
}

export const DownloadMcpRequest: MessageFns<DownloadMcpRequest> = {
	encode(message: DownloadMcpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mcpId !== "") {
			writer.uint32(10).string(message.mcpId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): DownloadMcpRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseDownloadMcpRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.mcpId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): DownloadMcpRequest {
		return { mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "" }
	},

	toJSON(message: DownloadMcpRequest): unknown {
		const obj: any = {}
		if (message.mcpId !== "") {
			obj.mcpId = message.mcpId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<DownloadMcpRequest>, I>>(base?: I): DownloadMcpRequest {
		return DownloadMcpRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<DownloadMcpRequest>, I>>(object: I): DownloadMcpRequest {
		const message = createBaseDownloadMcpRequest()
		message.mcpId = object.mcpId ?? ""
		return message
	},
}

function createBaseSearchCommitsRequest(): SearchCommitsRequest {
	return { query: "" }
}

export const SearchCommitsRequest: MessageFns<SearchCommitsRequest> = {
	encode(message: SearchCommitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.query !== "") {
			writer.uint32(10).string(message.query)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SearchCommitsRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSearchCommitsRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.query = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SearchCommitsRequest {
		return { query: isSet(object.query) ? globalThis.String(object.query) : "" }
	},

	toJSON(message: SearchCommitsRequest): unknown {
		const obj: any = {}
		if (message.query !== "") {
			obj.query = message.query
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SearchCommitsRequest>, I>>(base?: I): SearchCommitsRequest {
		return SearchCommitsRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SearchCommitsRequest>, I>>(object: I): SearchCommitsRequest {
		const message = createBaseSearchCommitsRequest()
		message.query = object.query ?? ""
		return message
	},
}

function createBaseShowMcpViewRequest(): ShowMcpViewRequest {
	return { tab: 0 }
}

export const ShowMcpViewRequest: MessageFns<ShowMcpViewRequest> = {
	encode(message: ShowMcpViewRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.tab !== 0) {
			writer.uint32(8).int32(message.tab)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ShowMcpViewRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseShowMcpViewRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.tab = reader.int32() as any
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ShowMcpViewRequest {
		return { tab: isSet(object.tab) ? mcpViewTabFromJSON(object.tab) : 0 }
	},

	toJSON(message: ShowMcpViewRequest): unknown {
		const obj: any = {}
		if (message.tab !== 0) {
			obj.tab = mcpViewTabToJSON(message.tab)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ShowMcpViewRequest>, I>>(base?: I): ShowMcpViewRequest {
		return ShowMcpViewRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ShowMcpViewRequest>, I>>(object: I): ShowMcpViewRequest {
		const message = createBaseShowMcpViewRequest()
		message.tab = object.tab ?? 0
		return message
	},
}

function createBaseApplyTelemetrySettingRequest(): ApplyTelemetrySettingRequest {
	return { setting: 0 }
}

export const ApplyTelemetrySettingRequest: MessageFns<ApplyTelemetrySettingRequest> = {
	encode(message: ApplyTelemetrySettingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.setting !== 0) {
			writer.uint32(8).int32(message.setting)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ApplyTelemetrySettingRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseApplyTelemetrySettingRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.setting = reader.int32() as any
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ApplyTelemetrySettingRequest {
		return { setting: isSet(object.setting) ? telemetrySettingValueFromJSON(object.setting) : 0 }
	},

	toJSON(message: ApplyTelemetrySettingRequest): unknown {
		const obj: any = {}
		if (message.setting !== 0) {
			obj.setting = telemetrySettingValueToJSON(message.setting)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ApplyTelemetrySettingRequest>, I>>(base?: I): ApplyTelemetrySettingRequest {
		return ApplyTelemetrySettingRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ApplyTelemetrySettingRequest>, I>>(object: I): ApplyTelemetrySettingRequest {
		const message = createBaseApplyTelemetrySettingRequest()
		message.setting = object.setting ?? 0
		return message
	},
}

function createBaseUpdateMcpTimeoutRequest(): UpdateMcpTimeoutRequest {
	return { mcpId: "", timeout: 0 }
}

export const UpdateMcpTimeoutRequest: MessageFns<UpdateMcpTimeoutRequest> = {
	encode(message: UpdateMcpTimeoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.mcpId !== "") {
			writer.uint32(10).string(message.mcpId)
		}
		if (message.timeout !== 0) {
			writer.uint32(16).int32(message.timeout)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UpdateMcpTimeoutRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseUpdateMcpTimeoutRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.mcpId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.timeout = reader.int32()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): UpdateMcpTimeoutRequest {
		return {
			mcpId: isSet(object.mcpId) ? globalThis.String(object.mcpId) : "",
			timeout: isSet(object.timeout) ? globalThis.Number(object.timeout) : 0,
		}
	},

	toJSON(message: UpdateMcpTimeoutRequest): unknown {
		const obj: any = {}
		if (message.mcpId !== "") {
			obj.mcpId = message.mcpId
		}
		if (message.timeout !== 0) {
			obj.timeout = Math.round(message.timeout)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<UpdateMcpTimeoutRequest>, I>>(base?: I): UpdateMcpTimeoutRequest {
		return UpdateMcpTimeoutRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<UpdateMcpTimeoutRequest>, I>>(object: I): UpdateMcpTimeoutRequest {
		const message = createBaseUpdateMcpTimeoutRequest()
		message.mcpId = object.mcpId ?? ""
		message.timeout = object.timeout ?? 0
		return message
	},
}

function createBaseFetchOpenGraphDataRequest(): FetchOpenGraphDataRequest {
	return { url: "" }
}

export const FetchOpenGraphDataRequest: MessageFns<FetchOpenGraphDataRequest> = {
	encode(message: FetchOpenGraphDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.url !== "") {
			writer.uint32(10).string(message.url)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): FetchOpenGraphDataRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseFetchOpenGraphDataRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.url = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): FetchOpenGraphDataRequest {
		return { url: isSet(object.url) ? globalThis.String(object.url) : "" }
	},

	toJSON(message: FetchOpenGraphDataRequest): unknown {
		const obj: any = {}
		if (message.url !== "") {
			obj.url = message.url
		}
		return obj
	},

	create<I extends Exact<DeepPartial<FetchOpenGraphDataRequest>, I>>(base?: I): FetchOpenGraphDataRequest {
		return FetchOpenGraphDataRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<FetchOpenGraphDataRequest>, I>>(object: I): FetchOpenGraphDataRequest {
		const message = createBaseFetchOpenGraphDataRequest()
		message.url = object.url ?? ""
		return message
	},
}

function createBaseCheckIsImageUrlRequest(): CheckIsImageUrlRequest {
	return { url: "" }
}

export const CheckIsImageUrlRequest: MessageFns<CheckIsImageUrlRequest> = {
	encode(message: CheckIsImageUrlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.url !== "") {
			writer.uint32(10).string(message.url)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): CheckIsImageUrlRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseCheckIsImageUrlRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.url = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): CheckIsImageUrlRequest {
		return { url: isSet(object.url) ? globalThis.String(object.url) : "" }
	},

	toJSON(message: CheckIsImageUrlRequest): unknown {
		const obj: any = {}
		if (message.url !== "") {
			obj.url = message.url
		}
		return obj
	},

	create<I extends Exact<DeepPartial<CheckIsImageUrlRequest>, I>>(base?: I): CheckIsImageUrlRequest {
		return CheckIsImageUrlRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<CheckIsImageUrlRequest>, I>>(object: I): CheckIsImageUrlRequest {
		const message = createBaseCheckIsImageUrlRequest()
		message.url = object.url ?? ""
		return message
	},
}

function createBaseInvokeRequest(): InvokeRequest {
	return { text: undefined, images: [] }
}

export const InvokeRequest: MessageFns<InvokeRequest> = {
	encode(message: InvokeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.text !== undefined) {
			writer.uint32(10).string(message.text)
		}
		for (const v of message.images) {
			writer.uint32(18).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): InvokeRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseInvokeRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.text = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.images.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): InvokeRequest {
		return {
			text: isSet(object.text) ? globalThis.String(object.text) : undefined,
			images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => globalThis.String(e)) : [],
		}
	},

	toJSON(message: InvokeRequest): unknown {
		const obj: any = {}
		if (message.text !== undefined) {
			obj.text = message.text
		}
		if (message.images?.length) {
			obj.images = message.images
		}
		return obj
	},

	create<I extends Exact<DeepPartial<InvokeRequest>, I>>(base?: I): InvokeRequest {
		return InvokeRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<InvokeRequest>, I>>(object: I): InvokeRequest {
		const message = createBaseInvokeRequest()
		message.text = object.text ?? undefined
		message.images = object.images?.map((e) => e) || []
		return message
	},
}

function createBaseUpdateSettingsRequest(): UpdateSettingsRequest {
	return {
		settingsUpdate: undefined,
		apiConfiguration: undefined,
		chatSettings: undefined,
		planActSeparateModelsSetting: undefined,
		customInstructionsSetting: undefined,
	}
}

export const UpdateSettingsRequest: MessageFns<UpdateSettingsRequest> = {
	encode(message: UpdateSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.settingsUpdate !== undefined) {
			Struct.encode(Struct.wrap(message.settingsUpdate), writer.uint32(10).fork()).join()
		}
		if (message.apiConfiguration !== undefined) {
			ApiConfiguration.encode(message.apiConfiguration, writer.uint32(18).fork()).join()
		}
		if (message.chatSettings !== undefined) {
			ChatSettings.encode(message.chatSettings, writer.uint32(26).fork()).join()
		}
		if (message.planActSeparateModelsSetting !== undefined) {
			writer.uint32(32).bool(message.planActSeparateModelsSetting)
		}
		if (message.customInstructionsSetting !== undefined) {
			writer.uint32(42).string(message.customInstructionsSetting)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UpdateSettingsRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseUpdateSettingsRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.settingsUpdate = Struct.unwrap(Struct.decode(reader, reader.uint32()))
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.apiConfiguration = ApiConfiguration.decode(reader, reader.uint32())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.chatSettings = ChatSettings.decode(reader, reader.uint32())
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.planActSeparateModelsSetting = reader.bool()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.customInstructionsSetting = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): UpdateSettingsRequest {
		return {
			settingsUpdate: isObject(object.settingsUpdate) ? object.settingsUpdate : undefined,
			apiConfiguration: isSet(object.apiConfiguration) ? ApiConfiguration.fromJSON(object.apiConfiguration) : undefined,
			chatSettings: isSet(object.chatSettings) ? ChatSettings.fromJSON(object.chatSettings) : undefined,
			planActSeparateModelsSetting: isSet(object.planActSeparateModelsSetting)
				? globalThis.Boolean(object.planActSeparateModelsSetting)
				: undefined,
			customInstructionsSetting: isSet(object.customInstructionsSetting)
				? globalThis.String(object.customInstructionsSetting)
				: undefined,
		}
	},

	toJSON(message: UpdateSettingsRequest): unknown {
		const obj: any = {}
		if (message.settingsUpdate !== undefined) {
			obj.settingsUpdate = message.settingsUpdate
		}
		if (message.apiConfiguration !== undefined) {
			obj.apiConfiguration = ApiConfiguration.toJSON(message.apiConfiguration)
		}
		if (message.chatSettings !== undefined) {
			obj.chatSettings = ChatSettings.toJSON(message.chatSettings)
		}
		if (message.planActSeparateModelsSetting !== undefined) {
			obj.planActSeparateModelsSetting = message.planActSeparateModelsSetting
		}
		if (message.customInstructionsSetting !== undefined) {
			obj.customInstructionsSetting = message.customInstructionsSetting
		}
		return obj
	},

	create<I extends Exact<DeepPartial<UpdateSettingsRequest>, I>>(base?: I): UpdateSettingsRequest {
		return UpdateSettingsRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<UpdateSettingsRequest>, I>>(object: I): UpdateSettingsRequest {
		const message = createBaseUpdateSettingsRequest()
		message.settingsUpdate = object.settingsUpdate ?? undefined
		message.apiConfiguration =
			object.apiConfiguration !== undefined && object.apiConfiguration !== null
				? ApiConfiguration.fromPartial(object.apiConfiguration)
				: undefined
		message.chatSettings =
			object.chatSettings !== undefined && object.chatSettings !== null
				? ChatSettings.fromPartial(object.chatSettings)
				: undefined
		message.planActSeparateModelsSetting = object.planActSeparateModelsSetting ?? undefined
		message.customInstructionsSetting = object.customInstructionsSetting ?? undefined
		return message
	},
}

function createBaseOptionsResponseRequest(): OptionsResponseRequest {
	return { selectedOption: "" }
}

export const OptionsResponseRequest: MessageFns<OptionsResponseRequest> = {
	encode(message: OptionsResponseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.selectedOption !== "") {
			writer.uint32(10).string(message.selectedOption)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): OptionsResponseRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseOptionsResponseRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.selectedOption = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): OptionsResponseRequest {
		return { selectedOption: isSet(object.selectedOption) ? globalThis.String(object.selectedOption) : "" }
	},

	toJSON(message: OptionsResponseRequest): unknown {
		const obj: any = {}
		if (message.selectedOption !== "") {
			obj.selectedOption = message.selectedOption
		}
		return obj
	},

	create<I extends Exact<DeepPartial<OptionsResponseRequest>, I>>(base?: I): OptionsResponseRequest {
		return OptionsResponseRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<OptionsResponseRequest>, I>>(object: I): OptionsResponseRequest {
		const message = createBaseOptionsResponseRequest()
		message.selectedOption = object.selectedOption ?? ""
		return message
	},
}

function createBaseTaskFeedbackRequest(): TaskFeedbackRequest {
	return { feedbackType: 0, text: undefined }
}

export const TaskFeedbackRequest: MessageFns<TaskFeedbackRequest> = {
	encode(message: TaskFeedbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.feedbackType !== 0) {
			writer.uint32(8).int32(message.feedbackType)
		}
		if (message.text !== undefined) {
			writer.uint32(18).string(message.text)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): TaskFeedbackRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseTaskFeedbackRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.feedbackType = reader.int32() as any
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.text = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): TaskFeedbackRequest {
		return {
			feedbackType: isSet(object.feedbackType) ? taskFeedbackTypeFromJSON(object.feedbackType) : 0,
			text: isSet(object.text) ? globalThis.String(object.text) : undefined,
		}
	},

	toJSON(message: TaskFeedbackRequest): unknown {
		const obj: any = {}
		if (message.feedbackType !== 0) {
			obj.feedbackType = taskFeedbackTypeToJSON(message.feedbackType)
		}
		if (message.text !== undefined) {
			obj.text = message.text
		}
		return obj
	},

	create<I extends Exact<DeepPartial<TaskFeedbackRequest>, I>>(base?: I): TaskFeedbackRequest {
		return TaskFeedbackRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<TaskFeedbackRequest>, I>>(object: I): TaskFeedbackRequest {
		const message = createBaseTaskFeedbackRequest()
		message.feedbackType = object.feedbackType ?? 0
		message.text = object.text ?? undefined
		return message
	},
}

function createBaseGetRelativePathsRequest(): GetRelativePathsRequest {
	return { uris: [] }
}

export const GetRelativePathsRequest: MessageFns<GetRelativePathsRequest> = {
	encode(message: GetRelativePathsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.uris) {
			writer.uint32(10).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GetRelativePathsRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseGetRelativePathsRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.uris.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): GetRelativePathsRequest {
		return { uris: globalThis.Array.isArray(object?.uris) ? object.uris.map((e: any) => globalThis.String(e)) : [] }
	},

	toJSON(message: GetRelativePathsRequest): unknown {
		const obj: any = {}
		if (message.uris?.length) {
			obj.uris = message.uris
		}
		return obj
	},

	create<I extends Exact<DeepPartial<GetRelativePathsRequest>, I>>(base?: I): GetRelativePathsRequest {
		return GetRelativePathsRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<GetRelativePathsRequest>, I>>(object: I): GetRelativePathsRequest {
		const message = createBaseGetRelativePathsRequest()
		message.uris = object.uris?.map((e) => e) || []
		return message
	},
}

function createBaseSearchFilesRequest(): SearchFilesRequest {
	return { query: "" }
}

export const SearchFilesRequest: MessageFns<SearchFilesRequest> = {
	encode(message: SearchFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.query !== "") {
			writer.uint32(10).string(message.query)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SearchFilesRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseSearchFilesRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.query = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): SearchFilesRequest {
		return { query: isSet(object.query) ? globalThis.String(object.query) : "" }
	},

	toJSON(message: SearchFilesRequest): unknown {
		const obj: any = {}
		if (message.query !== "") {
			obj.query = message.query
		}
		return obj
	},

	create<I extends Exact<DeepPartial<SearchFilesRequest>, I>>(base?: I): SearchFilesRequest {
		return SearchFilesRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<SearchFilesRequest>, I>>(object: I): SearchFilesRequest {
		const message = createBaseSearchFilesRequest()
		message.query = object.query ?? ""
		return message
	},
}

function createBaseToggleFavoriteModelRequest(): ToggleFavoriteModelRequest {
	return { modelId: "", isFavorite: false }
}

export const ToggleFavoriteModelRequest: MessageFns<ToggleFavoriteModelRequest> = {
	encode(message: ToggleFavoriteModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.modelId !== "") {
			writer.uint32(10).string(message.modelId)
		}
		if (message.isFavorite !== false) {
			writer.uint32(16).bool(message.isFavorite)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ToggleFavoriteModelRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseToggleFavoriteModelRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.modelId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.isFavorite = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ToggleFavoriteModelRequest {
		return {
			modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
			isFavorite: isSet(object.isFavorite) ? globalThis.Boolean(object.isFavorite) : false,
		}
	},

	toJSON(message: ToggleFavoriteModelRequest): unknown {
		const obj: any = {}
		if (message.modelId !== "") {
			obj.modelId = message.modelId
		}
		if (message.isFavorite !== false) {
			obj.isFavorite = message.isFavorite
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ToggleFavoriteModelRequest>, I>>(base?: I): ToggleFavoriteModelRequest {
		return ToggleFavoriteModelRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ToggleFavoriteModelRequest>, I>>(object: I): ToggleFavoriteModelRequest {
		const message = createBaseToggleFavoriteModelRequest()
		message.modelId = object.modelId ?? ""
		message.isFavorite = object.isFavorite ?? false
		return message
	},
}

function createBaseGrpcRequest(): GrpcRequest {
	return { service: "", method: "", message: undefined, requestId: "" }
}

export const GrpcRequest: MessageFns<GrpcRequest> = {
	encode(message: GrpcRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.service !== "") {
			writer.uint32(10).string(message.service)
		}
		if (message.method !== "") {
			writer.uint32(18).string(message.method)
		}
		if (message.message !== undefined) {
			Value.encode(Value.wrap(message.message), writer.uint32(26).fork()).join()
		}
		if (message.requestId !== "") {
			writer.uint32(34).string(message.requestId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GrpcRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseGrpcRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.service = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.method = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.message = Value.unwrap(Value.decode(reader, reader.uint32()))
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.requestId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): GrpcRequest {
		return {
			service: isSet(object.service) ? globalThis.String(object.service) : "",
			method: isSet(object.method) ? globalThis.String(object.method) : "",
			message: isSet(object?.message) ? object.message : undefined,
			requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
		}
	},

	toJSON(message: GrpcRequest): unknown {
		const obj: any = {}
		if (message.service !== "") {
			obj.service = message.service
		}
		if (message.method !== "") {
			obj.method = message.method
		}
		if (message.message !== undefined) {
			obj.message = message.message
		}
		if (message.requestId !== "") {
			obj.requestId = message.requestId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<GrpcRequest>, I>>(base?: I): GrpcRequest {
		return GrpcRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<GrpcRequest>, I>>(object: I): GrpcRequest {
		const message = createBaseGrpcRequest()
		message.service = object.service ?? ""
		message.method = object.method ?? ""
		message.message = object.message ?? undefined
		message.requestId = object.requestId ?? ""
		return message
	},
}

function createBaseToggleClineRuleRequest(): ToggleClineRuleRequest {
	return { rulePath: "", isGlobal: false, enabled: false }
}

export const ToggleClineRuleRequest: MessageFns<ToggleClineRuleRequest> = {
	encode(message: ToggleClineRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.rulePath !== "") {
			writer.uint32(10).string(message.rulePath)
		}
		if (message.isGlobal !== false) {
			writer.uint32(16).bool(message.isGlobal)
		}
		if (message.enabled !== false) {
			writer.uint32(24).bool(message.enabled)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ToggleClineRuleRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseToggleClineRuleRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.rulePath = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.isGlobal = reader.bool()
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.enabled = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ToggleClineRuleRequest {
		return {
			rulePath: isSet(object.rulePath) ? globalThis.String(object.rulePath) : "",
			isGlobal: isSet(object.isGlobal) ? globalThis.Boolean(object.isGlobal) : false,
			enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
		}
	},

	toJSON(message: ToggleClineRuleRequest): unknown {
		const obj: any = {}
		if (message.rulePath !== "") {
			obj.rulePath = message.rulePath
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ToggleClineRuleRequest>, I>>(base?: I): ToggleClineRuleRequest {
		return ToggleClineRuleRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ToggleClineRuleRequest>, I>>(object: I): ToggleClineRuleRequest {
		const message = createBaseToggleClineRuleRequest()
		message.rulePath = object.rulePath ?? ""
		message.isGlobal = object.isGlobal ?? false
		message.enabled = object.enabled ?? false
		return message
	},
}

function createBaseDeleteClineRuleRequest(): DeleteClineRuleRequest {
	return { rulePath: "", isGlobal: false }
}

export const DeleteClineRuleRequest: MessageFns<DeleteClineRuleRequest> = {
	encode(message: DeleteClineRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.rulePath !== "") {
			writer.uint32(10).string(message.rulePath)
		}
		if (message.isGlobal !== false) {
			writer.uint32(16).bool(message.isGlobal)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): DeleteClineRuleRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseDeleteClineRuleRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.rulePath = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.isGlobal = reader.bool()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): DeleteClineRuleRequest {
		return {
			rulePath: isSet(object.rulePath) ? globalThis.String(object.rulePath) : "",
			isGlobal: isSet(object.isGlobal) ? globalThis.Boolean(object.isGlobal) : false,
		}
	},

	toJSON(message: DeleteClineRuleRequest): unknown {
		const obj: any = {}
		if (message.rulePath !== "") {
			obj.rulePath = message.rulePath
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal
		}
		return obj
	},

	create<I extends Exact<DeepPartial<DeleteClineRuleRequest>, I>>(base?: I): DeleteClineRuleRequest {
		return DeleteClineRuleRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<DeleteClineRuleRequest>, I>>(object: I): DeleteClineRuleRequest {
		const message = createBaseDeleteClineRuleRequest()
		message.rulePath = object.rulePath ?? ""
		message.isGlobal = object.isGlobal ?? false
		return message
	},
}

function createBaseAddRemoteServerRequestPayload(): AddRemoteServerRequestPayload {
	return { serverConfig: "" }
}

export const AddRemoteServerRequestPayload: MessageFns<AddRemoteServerRequestPayload> = {
	encode(message: AddRemoteServerRequestPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.serverConfig !== "") {
			writer.uint32(10).string(message.serverConfig)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AddRemoteServerRequestPayload {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		let end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAddRemoteServerRequestPayload()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.serverConfig = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AddRemoteServerRequestPayload {
		return { serverConfig: isSet(object.serverConfig) ? globalThis.String(object.serverConfig) : "" }
	},

	toJSON(message: AddRemoteServerRequestPayload): unknown {
		const obj: any = {}
		if (message.serverConfig !== "") {
			obj.serverConfig = message.serverConfig
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AddRemoteServerRequestPayload>, I>>(base?: I): AddRemoteServerRequestPayload {
		return AddRemoteServerRequestPayload.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AddRemoteServerRequestPayload>, I>>(object: I): AddRemoteServerRequestPayload {
		const message = createBaseAddRemoteServerRequestPayload()
		message.serverConfig = object.serverConfig ?? ""
		return message
	},
}

export type TaskControlServiceDefinition = typeof TaskControlServiceDefinition
export const TaskControlServiceDefinition = {
	name: "TaskControlService",
	fullName: "cline.task_control.TaskControlService",
	methods: {
		/** Core Task Flow */
		startTask: {
			name: "StartTask",
			requestType: NewTaskRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		clearTask: {
			name: "ClearTask",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** For user messages via INVOKE */
		sendUserInput: {
			name: "SendUserInput",
			requestType: InvokeRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		submitAskResponse: {
			name: "SubmitAskResponse",
			requestType: AskResponseRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		submitOptionsResponse: {
			name: "SubmitOptionsResponse",
			requestType: OptionsResponseRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		cancelTask: {
			name: "CancelTask",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		resumeLatestTask: {
			name: "ResumeLatestTask",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** State & History Management */
		getLatestState: {
			name: "GetLatestState",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		resetState: {
			name: "ResetState",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		showTaskWithId: {
			name: "ShowTaskWithId",
			requestType: ShowTaskWithIdRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		deleteTaskWithId: {
			name: "DeleteTaskWithId",
			requestType: DeleteTaskWithIdRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		exportCurrentTask: {
			name: "ExportCurrentTask",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		exportTaskWithId: {
			name: "ExportTaskWithId",
			requestType: ExportTaskWithIdRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		clearAllTaskHistory: {
			name: "ClearAllTaskHistory",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		requestTotalTasksSize: {
			name: "RequestTotalTasksSize",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** Settings Management */
		applyApiConfiguration: {
			name: "ApplyApiConfiguration",
			requestType: ApiConfiguration,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		applyAutoApprovalSettings: {
			name: "ApplyAutoApprovalSettings",
			requestType: ApplyAutoApprovalSettingsRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		applyBrowserSettings: {
			name: "ApplyBrowserSettings",
			requestType: ApplyBrowserSettingsRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** Added based on Step 8 refinement */
		applyChatSettings: {
			name: "ApplyChatSettings",
			requestType: ChatSettings,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		applyTelemetrySetting: {
			name: "ApplyTelemetrySetting",
			requestType: ApplyTelemetrySettingRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** Generic update */
		updateSettings: {
			name: "UpdateSettings",
			requestType: UpdateSettingsRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** Refined request type */
		togglePlanActMode: {
			name: "TogglePlanActMode",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** Model & Provider Refresh / Interaction */
		requestOllamaModels: {
			name: "RequestOllamaModels",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		requestLmStudioModels: {
			name: "RequestLmStudioModels",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		requestVsCodeLmModels: {
			name: "RequestVsCodeLmModels",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		refreshOpenRouterModels: {
			name: "RefreshOpenRouterModels",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		refreshRequestyModels: {
			name: "RefreshRequestyModels",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		refreshOpenAiModels: {
			name: "RefreshOpenAiModels",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		toggleFavoriteModel: {
			name: "ToggleFavoriteModel",
			requestType: ToggleFavoriteModelRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** MCP Management */
		addRemoteServer: {
			name: "AddRemoteServer",
			requestType: AddRemoteServerRequestPayload,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		restartMcpServer: {
			name: "RestartMcpServer",
			requestType: RestartMcpServerRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		deleteMcpServer: {
			name: "DeleteMcpServer",
			requestType: DeleteMcpServerRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		toggleMcpServer: {
			name: "ToggleMcpServer",
			requestType: ToggleMcpServerRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		updateMcpTimeout: {
			name: "UpdateMcpTimeout",
			requestType: UpdateMcpTimeoutRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		fetchMcpMarketplace: {
			name: "FetchMcpMarketplace",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		silentlyRefreshMcpMarketplace: {
			name: "SilentlyRefreshMcpMarketplace",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		downloadMcp: {
			name: "DownloadMcp",
			requestType: DownloadMcpRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		fetchLatestMcpServersFromHub: {
			name: "FetchLatestMcpServersFromHub",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		toggleToolAutoApprove: {
			name: "ToggleToolAutoApprove",
			requestType: ToggleToolAutoApproveRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** File/System Interaction */
		openImage: {
			name: "OpenImage",
			requestType: OpenImageRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		openInBrowser: {
			name: "OpenInBrowser",
			requestType: OpenInBrowserRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		openFile: {
			name: "OpenFile",
			requestType: OpenFileRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		createRuleFile: {
			name: "CreateRuleFile",
			requestType: CreateRuleFileRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		refreshClineRules: {
			name: "RefreshClineRules",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		getRelativePaths: {
			name: "GetRelativePaths",
			requestType: GetRelativePathsRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		searchFiles: {
			name: "SearchFiles",
			requestType: SearchFilesRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		getDetectedChromePath: {
			name: "GetDetectedChromePath",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		relaunchChromeDebugMode: {
			name: "RelaunchChromeDebugMode",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		toggleClineRule: {
			name: "ToggleClineRule",
			requestType: ToggleClineRuleRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		deleteClineRule: {
			name: "DeleteClineRule",
			requestType: DeleteClineRuleRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** Auth & Account */
		accountLoginClicked: {
			name: "AccountLoginClicked",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		accountLogoutClicked: {
			name: "AccountLogoutClicked",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		showAccountViewClicked: {
			name: "ShowAccountViewClicked",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		authStateChanged: {
			name: "AuthStateChanged",
			requestType: AuthStateChangedRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		authCallback: {
			name: "AuthCallback",
			requestType: AuthCallbackRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		fetchUserCreditsData: {
			name: "FetchUserCreditsData",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** Misc UI/Interaction Triggers */
		webviewDidLaunch: {
			name: "WebviewDidLaunch",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		didShowAnnouncement: {
			name: "DidShowAnnouncement",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		openMention: {
			name: "OpenMention",
			requestType: OpenMentionRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		showChatView: {
			name: "ShowChatView",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		openMcpSettings: {
			name: "OpenMcpSettings",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		checkpointRestore: {
			name: "CheckpointRestore",
			requestType: CheckpointRestoreRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		taskCompletionViewChanges: {
			name: "TaskCompletionViewChanges",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		openExtensionSettings: {
			name: "OpenExtensionSettings",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		showMcpView: {
			name: "ShowMcpView",
			requestType: ShowMcpViewRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		/** Generic open settings */
		openSettings: {
			name: "OpenSettings",
			requestType: Empty,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		fetchOpenGraphData: {
			name: "FetchOpenGraphData",
			requestType: FetchOpenGraphDataRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		checkIsImageUrl: {
			name: "CheckIsImageUrl",
			requestType: CheckIsImageUrlRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		taskFeedback: {
			name: "TaskFeedback",
			requestType: TaskFeedbackRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
		searchCommits: {
			name: "SearchCommits",
			requestType: SearchCommitsRequest,
			requestStream: false,
			responseType: ExtensionMessage,
			responseStream: true,
			options: {},
		},
	},
} as const

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function longToNumber(int64: { toString(): string }): number {
	const num = globalThis.Number(int64.toString())
	if (num > globalThis.Number.MAX_SAFE_INTEGER) {
		throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER")
	}
	if (num < globalThis.Number.MIN_SAFE_INTEGER) {
		throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER")
	}
	return num
}

function isObject(value: any): boolean {
	return typeof value === "object" && value !== null
}

function isSet(value: any): boolean {
	return value !== null && value !== undefined
}

export interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter
	decode(input: BinaryReader | Uint8Array, length?: number): T
	fromJSON(object: any): T
	toJSON(message: T): unknown
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
