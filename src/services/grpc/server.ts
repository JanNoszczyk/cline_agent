import * as grpc from "@grpc/grpc-js"
// Removed incorrect lookupService import
// Removed incorrect stream import: import *sl from 'node:stream';
import * as fs from "fs" // Added for file logging
// import * as protoLoader from "@grpc/proto-loader"; // Will be removed
import * as path from "path"
import * as vscode from "vscode"
// Import generated services and types
// Updated to import the *ServiceService objects generated by outputServices=grpc-js
import { TaskControlServiceService as TaskControlServiceDefinition } from "../../shared/proto/task_control"
import { BrowserServiceService as BrowserServiceDefinition } from "../../shared/proto/browser"
import { CheckpointsServiceService as CheckpointsServiceDefinition } from "../../shared/proto/checkpoints"
import { McpServiceService as McpServiceDefinition } from "../../shared/proto/mcp"
import { FileServiceService as FileServiceDefinition } from "../../shared/proto/file"
import { TaskServiceService as TaskServiceDefinition } from "../../shared/proto/task"
import { WebServiceService as WebContentServiceDefinition } from "../../shared/proto/web" // Corrected import and aliased
import { AccountServiceService as AccountServiceDefinition } from "../../shared/proto/account"
// Note: Actual service definition names might be slightly different based on ts-proto generation (e.g., TaskControlServiceDefinition)
// We'll need to inspect the generated files if these names are incorrect.
// For message types, GrpcBridge already imports them via taskControlPb.
// import { adaptGenericServiceDefinitionForGrpcJs } from "./grpc-service-adapter"; // No longer needed
// import { mapAccountService } from "./mapper/account-mapper"; // Commented out: File not found
// import { mapBrowserService } from "./mapper/browser-mapper"; // Commented out: File not found
// import { mapCheckpointsService } from "./mapper/checkpoints-mapper"; // Commented out: File not found
// import { mapFileService } from "./mapper/file-mapper"; // Commented out: File not found
// import { mapMcpService } from "./mapper/mcp-mapper"; // Commented out: File not found
// import { mapTaskControlService } from "./mapper/task-control-mapper"; // Commented out: File not found
// import { mapTaskService } from "./mapper/task-mapper"; // Commented out: File not found
// import { mapWebContentService } from "./mapper/web-content-mapper"; // Commented out: File not found
import { Logger } from "../../services/logging/Logger" // Import Logger class
import util from "util" // Import util for inspect
// Removed GrpcRequest, GrpcResponse import as types.ts not found and types not used directly here
// import { GrpcRequest, GrpcResponse } from '../../shared/types';
import { EventEmitter } from "events"
import { setTimeout as setTimeoutPromise } from "node:timers/promises" // Import setTimeoutPromise
// Removed incorrect service implementation imports - these should be passed in or created differently
// import { TaskControlServiceImpl } from './mapper';
// import { BrowserServiceImpl } from './browser-mapper';
// import { CheckpointsServiceImpl } from './checkpoints-mapper';
// import { McpServiceImpl } from './mcp-mapper';
// Removed incorrect getProtoPath import
// Duplicate util import removed
import { Controller } from "../../core/controller" // Import Controller type

// --- Proto loading moved inside startExternalGrpcServer ---

export class GrpcNotifier extends EventEmitter {
	override emit(eventName: string | symbol, ...args: any[]): boolean {
		const eventNameStr = eventName.toString()
		// Assuming the first arg is typically clientId for our relevant events
		const clientId = args.length > 0 ? args[0] : "unknown_client"
		let messageDetails = ""

		if (eventNameStr === "sayUpdate" && args.length > 1 && args[1]) {
			// args[1] is protoClineMsg
			const protoClineMsg = args[1]
			const partial = args.length > 2 ? args[2] : "unknown_partial_status"
			let textSnippet = ""
			if (protoClineMsg.textBlock?.text) {
				textSnippet = protoClineMsg.textBlock.text.substring(0, 50).replace(/\n/g, "\\n") + "..."
			} else if (protoClineMsg.toolUseBlock) {
				textSnippet = `ToolUse: ${protoClineMsg.toolUseBlock.name}`
			} else if (protoClineMsg.toolResultBlock) {
				textSnippet = `ToolResult: ${protoClineMsg.toolResultBlock.toolUseId}`
			}
			messageDetails = `(clientId: ${clientId}, partial: ${partial}, content: ${textSnippet})`
		} else if (eventNameStr === "stateUpdate" && args.length > 1 && args[1]) {
			const state = args[1] // protoState
			messageDetails = `(clientId: ${clientId}, tasks: ${state.tasks?.length}, mcpServers: ${state.mcpServers?.length})`
		} else if (eventNameStr === "askRequest" && args.length > 1 && args[1]) {
			const protoClineMsg = args[1]
			let askDetails = ""
			if (protoClineMsg.textBlock?.text) {
				askDetails = protoClineMsg.textBlock.text.substring(0, 50).replace(/\n/g, "\\n") + "..."
			}
			messageDetails = `(clientId: ${clientId}, askContent: ${askDetails})`
		} else if (eventNameStr === "error" && args.length > 1) {
			messageDetails = `(clientId: ${clientId}, error: ${String(args[1]).substring(0, 100)})`
		} else {
			messageDetails = `(clientId: ${clientId}, args: ${util.inspect(args.slice(1), { depth: 0, breakLength: Infinity })})`
		}

		const logMessage = `[GrpcNotifier] Emitting event: '${eventNameStr}' ${messageDetails}`
		Logger.info(logMessage) // For VSCode console
		appendToGrpcLogFile(logMessage) // For file log

		return super.emit(eventName, ...args)
	}
}

let server: grpc.Server | null = null
let grpcNotifier: GrpcNotifier | null = null
let grpcLogFilePath: string | null = null // Variable for log file path

// Helper function to append to log file
function appendToGrpcLogFile(message: string) {
	if (grpcLogFilePath) {
		try {
			const timestamp = new Date().toISOString()
			fs.appendFileSync(grpcLogFilePath, `${timestamp} - ${message}\n`, "utf8")
		} catch (e: any) {
			// Log error to console if file logging fails
			console.error(`[CONSOLE GRPC LOG FILE ERROR] Failed to write to ${grpcLogFilePath}: ${e.message}`)
		}
	}
}

export function getGrpcNotifier(): GrpcNotifier | null {
	return grpcNotifier
}

export function getGrpcServer(): grpc.Server | null {
	return server
}

// Define expected structure for service implementations (adjust as needed based on Controller)
interface ServiceImplementations {
	taskControl: grpc.UntypedServiceImplementation
	browser: grpc.UntypedServiceImplementation
	checkpoints: grpc.UntypedServiceImplementation
	mcp: grpc.UntypedServiceImplementation
	file: grpc.UntypedServiceImplementation
	task: grpc.UntypedServiceImplementation
	webContent: grpc.UntypedServiceImplementation
	account: grpc.UntypedServiceImplementation
}

export async function startExternalGrpcServer(
	context: vscode.ExtensionContext,
	controller: Controller, // Use imported Controller type
	// Assume implementations are provided, e.g., via the controller or a dedicated factory
	serviceImplementations: ServiceImplementations,
): Promise<{ server: grpc.Server; notifier: GrpcNotifier }> {
	// Initialize log file path
	if (!grpcLogFilePath) {
		// Initialize only once
		const envLogPath = process.env.GRPC_SERVER_DEBUG_LOG_PATH
		let determinedLogPath: string | null = null

		console.log("[CONSOLE External GRPC] Initializing gRPC server log path...")

		if (envLogPath) {
			console.log(`[CONSOLE External GRPC] Environment variable GRPC_SERVER_DEBUG_LOG_PATH is set to: ${envLogPath}`)
			determinedLogPath = envLogPath
		} else {
			console.warn("[CONSOLE External GRPC] GRPC_SERVER_DEBUG_LOG_PATH not set. Falling back to default log path logic.")
			let fallbackLogDir: string | null = null
			const fallbackLogFilename = "grpc_server_debug.log"
			if (context.storageUri && context.storageUri.fsPath) {
				fallbackLogDir = context.storageUri.fsPath
				console.log(`[CONSOLE External GRPC] Using fallback log directory from context.storageUri: ${fallbackLogDir}`)
			} else {
				console.warn(
					"[CONSOLE External GRPC] context.storageUri.fsPath is not available. Using /tmp as fallback log directory.",
				)
				fallbackLogDir = "/tmp"
			}
			determinedLogPath = path.join(fallbackLogDir, fallbackLogFilename)
		}

		if (determinedLogPath) {
			try {
				const logDirToEnsure = path.dirname(determinedLogPath)
				if (!fs.existsSync(logDirToEnsure)) {
					console.log(
						`[CONSOLE External GRPC] Log directory ${logDirToEnsure} for path ${determinedLogPath} does not exist. Creating...`,
					)
					fs.mkdirSync(logDirToEnsure, { recursive: true })
					console.log(`[CONSOLE External GRPC] Log directory ${logDirToEnsure} created.`)
				}

				// Check if the determined path is a directory (it shouldn't be)
				if (fs.existsSync(determinedLogPath) && fs.statSync(determinedLogPath).isDirectory()) {
					console.error(
						`[CONSOLE External GRPC] ERROR: Log path ${determinedLogPath} exists and is a directory. Attempting to remove and recreate as file.`,
					)
					fs.rmSync(determinedLogPath, { recursive: true, force: true }) // Remove if it's a directory
					fs.writeFileSync(determinedLogPath, "", "utf8") // Create as empty file
					console.log(`[CONSOLE External GRPC] Log path ${determinedLogPath} recreated as an empty file.`)
				}

				grpcLogFilePath = determinedLogPath
				const initMessage = `GRPC Server Log Initialized at ${new Date().toISOString()} (Log Path: ${grpcLogFilePath})\nUsing ${envLogPath ? "GRPC_SERVER_DEBUG_LOG_PATH" : "fallback path"}.\n`
				fs.writeFileSync(grpcLogFilePath, initMessage, "utf8") // Create/overwrite with init message
				console.log(`[CONSOLE External GRPC] Successfully initialized logging to file: ${grpcLogFilePath}`)
			} catch (e: any) {
				console.error(
					`[CONSOLE External GRPC] Failed to initialize log file at ${determinedLogPath}: ${e.message}. File logging disabled.`,
				)
				grpcLogFilePath = null // Disable file logging if any setup step fails
			}
		} else {
			console.error("[CONSOLE External GRPC] No log path could be determined. File logging disabled.")
			grpcLogFilePath = null // Ensure it's null if no path was determined
		}
	}

	const log = (message: string) => {
		console.log(message)
		appendToGrpcLogFile(message)
	}
	const logError = (message: string) => {
		console.error(message)
		appendToGrpcLogFile(`ERROR: ${message}`)
	}

	log("[CONSOLE External GRPC] Top of startExternalGrpcServer function.")
	if (server) {
		Logger.info("[External GRPC] Server already running.") // Use Logger.info
		log("[CONSOLE External GRPC] Server already running.")
		return { server, notifier: grpcNotifier! }
	}

	Logger.info("[External GRPC] Starting startExternalGrpcServer function...") // Use Logger.info
	log("[CONSOLE External GRPC] Starting startExternalGrpcServer function...")

	try {
		log("[CONSOLE External GRPC] Inside try block, before loading protos.")
		// --- Load Protos using context.extensionPath ---
		Logger.info("[External GRPC] Constructing proto paths using context.extensionPath...")
		log("[CONSOLE External GRPC] Constructing proto paths using context.extensionPath...")
		// --- Proto Loading Removed ---
		// Static imports will be used instead.

		const MAX_MESSAGE_LENGTH = 50 * 1024 * 1024 // 50 MB
		server = new grpc.Server({
			"grpc.enable_channelz": 0, // Disable Channelz
			"grpc.max_receive_message_length": MAX_MESSAGE_LENGTH,
			"grpc.max_send_message_length": MAX_MESSAGE_LENGTH,
		})
		grpcNotifier = new GrpcNotifier()
		Logger.info(
			`[External GRPC] gRPC server instance (Channelz disabled, Max Msg Length: ${MAX_MESSAGE_LENGTH / (1024 * 1024)}MB) and notifier created.`,
		) // Use Logger.info
		log("[CONSOLE External GRPC] gRPC server instance (Channelz disabled) and notifier created.")

		// --- Browser Service ---
		// Assuming BrowserServiceDefinition is the generated service definition from ts-proto
		const browserServiceFQN = "cline.BrowserService"
		if (BrowserServiceDefinition && serviceImplementations.browser) {
			Logger.info(`[External GRPC] Registering ${browserServiceFQN} (using static import)...`)
			log(`[CONSOLE External GRPC] Registering ${browserServiceFQN} (using static import)...`)
			server.addService(BrowserServiceDefinition, serviceImplementations.browser) // Removed adapter
			Logger.info(`[External GRPC] Registered ${browserServiceFQN}.`)
			log(`[CONSOLE External GRPC] Registered ${browserServiceFQN}.`)
		} else {
			const errorMsg = `[External GRPC] BrowserService definition ${!BrowserServiceDefinition ? `not found via static import!` : "implementation not provided!"}`
			Logger.error(errorMsg)
			logError(errorMsg)
		}

		// --- Checkpoints Service ---
		const checkpointsServiceFQN = "cline.CheckpointsService"
		if (CheckpointsServiceDefinition && serviceImplementations.checkpoints) {
			Logger.info(`[External GRPC] Registering ${checkpointsServiceFQN} (using static import)...`)
			log(`[CONSOLE External GRPC] Registering ${checkpointsServiceFQN} (using static import)...`)
			server.addService(CheckpointsServiceDefinition, serviceImplementations.checkpoints) // Removed adapter
			Logger.info(`[External GRPC] Registered ${checkpointsServiceFQN}.`)
			log(`[CONSOLE External GRPC] Registered ${checkpointsServiceFQN}.`)
		} else {
			const errorMsg = `[External GRPC] CheckpointsService definition ${!CheckpointsServiceDefinition ? `not found via static import!` : "implementation not provided!"}`
			Logger.error(errorMsg)
			logError(errorMsg)
		}

		// --- MCP Service ---
		const mcpServiceFQN = "cline.McpService"
		if (McpServiceDefinition && serviceImplementations.mcp) {
			Logger.info(`[External GRPC] Registering ${mcpServiceFQN} (using static import)...`)
			log(`[CONSOLE External GRPC] Registering ${mcpServiceFQN} (using static import)...`)
			server.addService(McpServiceDefinition, serviceImplementations.mcp) // Removed adapter
			Logger.info(`[External GRPC] Registered ${mcpServiceFQN}.`)
			log(`[CONSOLE External GRPC] Registered ${mcpServiceFQN}.`)
		} else {
			const errorMsg = `[External GRPC] McpService definition ${!McpServiceDefinition ? `not found via static import!` : "implementation not provided!"}`
			Logger.error(errorMsg)
			logError(errorMsg)
		}

		// --- TaskControl Service ---
		// Assuming TaskControlServiceDefinition is the generated service definition
		const taskControlServiceFQN = "cline.task_control.TaskControlService"
		if (TaskControlServiceDefinition && serviceImplementations.taskControl) {
			Logger.info(`[External GRPC] Registering ${taskControlServiceFQN} (using static import)...`)
			log(`[CONSOLE External GRPC] Registering ${taskControlServiceFQN} (using static import)...`)
			try {
				server.addService(TaskControlServiceDefinition, serviceImplementations.taskControl) // Removed adapter
				Logger.info(`[External GRPC] server.addService(${taskControlServiceFQN}) completed.`)
				log(`[CONSOLE External GRPC] server.addService(${taskControlServiceFQN}) completed.`)
			} catch (addServiceError: any) {
				const errorMsg = `[External GRPC] Error during server.addService(${taskControlServiceFQN}): ${addServiceError.message}`
				Logger.error(errorMsg)
				logError(errorMsg)
			}
		} else {
			const errorMsg = `[External GRPC] TaskControlService definition ${!TaskControlServiceDefinition ? `not found via static import!` : "implementation not provided!"}`
			Logger.error(errorMsg)
			logError(errorMsg)
			// Logger.debug removed for verbosity
			// Logger.debug removed for verbosity
			// Logger.debug removed for verbosity
		}
		// Add log *after* the if/else
		Logger.info("[External GRPC] Finished attempting TaskControlService registration.") // NEW LOG
		log("[CONSOLE External GRPC] Finished attempting TaskControlService registration.")

		// --- File Service ---
		const fileServiceFQN = "cline.FileService"
		if (FileServiceDefinition && serviceImplementations.file) {
			Logger.info(`[External GRPC] Registering ${fileServiceFQN} (using static import)...`)
			log(`[CONSOLE External GRPC] Registering ${fileServiceFQN} (using static import)...`)
			server.addService(FileServiceDefinition, serviceImplementations.file) // Removed adapter
			Logger.info(`[External GRPC] Registered ${fileServiceFQN}.`)
			log(`[CONSOLE External GRPC] Registered ${fileServiceFQN}.`)
		} else {
			const errorMsg = `[External GRPC] FileService definition ${!FileServiceDefinition ? `not found via static import!` : "implementation not provided!"}`
			Logger.error(errorMsg)
			logError(errorMsg)
		}

		// --- Task Service ---
		const taskServiceFQN = "cline.TaskService"
		if (TaskServiceDefinition && serviceImplementations.task) {
			Logger.info(`[External GRPC] Registering ${taskServiceFQN} (using static import)...`)
			log(`[CONSOLE External GRPC] Registering ${taskServiceFQN} (using static import)...`)
			server.addService(TaskServiceDefinition, serviceImplementations.task) // Removed adapter
			Logger.info(`[External GRPC] Registered ${taskServiceFQN}.`)
			log(`[CONSOLE External GRPC] Registered ${taskServiceFQN}.`)
		} else {
			const errorMsg = `[External GRPC] TaskService definition ${!TaskServiceDefinition ? `not found via static import!` : "implementation not provided!"}`
			Logger.error(errorMsg)
			logError(errorMsg)
		}

		// --- WebContent Service ---
		const webContentServiceFQN = "cline.WebContentService" // Assuming this is the intended FQN, proto has WebService
		if (WebContentServiceDefinition && serviceImplementations.webContent) {
			Logger.info(`[External GRPC] Registering ${webContentServiceFQN} (using static import)...`)
			log(`[CONSOLE External GRPC] Registering ${webContentServiceFQN} (using static import)...`)
			server.addService(WebContentServiceDefinition, serviceImplementations.webContent) // Removed adapter
			Logger.info(`[External GRPC] Registered ${webContentServiceFQN}.`)
			log(`[CONSOLE External GRPC] Registered ${webContentServiceFQN}.`)
		} else {
			const errorMsg = `[External GRPC] WebContentService definition ${!WebContentServiceDefinition ? `not found via static import!` : "implementation not provided!"}`
			Logger.error(errorMsg)
			logError(errorMsg)
		}

		// --- Account Service ---
		const accountServiceFQN = "cline.AccountService"
		if (AccountServiceDefinition && serviceImplementations.account) {
			Logger.info(`[External GRPC] Registering ${accountServiceFQN} (using static import)...`)
			log(`[CONSOLE External GRPC] Registering ${accountServiceFQN} (using static import)...`)
			server.addService(AccountServiceDefinition, serviceImplementations.account) // Removed adapter
			Logger.info(`[External GRPC] Registered ${accountServiceFQN}.`)
			log(`[CONSOLE External GRPC] Registered ${accountServiceFQN}.`)
		} else {
			const errorMsg = `[External GRPC] AccountService definition ${!AccountServiceDefinition ? `not found via static import!` : "implementation not provided!"}`
			Logger.error(errorMsg)
			logError(errorMsg)
		}

		Logger.info("[External GRPC] Finished service registration.") // Use Logger.info
		log("[CONSOLE External GRPC] Finished service registration.")

		const port = 50051
		// Try 0.0.0.0 first for Docker compatibility, then fallback to localhost addresses
		const hosts = ["0.0.0.0", "127.0.0.1", "localhost"]
		Logger.info(`[External GRPC] Will try binding to hosts in order: ${hosts.join(", ")}`)
		log(`[CONSOLE External GRPC] Will try binding to hosts in order: ${hosts.join(", ")}`)

		// Log network interface diagnostics
		try {
			const os = require("os")
			const networkInterfaces = os.networkInterfaces()
			log(`[CONSOLE External GRPC] Available network interfaces: ${JSON.stringify(networkInterfaces, null, 2)}`)
		} catch (netErr: any) {
			log(`[CONSOLE External GRPC] Could not get network interfaces: ${netErr.message}`)
		}

		// Add a delay before attempting bindAsync to allow network interfaces to stabilize in container
		const initialDelay = 10000 // 10 seconds initial delay
		const maxRetries = 5 // Reduced retries for this diagnostic
		const retryDelay = 4000 // 2 seconds between subsequent retries

		log(
			`[CONSOLE External GRPC] Initializing gRPC server bind sequence. Initial delay: ${initialDelay}ms, Max retries: ${maxRetries}, Retry delay: ${retryDelay}ms.`,
		)

		for (let attempt = 1; attempt <= maxRetries; attempt++) {
			log(`[CONSOLE External GRPC] Bind attempt ${attempt}/${maxRetries}...`)

			const currentDelay = attempt === 1 ? initialDelay : retryDelay
			if (currentDelay > 0) {
				log(`[CONSOLE External GRPC] Waiting ${currentDelay}ms before bind attempt ${attempt}...`)
				await setTimeoutPromise(currentDelay)
				log(`[CONSOLE External GRPC] Delay finished for attempt ${attempt}.`)
			}

			// Try each host in order for this attempt
			let bindSuccessful = false
			let lastError: Error | null = null

			for (const host of hosts) {
				try {
					log(`[CONSOLE External GRPC] Trying host ${host} on attempt ${attempt}...`)
					const boundPort = await new Promise<number>((resolveBind, rejectBind) => {
						Logger.info(
							`[External GRPC] bindAsync initiated for ${host} (attempt ${attempt}). Waiting for callback...`,
						)
						log(
							`[CONSOLE External GRPC] bindAsync initiated for ${host} (attempt ${attempt}). Waiting for callback...`,
						)
						// Use direct string concatenation for better compatibility
						const bindAddress = host + ":" + port.toString()
						log(`[CONSOLE External GRPC] Binding to address: "${bindAddress}"`)
						server!.bindAsync(bindAddress, grpc.ServerCredentials.createInsecure(), (err, port) => {
							Logger.info(`[External GRPC] bindAsync callback executed for ${host} (attempt ${attempt}).`)
							log(`[CONSOLE External GRPC] bindAsync callback executed for ${host} (attempt ${attempt}).`)
							if (err) {
								const errorMsg = `[External GRPC] Server binding error for ${host} (attempt ${attempt}): ${err.message}`
								Logger.error(errorMsg)
								logError(errorMsg)
								return rejectBind(err)
							}
							resolveBind(port)
						})
					})

					Logger.info(
						`[External GRPC] Server bound successfully to ${host}:${boundPort} (attempt ${attempt}). Attempting to start server...`,
					)
					log(
						`[CONSOLE External GRPC] Server bound successfully to ${host}:${boundPort} (attempt ${attempt}). Attempting to start server...`,
					)

					server!.start()
					Logger.info(
						`[External GRPC] server.start() called synchronously. Server should be listening now on ${host}:${boundPort} (attempt ${attempt}).`,
					)
					log(
						`[CONSOLE External GRPC] server.start() called synchronously. Server should be listening now on ${host}:${boundPort} (attempt ${attempt}).`,
					)

					// --- Temporarily REMOVED self-connection test for diagnostics ---
					Logger.info(
						`[External GRPC] Self-connection test SKIPPED for diagnostics (attempt ${attempt}). Assuming server is OK if start didn't throw.`,
					)
					log(
						`[CONSOLE External GRPC] Self-connection test SKIPPED for diagnostics (attempt ${attempt}). Assuming server is OK if start didn't throw.`,
					)
					bindSuccessful = true
					break // Break out of host loop on success
					// --- End of REMOVED self-connection test ---
				} catch (bindOrStartErr: any) {
					lastError = bindOrStartErr
					const errorMsg = `[External GRPC] Error during bind/start for ${host} (attempt ${attempt}): ${bindOrStartErr.message}`
					Logger.error(errorMsg)
					logError(errorMsg)
					// Continue to next host
				}
			}

			if (bindSuccessful) {
				return { server: server!, notifier: grpcNotifier! } // Success, exit attempt loop and return
			}

			if (attempt < maxRetries) {
				log(
					`[CONSOLE External GRPC] Attempt ${attempt} failed for all hosts. Retrying in ${retryDelay / 1000} seconds...`,
				)
			} else {
				const finalErrorMsg = `[External GRPC] All ${maxRetries} bind attempts failed for all hosts. Last error: ${lastError?.message || "Unknown error"}`
				Logger.error(finalErrorMsg)
				logError(finalErrorMsg)
				if (server) {
					server.tryShutdown(() => {})
				}
				server = null
				grpcNotifier = null
				throw new Error(finalErrorMsg)
			}
		}
		// Should not be reached if successful.
		const finalLoopErrorMsg = `[External GRPC] All bind attempts failed after loop completion (this indicates a logic flaw).`
		Logger.error(finalLoopErrorMsg)
		logError(finalLoopErrorMsg)
		if (server) {
			server.tryShutdown(() => {})
		}
		server = null
		grpcNotifier = null
		throw new Error(finalLoopErrorMsg)
	} catch (error: any) {
		const errorMsg = `[External GRPC] Error during server setup: ${error.message}`
		Logger.error(errorMsg)
		logError(errorMsg)
		if (server) {
			// Attempt graceful shutdown if server instance exists
			server.tryShutdown(() => {
				Logger.info("[External GRPC] Server shut down after setup error.") // Use Logger.info
				log("[CONSOLE External GRPC] Server shut down after setup error.")
			})
		}
		server = null
		grpcNotifier = null
		throw error // Re-throw the error to indicate failure
	}
}

export function stopExternalGrpcServer(): Promise<void> {
	const log = (message: string) => {
		// Local log function for stop server
		console.log(message)
		appendToGrpcLogFile(message)
	}
	log("[CONSOLE External GRPC] stopExternalGrpcServer called.")
	return new Promise((resolve) => {
		if (server) {
			Logger.info("[External GRPC] Shutting down gRPC server...") // Use Logger.info
			log("[CONSOLE External GRPC] Shutting down gRPC server...")
			server.tryShutdown(() => {
				Logger.info("[External GRPC] gRPC server shut down.") // Use Logger.info
				log("[CONSOLE External GRPC] gRPC server shut down.")
				server = null
				grpcNotifier = null
				resolve()
			})
		} else {
			Logger.info("[External GRPC] Server not running, no need to shut down.") // Use Logger.info
			log("[CONSOLE External GRPC] Server not running, no need to shut down.")
			resolve()
		}
	})
}

// Example of how the notifier might be used (implementation details depend on your controller)
// grpcNotifier?.emit('someEvent', { data: 'example' });
